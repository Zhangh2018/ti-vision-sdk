C6000 C/C++ CODE GENERATION TOOLS
7.4.2 November 2012
Defect History

------------------------------------------------------------------------------
Table of Contents
------------------------------------------------------------------------------
1. 7.4.2 Fixed Code Generation Tools Defects
2. 7.4.1 Fixed Code Generation Tools Defects
3. 7.4.0 Fixed Code Generation Tools Defects
4. 7.4.0B2 Fixed Code Generation Tools Defects
5. Current Known Issues


------------------------------------------------------------------------------
1. 7.4.2 Fixed Code Generation Tools Defects
------------------------------------------------------------------------------

------------------------------------------------------------------------------
FIXED  SDSCM00042974
------------------------------------------------------------------------------

Summary            : Resource conflict between instruction in SPLOOP and
		     instruction in its epilog causing hardware exception

Fixed in           : 7.4.2
Severity           : S2 - Major
Affected Component : Code Generator

Description: 
This bug only happens at the epilog area of a SPLOOP. It could cause 
resource conflict which leads to a hardware exception. There is no 
obvious link between the user's C source code to this bug so it is hard
to avoid this problem at the source code level.

The fix of this bug could cause performance degradation. Usually this 
happens for an early exit SPLOOP where the loop's trip count is less
than the number of iterations running in parallel. The performance could be 
severly worse if this SPLOOP is the inner loop and the outer loop 
executes many times. If this happens, there is no work around to fix
this problem.

This fix could also cause code size increase. But it is minimal.
Usually it is one NOP per SPLOOP.

------------------------------------------------------------------------------
FIXED  SDSCM00043174
------------------------------------------------------------------------------

Summary            : Linker fails to honor specific placement for function from
		     RTS library

Fixed in           : 7.4.2
Severity           : S2 - Major
Affected Component : COFF Linker

Description: 
Linker now honors section placement specification.

------------------------------------------------------------------------------
FIXED  SDSCM00044285
------------------------------------------------------------------------------

Summary            : scanf %[^ mistakenly writes EOF to output

Fixed in           : 7.4.2
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
When using ^ to negagte the scan set [ sscanf(in, "%[^abc]", out) ],
scanf would incorrectly copy EOF to the output string.	It should
instead stop reading input and return as normal.

------------------------------------------------------------------------------
FIXED  SDSCM00044581
------------------------------------------------------------------------------

Summary            : Optimizer continues abort after CQ44463

Fixed in           : 7.4.2
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

------------------------------------------------------------------------------
FIXED  SDSCM00045105
------------------------------------------------------------------------------

Summary            : Empty struct as field of parent struct may cause optimiser
		     abort

Fixed in           : 7.4.2
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
If a struct contains another struct, and the inner struct has no
fields, and the parent struct is copied whole through an assignment of 
struct-type variables, the optimiser may abort.

------------------------------------------------------------------------------
FIXED  SDSCM00045197
------------------------------------------------------------------------------

Summary            : strip6x segmentation fault on ELF executable

Fixed in           : 7.4.2
Severity           : S2 - Major
Affected Component : Strip Utility

Description: 
The crash occurs when trying to delete an unused ELF segment, which
only appear in executable files.  

------------------------------------------------------------------------------
FIXED  SDSCM00045232
------------------------------------------------------------------------------

Summary            : Incorrect linker symbol value after multiple partial links

Fixed in           : 7.4.2
Severity           : S2 - Major
Affected Component : ELF Linker

Description: 
Linker symbols whose values depend on section placement were getting 
assigned absolute values instead of section relative values in partial 
links.	These are symbols that are defined using the '.' operator,
and/or those defined using the linker command file keywords such as START,
END, LOAD_START etc. As a result, the final link would assign incorrect
values to these symbols.  


------------------------------------------------------------------------------
2. 7.4.1 Fixed Code Generation Tools Defects
------------------------------------------------------------------------------

------------------------------------------------------------------------------
FIXED  SDSCM00043713
------------------------------------------------------------------------------

Summary            : Linker fails with internal error

Fixed in           : 7.4.1
Severity           : S2 - Major
Affected Component : Linker

Description: 
Linker sometimes fails with internal error lnk470.exe experienced an
unhandled exception

The linker no longer makes the assumption that the decompression
routine's section can be automatically removed when the linker
determines the decompression routine is not needed.

Workaround: 
No workaround

------------------------------------------------------------------------------
FIXED  SDSCM00044048
------------------------------------------------------------------------------

Summary            : Enabling vectorization produces incorrect code

Fixed in           : 7.4.1
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
In certain cases, enabling vectorization could result in incorrect code

Workaround: 
Disable vectorization or optimization.

------------------------------------------------------------------------------
FIXED  SDSCM00044222
------------------------------------------------------------------------------

Summary            : Arm _set_interrupt_priority intrinsic and C6x __mfence()
		     intrinsic should be treated as a
		     barrier in the compiler.

Fixed in           : 7.4.1
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
There are 2 intrinsics that should be treated as a barrier in the
compiler but are not. They are

1. C6x _mfence intrinsic
2. ARM _set_interrupt_priority intrinsic

This means that loads and stores (memory operations) above and below
the intrinsics should not move across the intrinsic. It is possible
that such an instruction could be scheduled before or after the
intrinsic. This bug is fixed in the following compiler versions

1. ARM 5.0.1
2. C6x 7.4.1


Workaround: No workaround 


------------------------------------------------------------------------------
FIXED  SDSCM00044377
------------------------------------------------------------------------------

Summary            : Disassembler fails to decode LDNDW when scaling mode is
		     used

Fixed in           : 7.4.1
Severity           : S3 - Minor
Affected Component : Disassembler (dis)

Description: 
The disassembler would mistakenly fail to disassemble LDNDW and STNDW
when scaling mode was used.  The instruction would instead be shown as
a .word.

Workaround: 
This bug does not impact the correctness of the code.  Be aware that a
.word in a text section might be LDNDW or STNDW.

------------------------------------------------------------------------------
FIXED  SDSCM00044450
------------------------------------------------------------------------------

Summary            : Parser allows virtual base classes that are too large

Fixed in           : 7.4.1
Severity           : S3 - Minor
Affected Component : Parser

Description: 
In EABI, due to the RTTI implementation, the compiler can only handle 
virtual base classes of a certain size.  The parser incorrectly
computed 
this size and did not emit a warning for very large virtual base
classes 
that were too large. This would lead to data corruption.

Workaround: 
Do not allow any object to inherit from virtual base classes with 
total size larger than approximately 0x7ffff0

------------------------------------------------------------------------------
FIXED  SDSCM00044463
------------------------------------------------------------------------------

Summary            : gcc packed attribute causes both codegen and optimizer
		     error

Fixed in           : 7.4.1
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
If a struct type is given the "packed" attribute via 
"__attribute__((packed))" but anonymous structs and unions within it
are 
not given that attribute, the compiler may crash.  Without optimisation

or with -o0 or -o1, the problem will happen only without "--abi=eabi"; 

with -o2 and above, the problem will happen with or without
"--abi=eabi".

Workaround: 
Add "__attribute__((packed))" to all nested structs and unions.

------------------------------------------------------------------------------
FIXED  SDSCM00044561
------------------------------------------------------------------------------

Summary            : ASG error in cg6x

Fixed in           : 7.4.1
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
Code causes the following codegen crash

INTERNAL ERROR no match for ASG

Workaround: No workaround 


------------------------------------------------------------------------------
FIXED  SDSCM00044735
------------------------------------------------------------------------------

Summary            : EXIDX_CANTUNWIND yields invalid memory read

Fixed in           : 7.4.1
Severity           : S2 - Major
Affected Component : Runtime Support Libraries (RTS)

Description: 
If an exception is thrown that tries to propagate up through any
C-compiled function, the RTS must call stdterminate().	The linker
is responsible for fabricating CANTUNWIND entries in the EXIDX table
for C functions so that the unwinder knows it has unwound to a C
function.  If the C function happens to be placed after the last C++
text section, the linker doesn't create such an EXIDX entry.

This is a bug in the RTS.  The EXIDX lookup does check whether it is
running off the end of the EXIDX table, but when it does, it
mistakenly attempts to read a value from just beyond the end of the
table.	This problem only occurs in EABI.

Workaround: 
This bug can only occur when the program is terminating due to a
problem with an uncaught exception.  To work around the issue, ensure
that C++ functions which might be called from a C function catch all
exceptions.

------------------------------------------------------------------------------
FIXED  SDSCM00044775
------------------------------------------------------------------------------

Summary            : Missed dependence between x[i+4] and x[i] when i unsigned

Fixed in           : 7.4.1
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
A loop with a write to x[i+k1] and a read from x[i+k2], where i is an 
unsigned integral type and k1 and k2 are constants, may produce
incorrect 
answers, because the compiler will not recognise the dependence between

the two accesses.  Whether or not the result is correct is due to 
variations in the scheduling of instructions in the compiler output. 
The 
compiler misses the dependences because it doesn't properly sign-extend

the unsigned difference computation and ends up with a large positive 
number instead of the correct small negative one.

Workaround: 
Change "i" from unsigned to signed, from UINT32 to INT32.

------------------------------------------------------------------------------
FIXED  SDSCM00044799
------------------------------------------------------------------------------

Summary            : pprof6x aborts during compile which uses profile data to
		     analyze the call graph

Fixed in           : 7.4.1
Severity           : S2 - Major
Affected Component : Path Profiler (pprof)

Description: 
pprof6x may abort the compilation when using profile data
(--use_profile_info option) and analyzing callgraph information
(--analyze=callgraph option). The issue will at least come up in cases
where the application contains at least one C++ global object that
requires initialization and is using entry/exit hook functions.

Workaround: 
Can possibly avoid the problem by removing the use of --entry_hook
option. A more drastic workaround would be to avoid using the
--use_profile_info option.


------------------------------------------------------------------------------
3. 7.4.0 Fixed Code Generation Tools Defects
------------------------------------------------------------------------------

------------------------------------------------------------------------------
FIXED  SDSCM00041434
------------------------------------------------------------------------------

Summary            : Compiler optimizes away certain calls to assert()

Fixed in           : 7.4.0
Severity           : S3 - Minor
Affected Component : Absolute Lister

Description: 
Certain assert() statements, most notably "assert(x&1)" and the 
equivalent "assert(x%2==0)", may be removed by the compiler and thus
will not do the run-time condition check that is desired.

Defect occurs in

ARP32 Compiler versions 1.0.0B1 - 1.0.0B2
C2000 Compiler versions 4.1.0B1 - 4.1.4, 4.3.0B1 - 4.3.0, 5.2.0B1 -
5.2.12, 6.0.0B1 - 6.0.3, 6.1.0B1 - 6.1.0
C5500 Compiler versions 4.0.0B1 - 4.0.2, 4.1.0B1 - 4.1.2, 4.2.0B1 -
4.2.3, 4.3.0B1 - 4.3.9, 4.4.0B1 - 4.4.1
C6000 Compiler versions 6.1.19 - 6.1.21, 7.0.0B1 - 7.0.5, 7.1.0B1 -
7.1.0B3, 6.1.10.101, 7.2.0B1 - 7.2.9, 7.3.0B1 - 7.3.5, 7.4.0B1 -
7.4.0B2
MSP430 Compiler versions 2.0.0B1 - 2.0.2, 4.0.0B1 - 4.0.2, 4.1.0B1 -
4.1.0
TMS470 Compiler versions 2.41.beta - 2.50.beta, 4.4.0B1 - 4.4.18,
4.5.0B1 - 4.5.2, 4.4.10.100 - 4.4.10.116, 4.6.0B1 - 4.6.6, 4.4.15.201 -
4.4.15.209, 4.7.0B1 - 4.7.1, 4.8.0B1, 4.9.0B1 - 4.9.5, 4.7.1.201 -
4.7.1.202, 5.0.0B1


Workaround: 
Instead of "assert(p)", use "if (!p) assert(0)", which will still abort
at the same place under the same conditions, but will have a different 
error message.	More elaborately, implement a function equivalent to 
assert() but with a different name, that the compiler will not
recognize as a system function.

------------------------------------------------------------------------------
FIXED  SDSCM00042292
------------------------------------------------------------------------------

Summary            : In EABI mode string literals used in member functions
		     result in static members of the class
		     and not placed in .const.string

Fixed in           : 7.4.0
Severity           : S2 - Major
Affected Component : Parser

Description: 
In the test case provided in this defect report, the class member 
A::operation uses string literals. Instead of creating the string literals,
the parser is generating static char array member and initializes it to the
string chars.

Workaround: 
None

------------------------------------------------------------------------------
FIXED  SDSCM00043770
------------------------------------------------------------------------------

Summary            : Intentional alias between two congruent IF tests may
		     simplify incorrectly

Fixed in           : 7.4.0
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
Code like

  p = &x;
  if (x) ...
  *p = ...
  if (x) ...

may compile incorrectly, as the compiler will miss the effect that the 
write to *p has on the value of x in the second IF.

Defect occurs in

C6000 Compiler versions 5.0.0B1 - 5.0.1, 5.1.0B1 - 5.1.13, 5.3.0B1 -
5.3.0, 6.0.1B1 - 6.0.31, 6.1.0B1 - 6.1.21, 7.0.0B1 - 7.0.5, 7.1.0B1 -
7.1.0B3, 6.1.10.101, 7.2.0B1 - 7.2.9, 7.3.0B1 - 7.3.5, 7.4.0B1 -
7.4.0B2


Workaround: 
Compile at -o0, or avoid creating aliases and then using both paths to 
access a single variable.

------------------------------------------------------------------------------
FIXED  SDSCM00043948
------------------------------------------------------------------------------

Summary            : IF predicate with negative integer factor simplifies
		     incorrectly

Fixed in           : 7.4.0
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
An IF predicate with a negative integer factor -- eg, "if (x*(-3) ==
-9)" -- may be simplified incorrectly, for instance to "if (x == -3)"
instead of the correct "if (x == 3)".

Defect occurs in

ARP32 Compiler versions 1.0.0B1 - 1.0.0B2
C6000 Compiler versions 4.44 - 4.45, 5.0.0B1 - 5.0.1, 5.1.0B1 - 5.1.13,
5.3.0B1 - 5.3.0, 6.0.1B1 - 6.0.31, 6.1.0B1 - 6.1.21, 7.0.0B1 - 7.0.5,
7.1.0B1 - 7.1.0B3, 6.1.10.101, 7.2.0B1 - 7.2.9, 7.3.0B1 - 7.3.5,
7.4.0B1 - 7.4.0B2
MSP430 Compiler versions 2.0.0B1 - 2.0.2, 3.0.0B1 - 3.0.1, 3.1.0B1 -
3.1.0, 3.2.0B1 - 3.2.3, 3.3.0B1 - 3.3.3, 4.0.0B1 - 4.0.2, 4.1.0B1 -
4.1.0
TMS470 Compiler versions 4.4.0B1 - 4.4.18, 4.5.0B1 - 4.5.2, 4.4.10.100
- 4.4.10.116, 4.6.0B1 - 4.6.6, 4.4.15.201 - 4.4.15.209, 4.7.0B1 -
4.7.1, 4.8.0B1, 4.9.0B1 - 4.9.5, 4.7.1.201 - 4.7.1.202, 5.0.0B1


Workaround: 
None.  Avoid the situation.

------------------------------------------------------------------------------
FIXED  SDSCM00043966
------------------------------------------------------------------------------

Summary            : Second instance of three-operand associative op may
		     miscompile

Fixed in           : 7.4.0
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
If two three-operand expressions using the same associative operator
and two of the same operands occur in the same function -- for example,
x*x*x and 30*x*x -- the second expression may miscompile and be treated as 
identical to the first.

Defect occurs in

C6000 Compiler versions 6.1.0B1 - 6.1.21, 7.0.0B1 - 7.0.5, 7.1.0B1 -
7.1.0B3, 6.1.10.101, 7.2.0B1 - 7.2.9, 7.3.0B1 - 7.3.5, 7.4.0B1 -
7.4.0B2
TMS470 Compiler versions 4.4.0B1 - 4.4.18, 4.5.0B1 - 4.5.2, 4.4.10.100
- 4.4.10.116, 4.6.0B1 - 4.6.6, 4.4.15.201 - 4.4.15.209, 4.7.0B1 -
4.7.1, 4.8.0B1, 4.9.0B1 - 4.9.5, 4.7.1.201 - 4.7.1.202, 5.0.0B1

Workaround: 
Compile at -o1 or -o0, or avoid the situation.

------------------------------------------------------------------------------
FIXED  SDSCM00044012
------------------------------------------------------------------------------

Summary            : Optimizer crash in _AO_findMinMax

Fixed in           : 7.4.0
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
Certain intrinsic operations are commutative -- their operands can
occur in either order.  Many of these are parallel versions of common 
commutative operations, like _add2, or specialised versions, like _smpy.	
Minimum and maximum operations also have commutative intrinsics, _min2 
and _maxu4 for example.

When one of these commutative intrinsics appears in a reduction -- an
expression like

  x = _op(x, k);

-- inside nested loops, the optimiser may crash.  It is looking for
similar kinds of expressions, but isn't handling intrinsics correctly.
The compiler will either produce correct code here, or crash;  it will
not silently produce incorrect code.

Some of these intrinsics can be introduced by the compiler itself,
based on the original source code.  The motivating case for this bug report
looks like

  for (i = a;  i < b;  i++)
    for (j = c;  j < d;  j++)
    {
      t = ...;
      if (t < min) min = t;
    }

and the compiler transformed the IF into _min2.

For the problem to occur, the required ingredients are a commutative
intrinsic or expressions that can be transformed into one, inside a
nest of two loops that are simple enough that the outer loop may be
unrolled.

The workaround is to add "#pragma UNROLL(1)" to the outer loop, or to
compile at -o1 or -o0, to prevent the transformation where the crash
occurs.

Defect occurs in

C6000 Compiler versions 6.1.0B2 - 6.1.21, 7.0.0B1 - 7.0.5, 7.1.0B1 -
7.1.0B3, 6.1.10.101, 7.2.0B1 - 7.2.9, 7.3.0B1 - 7.3.5, 7.4.0B1 -
7.4.0B2
TMS470 Compiler versions 4.9.0B1 - 4.9.5, 4.10.0B1, 5.0.0B1

Workaround: 
Try "#pragma UNROLL(1)" ahead of the outermost for-loop, or compile
with 
-o1 or -o0.

------------------------------------------------------------------------------
FIXED  SDSCM00044066
------------------------------------------------------------------------------

Summary            : opt470 experienced a segmentation fault

Fixed in           : 7.4.0
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
Corrected false assumption made while performing an optimization.

Workaround: 
No workaround.

------------------------------------------------------------------------------
FIXED  SDSCM00044227
------------------------------------------------------------------------------

Summary            : Compiler may not ensure uniqueness of static variables in
		     C++ templates

Fixed in           : 7.4.0
Severity           : S2 - Major
Affected Component : Parser

Description: 
In EABI mode, static variables in template functions and static data
members of template classes may not be properly allocated and/or
initialized.  Templates are typically defined in header files,
resulting in separate instances in each translation unit (source file).
The tools must merge these multiple instances into unique instances,
and ensure that static objects are allocated and initialized only once.
There are three specific cases in which these mechanisms may fail,
resulting in incorrect behavior of the program. They are

1. A static variable in a template function, or a static variable in a
member function of a template class, may not be allocated as a single
unique object.	This error occurs only when all of the following
conditions occur:

   - the function is not declared inline, AND
   - the function is not implicity inline by virtue of having its body
     defined within the template class, AND
   - the function body is compiled in multiple translation units (i.e.
     the definition is in a header file).  

For example

   template <class T>
   void f()
   { 
      static int var; 
      // ...
   }

If this function definition is compiled into multiple translation
units, the compiler may incorrectly create multiple instances of 'var'.

Additionally, the compiler may incorrectly allocate 'var' into a
section with other variables. This may cause unexpected behavior during
linking, such as incorporating of unreferenced sections into the link,
or changing the contents of the data section from link to link
(depending on which copy of 'f()' arbitrarily gets linked in).

A workaround for this defect is to declare the function f() as inline.

2. Under the same conditions described in case 1, if the static
variable is initialized with a constructor, the constructor may
incorrectly be called multiple times.

For example 

   template <class T> 
   void f() 
   {
      static T var;
      // ...
   }

The constructor TT() may be called multiple times to initialize 'var'. 
Declaring f() as inline also works around this problem. 

3. Similarly, if a static data member of a template class is
initialized with a constructor, the constructor may incorrectly be
called multiple times.	This occurs only when all of the following
conditions occur:

   - the definition (not the declaration) of the data member appears in
     multiple translation units, AND
   - the member is referenced in multiple translation units in which
     the definition occurs.

For example

   template <class T>
   class MyClass
   {
      static T var;	// declaration
   };

   // definition
   template <class T> 
   T MyClass<T>var;   // may call TT() multiple times

A workaround for case 3 is to move the definition from a header file to
a .cpp file, so that it only occurs once.


Workaround: 
1. If a template function, or member function of a template class, has
a static varaible, declare the function 'inline'.
2. If a template class has a static data member with initialization by
constructor, put the definition of the data member in a .cpp file
rather than a .h file.

------------------------------------------------------------------------------
FIXED  SDSCM00044229
------------------------------------------------------------------------------

Summary            : including errno.h causes link-time failure when linked with
		     thread safe RTS

Fixed in           : 7.4.0
Severity           : S2 - Major
Affected Component : Runtime Support Libraries (RTS)

Description: 
An application that references 'errno' and links with a thread-safe version
of the C runtime support (RTS) library (rts6600_elf_mt.lib, for example), 
may experience a TLS symbol mismatch error during the link step of the 
application build.

Defect occurs in

C6000 Compiler versions 7.4.0B1 - 7.4.0B2

Workaround: 
The problem can be avoided if:

  - the file that references 'errno' declares 'errno' by including the
    RTS library's errno.h file, AND
  - compile's the source file with -D__TI_USE_TLS option

------------------------------------------------------------------------------
FIXED  SDSCM00044302
------------------------------------------------------------------------------

Summary            : opt6x emits an invalid symbol uid in the I-file as part of
		     a load speculation advice record

Fixed in           : 7.4.0
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
Load-speculation advice, generated internally by the optimiser, may
refer to symbols using an invalid index, which may cause a crash during 
compilation.

Defect occurs in

C6000 Compiler versions 7.3.0B1 - 7.3.5, 7.4.0B1 - 7.4.0B2


Workaround: 
None.

------------------------------------------------------------------------------
FIXED  SDSCM00044445
------------------------------------------------------------------------------

Summary            : cg6x accesses wrong address which results in a hardware
                     exception
                     
Fixed in           : 7.4.0
Severity           : S3 - Major
Affected Component : Code Generator

Description: 
This defect can occur in loops that qualify for software pipelining and
loop prolog collapsing during which the prolog of the loop is collapsed
(by instruction speculation and predication) into the loop kernel in order
to reduce the overall code size of the loop.

In this situation, during loop prolog collapsing, the compiler illegally
speculated a load instruction without checking all of the load instruction's
data dependencies.

Defect occurs in:
C6000 Compiler versions: 7.3.5 - 7.3.6, 7.4.0B1

Workaround:
Disable loop prolog collapsing (--disable:pc) with small risk for 
increase in loop's code size.

------------------------------------------------------------------------------
FIXED  SDSCM00044463
------------------------------------------------------------------------------

Summary            : In some cases, use of packed attribute causes cg6x and
                     opt6x internal errors

Fixed in           : 7.4.0
Severity           : S3 - Major
Affected Component : Code Generator, Optimizer

Description: 
If a struct type is given the "packed" attribute via 
"__attribute__((packed))" but anonymous structs and unions within it are 
not given that attribute, the compiler may crash. Without optimisation 
or with -o0 or -o1, the problem will happen only without "--abi=eabi"; 
with -o2 and above, the problem will happen with or without "--abi=eabi".

Defect occurs in:
C6000 Compiler versions: 7.2.0B1 - 7.2.9, 7.3.0B1 - 7.3.6, 7.4.0B1 - 7.4.0

Workaround: 
Add "__attribute__((packed))" to all nested structs and unions.

------------------------------------------------------------------------------
FIXED  SDSCM00044561
------------------------------------------------------------------------------
Summary            : cg6x generates "no match for ASG" internal error

Fixed in           : 7.4.0
Severity           : S2 - Major
Affected Component : Code Generator

Description: 
Compiler fails to handle an assignment that dereferences the result of an
intrinsic whose argument is an unaligned packed type object.

Workaround:
None.

------------------------------------------------------------------------------
FIXED  SDSCM00044618
------------------------------------------------------------------------------

Summary            : lnk6x runs out of memory when using --preferred_order in
		     large application

Fixed in           : 7.4.0
Severity           : S2 - Major
Affected Component : ELF Linker

Description: 
The linker can experience significant system memory usage and some
leakage while using the --preferred_order option during the link step
of a large application build. The leakage can be significant if the
application is compiled with debug (-g option). In some cases where
available system memory is limited (2GB PC system, for example), the
excessive system memory usage can cause the linker to run out of
memory.

Workaround: 
Avoid use of --preferred_order option during the link step.


------------------------------------------------------------------------------
4. 7.4.0B2 Fixed Code Generation Tools Defects
------------------------------------------------------------------------------

------------------------------------------------------------------------------
FIXED  SDSCM00037422
------------------------------------------------------------------------------

Summary            : Incorrect layout in .cdecls struct

Fixed in           : 7.4.0B2
Severity           : S3 - Minor
Affected Component : Assembler

Description: 
The attached test case defines a structure which contains a union.  The
last field in the structure is assigned the offset 9 by the compiler. 
The assembler, via .cdecls, assigns that same field the offset 10.

Workaround: 
None

------------------------------------------------------------------------------
FIXED  SDSCM00042194
------------------------------------------------------------------------------

Summary            : Partial link drops weak function symbol

Fixed in           : 7.4.0B2
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description:
Given an application that includes a reference to a weak symbol that is 
eventually defined, the given reference is not resolved properly. The
test case provided includes partial linking. During the first partial link,
the linker fails to copy the weak symbol into the output file, which corrupts
the symbol ID number in a the relocation associated with a reference to that
symbol.

Workaround: 
None

------------------------------------------------------------------------------
FIXED  SDSCM00042362
------------------------------------------------------------------------------

Summary            : Disassembly shows valid instruction, but should reject
		     illegal opcode

Fixed in           : 7.4.0B2
Severity           : S2 - Major
Affected Component : Disassembler (dis)

Description: 
Both the standalone disassembler and the disassembler view in CCS will 
mistakenly decode some instructions that actually contain encodings of 
illegal register pairs.  This can mislead the user into thinking that 
corrupted or invalid encodings are legal instructions.
Defect occurs in

C6000 Compiler versions 4.37 - 4.45, 5.0.0B1 - 5.0.1, 5.1.0B1 - 5.1.13,
5.3.0B1 - 5.3.0, 6.0.1B1 - 6.0.30, 6.1.0B1 - 6.1.20, 7.0.0B1 - 7.0.5,
7.1.0B1 - 7.1.0B3, 6.1.10.100 - 6.1.10.101, 7.2.0B1 - 7.2.8, 7.3.0B1 -
7.3.3, 7.4.0B1


Workaround: 
No practical workaround

------------------------------------------------------------------------------
FIXED  SDSCM00042376
------------------------------------------------------------------------------

Summary            : C6000 compiler fails to preserve all the context for an
		     interrupt function which contains an
		     SPLOOP

Fixed in           : 7.4.0B2
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
This bug only happens for interrupt functions when the interrupt is in 
the middle of a SPLOOP and the interrupt function itself also has a
SPLOOP.

Defect occurs in

C6000 Compiler versions 6.0.1B1 - 6.0.30, 6.1.0B1 - 6.1.20, 7.2.0B1 -
7.2.8, 7.3.0 - 7.3.3, 7.4.0B1


Workaround: 
By adding lines similar to these, you can manually preserve ITSR.

#include <c6x.h>

/* interrupt routine starts here */

unsigned int save_itsr = ITSR;

/* loop code here */

ITSR = save_itsr;

------------------------------------------------------------------------------
FIXED  SDSCM00042789
------------------------------------------------------------------------------

Summary            : Register allocation fails at ii=4, but succeeded in 7.3.0
		     compiler

Fixed in           : 7.4.0B2
Severity           : S1 - Critical / PS
Affected Component : Code Generator

Description: 
In some rare cases register allocation might fail on a software
pipelined loop, when it succeeded in a previous compiler release.  This
would typically occur on loops where most or all of the registers are
allocated.

Workaround: 
No known workarond

------------------------------------------------------------------------------
FIXED  SDSCM00042914
------------------------------------------------------------------------------

Summary            : Linker segfault using partial link output file of C++
		     source with ELF and exceptions enabled

Fixed in           : 7.4.0B2
Severity           : S2 - Major
Affected Component : ELF Linker

Description: 
The linker fails with a segmentation fault when using a file created by
partial linking C++ code with exceptions enabled and using the ELF file
format.  While the first (partial) link appears to succeed, a second
link using the (corrupted) output file from the partial link causes the
linker to segfault and stop.

Workaround: 
Re-link partial linked output file with a fixed linker, then perform
final link again with the now correct partial link output file.

------------------------------------------------------------------------------
FIXED  SDSCM00043152
------------------------------------------------------------------------------

Summary            : Optimizer issues information advice using optimizer's
		     temporary symbols instead of using
		     symbols from user code

Fixed in           : 7.4.0B2
Severity           : S3 - Minor
Affected Component : Optimizer

Description: 
The optimiser may issue alias advice that refers to the optimiser's 
temporary symbols, whose declarations the user cannot control.	This 
advice does not affect the code's behavior, though it leaves some 
suggested improvements inaccessible.

Defect occurs in

C6000 Compiler versions 5.3.0B1 - 5.3.0, 6.0.1B1 - 6.0.30, 6.1.0B1 -
6.1.20, 7.0.0B1 - 7.0.5, 7.1.0B1 - 7.1.0B3, 6.1.10.101, 7.2.0B1 -
7.2.8, 7.3.0B1 - 7.3.3, 7.4.0B1
TMS470 Compiler versions 4.4.0B1 - 4.4.18, 4.5.0B1 - 4.5.2, 4.4.10.100
- 4.4.10.114, 4.6.0B1 - 4.6.6, 4.4.15.201 - 4.4.15.209, 4.7.0B1 -
4.7.1, 4.8.0B1, 4.9.0B1 - 4.9.3, 4.7.1.201 - 4.7.1.202


Workaround: 
None.  Ignore the bad advice, or try to ascertain which user variable
the temp refers to by studying the optimiser comments in the .asm file.

------------------------------------------------------------------------------
FIXED  SDSCM00043207
------------------------------------------------------------------------------

Summary            : Compiler reads from stack frame after releasing it

Fixed in           : 7.4.0B2
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
The compiler may incorrectly move an access of a stack location past
the function return point where the stack location has been
deallocated.

Workaround: 
No direct workaround known if the issue appears, though it's likely
that different optimization flags will hide the issue.

------------------------------------------------------------------------------
FIXED  SDSCM00043223
------------------------------------------------------------------------------

Summary            : Compiler may miss alias given struct-of-array-of-structs

Fixed in           : 7.4.0B2
Severity           : S1 - Critical / PS
Affected Component : C/C++ Compiler (cl)

Description: 
In a particular situation involving a struct containing an array of 
structs, the compiler may miss an alias between a read and write of a 
scalar field in the nested struct.

Defect occurs in

ARP32 Compiler versions 1.0.0B1 - 1.0.0B2
C2000 Compiler versions 6.0.0B1 - 6.0.2, 6.1.0B1
C5500 Compiler versions 4.4.0B1 - 4.4.1
C6000 Compiler versions 7.2.0B1 - 7.2.8, 7.3.0B1 - 7.3.3, 7.4.0B1
MSP430 Compiler versions 4.0.0B1 - 4.0.2, 4.1.0B1
TMS470 Compiler versions 4.8.0B1, 4.9.0B1 - 4.9.3, 5.0.0B1


Workaround: 
In this case, save pointer-written-to-struct in a temp and dereference 
from the temp instead of re-reading from struct.  In general, compile
at 
-o1 or -o0.

------------------------------------------------------------------------------
FIXED  SDSCM00043233
------------------------------------------------------------------------------

Summary            : Use of -mb option to force 6200 array alignment can result
		     in link failure with rts6200.lib

Fixed in           : 7.4.0B2
Severity           : S2 - Major
Affected Component : Shell

Description: 
The -mb option is now deprecated, but to enable proper linking against 
rts6200 library, we have to force the option to also disable generation
of push/pop and custom call convention (call_stub) symbols.

Defect occurs in

C6000 Compiler versions 7.2.0 - 7.2.8, 7.3.0B1 - 7.3.3, 7.4.0B2 -
7.4.0B1


Workaround: 
Manually include --disable_push_pop and --disable_custom_call_conv when

using -mb.  These options will prevent the generation of C64+ specific 
symbols that would prevent you from linking against a 6200 RTS library.

------------------------------------------------------------------------------
FIXED  SDSCM00043316
------------------------------------------------------------------------------

Summary            : Arithmetic fails in GROUP directive

Fixed in           : 7.4.0B2
Severity           : S2 - Major
Affected Component : Linker

Description: 
Arithmetic expressions are now permitted as address specifiers in the 
SECTIONS section of a linker command file, as in the MEMORY section.

Defect occurs in

C6000 Compiler versions 6.1.0B1 - 6.1.20, 7.0.0B1 - 7.0.5, 7.1.0B1 -
7.1.0B3, 6.1.10.101, 7.2.6 - 7.2.8, 7.3.0B1 - 7.3.4, 7.4.0B1


Workaround: 
The constant address may be specified directly rather than through an 
expression.

------------------------------------------------------------------------------
FIXED  SDSCM00043326
------------------------------------------------------------------------------

Summary            : Extremely long (templated) type names may overflow buffer,
		     causing crash

Fixed in           : 7.4.0B2
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
The optimiser may crash when it encounters an extremely long type name
-- 
for example, a deep nested templated C++ class name -- while creating a
printed representation.  The crash is most likely, and perhaps only 
occurs, with -o2 or -o3.

Defect occurs in

ARP32 Compiler versions 1.0.0B1 - 1.0.0B2
C2000 Compiler versions 3.08 - 3.13, 4.1.0B1 - 4.1.4, 4.3.0B1 - 4.3.0,
5.0.0B1 - 5.0.2, 5.1.0B1 - 5.1.6, 5.2.0B1 - 5.2.11, 6.0.0B1 - 6.0.2,
6.1.0B1
C5500 Compiler versions 2.09, 2.70 - 2.84, 3.2.0B3 - 3.2.3, 3.3.0 -
3.3.6, 4.0.0B1 - 4.0.2, 4.1.0B1 - 4.1.2, 4.2.0B1 - 4.2.3, 4.3.0B1 -
4.3.9, 4.4.0B1 - 4.4.1
C6000 Compiler versions 4.10 - 4.22, 4.37 - 4.45, 5.0.0B1 - 5.0.1,
5.1.0B1 - 5.1.13, 5.3.0B1 - 5.3.0, 6.0.1B1 - 6.0.30, 6.1.0B1 - 6.1.20,
7.0.0B1 - 7.0.5, 7.1.0B1 - 7.1.0B3, 6.1.10.100 - 6.1.10.101, 7.2.0B1 -
7.2.8, 7.3.0B1 - 7.3.3, 7.4.0B1
MSP430 Compiler versions 2.0.0B1 - 2.0.2, 3.0.0B1 - 3.0.1, 3.1.0B1 -
3.1.0, 3.2.0B1 - 3.2.3, 3.3.0B1 - 3.3.3, 4.0.0B1 - 4.0.2, 4.1.0B1
TMS470 Compiler versions 2.166e - 2.178e, 2.209e, 2.40.beta - 2.71,
4.1.0B1 - 4.1.7, 2.54.02 - 2.54.209, 2.54.03 - 2.54.129, 2.202.03e -
2.202.15e, 4.4.0B1 - 4.4.18, 4.5.0B1 - 4.5.2, 4.4.10.100 - 4.4.10.114,
4.6.0B1 - 4.6.6, 4.4.15.200 - 4.4.15.209, 4.7.0B1 - 4.7.1, 4.8.0B1,
4.9.0B1 - 4.9.3, 4.7.1.201 - 4.7.1.202, 5.0.0B1


Workaround: 
None.

------------------------------------------------------------------------------
FIXED  SDSCM00043376
------------------------------------------------------------------------------

Summary            : data array copy got wrong results after calling initTimer()

Fixed in           : 7.4.0B2
Severity           : S2 - Major
Affected Component : Code Generator

Description: 
This bug only happens when SPLOOP is interrupted and there are registers 
in the SPLOOP that have two live ranges, or there are multiple assigned
registers in the SPLOOP. 

When interrupt is returned back to the SPLOOP, the register content can
not be correctly restored thus leads to error.

Defect occurs in

C6000 Compiler versions 7.2.6 - 7.2.8, 7.3.0B1 - 7.3.4, 7.4.0B1


Workaround: 
There is no work around for this bug.

------------------------------------------------------------------------------
FIXED  SDSCM00043377
------------------------------------------------------------------------------

Summary            : In the generated assembly file comments always say no -ms
		     option even when -ms option is used
		     for the build

Fixed in           : 7.4.0B2
Severity           : S3 - Minor
Affected Component : C/C++ Compiler (cl)

Description: 
In the compiler generated assembly file, the comments always say no -ms
option was used even when -ms option is used for the build.


Workaround: 
None

------------------------------------------------------------------------------
FIXED  SDSCM00043642
------------------------------------------------------------------------------

Summary            : Compiler incorrectly simplifies "(x >> k1) < k2" when k2 is
		     constant smaller than int

Fixed in           : 7.4.0B2
Severity           : S1 - Critical / PS
Affected Component : C/C++ Compiler (cl)

Description: 
Given an IF with a predicate like "(x >> k1) < k2", the compiler will 
attempt to convert it to "x < (k2<<k1)".  If k2 is a literal or const 
variable whose type is too small to hold k2<<k1, the result will be 
incorrect.  The compiler should use a wider type, the promoted type of 
x;  the workaround is to do the same thing in the source.

Defect occurs in

C6000 Compiler versions 6.1.0B1 - 6.1.20, 7.0.0B1 - 7.0.5, 7.1.0B1 -
7.1.0B3, 6.1.10.101, 7.2.0B1 - 7.2.8, 7.3.0B1 - 7.3.4, 7.4.0B1
TMS470 Compiler versions 4.4.0B1 - 4.4.18, 4.5.0B1 - 4.5.2, 4.4.10.100
- 4.4.10.114, 4.6.0B1 - 4.6.6, 4.4.15.201 - 4.4.15.209, 4.7.0B1 -
4.7.1, 4.8.0B1, 4.9.0B1 - 4.9.4, 4.7.1.201 - 4.7.1.202, 5.0.0B2 -
5.0.0B1


Workaround: 
Declare k2 as an int instead of a shorter type.

------------------------------------------------------------------------------
FIXED  SDSCM00043740
------------------------------------------------------------------------------

Summary            : error in PACKED structure access

Fixed in           : 7.4.0B2
Severity           : S2 - Major
Affected Component : Code Generator

Description: 
This bug happens when accessing PACKED data structure. The compiler 
generates aligned memory access instead of unaligned memory access.
Defect occurs in

C6000 Compiler versions 4.44 - 4.45, 5.0.0B1 - 5.0.1, 5.1.0B1 - 5.1.13,
5.3.0B1 - 5.3.0, 6.0.1B1 - 6.0.30, 6.1.0B1 - 6.1.20, 7.0.0B1 - 7.0.5,
7.1.0B1 - 7.1.0B3, 6.1.10.101, 7.2.0B1 - 7.2.8, 7.3.2 - 7.3.4, 7.4.0B1


Workaround: 
There is no workaround for this bug.

------------------------------------------------------------------------------
FIXED  SDSCM00043807
------------------------------------------------------------------------------

Summary            : Register initialization lost during instruction predication

Fixed in           : 7.4.0B2
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
When converting control flow to predicated instructions, in rare cases
the compiler could mistakenly discard some instructions which were
unpredicatable or were already predicated.  This will cause the
generated code to work incorrectly in unpredictable ways.

Defect occurs in

C2000 Compiler versions 6.1.0B1 - 6.1.0
C5500 Compiler versions 4.4.0B1 - 4.4.1
C6000 Compiler versions 7.3.0B1 - 7.3.5, 7.4.0B1
TMS470 Compiler versions 5.0.0B1


Workaround: 
No practical workaround

------------------------------------------------------------------------------
FIXED  SDSCM00043868
------------------------------------------------------------------------------

Summary            : Linker cannot find include file specified with relative
		     path

Fixed in           : 7.4.0B2
Severity           : S2 - Major
Affected Component : Linker

Description: 
In some cases, the linker may incorrectly resolve pathnames for #include
files, causing it to fail to find the included file. This occurs only when 
*ALL* of the following are true:
- Two files are #included consecutively
- The first file is in a different directory from the current directory
- The second file is specified using a relative path name

Workaround: 
This bug occurs because the linker does not properly reset the source
path after processing an #include, causing a second #include to be
relative to the wrong path. Any intervening token between the two
#include directive will overcome this, as will any macro expansion
(even if empty). For example

#define SPACE
#include "../first.cmd"
SPACE
#include "../second.cmd"


------------------------------------------------------------------------------
5. Current Known Issues
------------------------------------------------------------------------------

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00040934
------------------------------------------------------------------------------

Summary            : Structure is not initialized correctly when using -o2 or
		     -o3 optimization
Affected Component : Optimizer

Description: 
Codegen bug, see internal notes.

--------------------------------------------
There is a problem with the initialization of a structure using symbols
generated in the linker command file. The attached test case shows the
problem.

We use symbols generated in the linker cmd file using the dot operator.
These symbols are used as an initial value for a class/struct with a
constructor. In our case we want the difference of two adresses the
linker generates.

When using optimization -o2 or -o3, the compiler generates .cinit
entries instead of the constructor call.
In those .init-entries it doesn't use the difference of the adresses,
instead it uses the first symbol

----- snip (from testcase.cpp) -----
// symbols from the linker
extern char _start_isr_stack[];
extern char _end_isr_stack[];
...
struct Info
{
   unsigned mSize;
   Info(unsigned size)	mSize(size) {}
};
...
Info Info2((unsigned)_end_isr_stack - (unsigned)_start_isr_stack);
----- snip -----


That's what is generated

----- snip (from generated .asm file) -----
   .sect   ".cinit"
   .align   8
   .field     $C$IR_2,32
   .field     _Info2+0,32
   .field     __end_isr_stack,32      ; _Info2._mSize @ 0
----- snip -----

The last line should be something like
    .field   __end_isr_stack-__start_isr_stack,32


When turning off optimization or using lower level of opt than -o2, the
constructor calls are generated and the struct is initialized
correctly.


------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00042332
------------------------------------------------------------------------------

Summary            : Don't generate typeinfo when not used
Affected Component : Code Generator

Description: 
The C++ type info is generated under EABI whenever the virtual function
table is created as per the IA64 C++ ABI requirement. However, the
typeinfo is not used if RTTI or C++ exceptions are not used. Hence it
is a good candidate to place in slow external memory. However, they are
presently generated under .const section and hence it is difficult to
selectively group and place them. The proposal is to place the typeinfo
under the .const.typeinfo subsection to enable easier placement. 

Observations:
Typeinfo is generated even when --rtti or --exceptions option is not
specified. For embedded systems we should not generate typeinfo if it is
not used. The plan to fix this issue is to update the parser not to 
generate typeinfo if --rtti/--exceptions is not specified. This deviates
from IA64 C++ ABI but that is okay.

We can document the deviation in the C6x EABI. This will be a generic
fix so ARM and other EABI targets also don't generate the typeinfo. 
We also have to determine how the linker handles non-typeinfo object 
being linked with object that has typeinfo.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00042344
------------------------------------------------------------------------------

Summary            : Compiler generates internal error illegal initialization or
		     segmentation fault
Affected Component : C/C++ Compiler (cl)

Description: 
The test case provided in the defect report generates a segmentation fault 
when compiled with CGT 6.1.x and 7.0.x.  It generates the following error 
when compiled with 7.2.5 and 7.3.1 but does generate a .obj file.

Build with cl6x --gcc seg_fault.c

>> INTERNAL ERROR ILLEGAL INITIALIZATION

This may be a serious problem.	Please contact customer support with a
description of this problem and a sample of the source files that
caused this
INTERNAL ERROR message to appear.

Note May lose variable initialization information

Workaround:
The seg fault can be avoidded if the nested designated initializer is
removed:

static struct cfg config[] = 
{
   // the 1st definition causes the seg fault; comment it out and everything
   // is fine.
   { .module_id = MODULE_1,
     .param_length = sizeof(struct module_1_params),
     .param = (struct module_1_params[]){{1}} /* remove this designated */
                                              /* initializer            */
   },

   { .module_id = MODULE_2,
     .param_length = 5,
     .param = (int[]){0,1,2,3,4}
   },

   { .module_id = MODULE_3,
     .param_length = 2,
     .param = (int[]){0,1}
   }
};

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00042409
------------------------------------------------------------------------------

Summary            : The c6xabi Tag_ABI_array_object_alignment and
		     Tag_ABI_array_object_align_expected
		     build attributes are not correctly
		     enforced
Affected Component : Linker

Description: 
The build attributes enforce the required and preserved state of array
alignment. If the required is greater than the preserved it is an
error. The current check incorrectly assumes the build attribute values
of 0,1,2 increase in order of alignment. This is not the case since 0
means 8 byte alignment and 1 means 4 byte alignment.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00042559
------------------------------------------------------------------------------

Summary            : modf(-Inf, 1.0) with -mv6740 enters infinite loop
Affected Component : C/C++ Compiler (cl)

Description: 
Attempting to call modf(-Inf, 1.0) will result in an infinite loop. 
C6000 doesn't guarantee to handle Inf values correctly, but this should
at least not be an infinite loop.

Also calling modf(x, NaN) where x is negative will also result in an
infinite loop.	Not sure if this is the same bug.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00043605
------------------------------------------------------------------------------

Summary            : Linker segfaults linking partially linked file when partial
		     link includes RTS library, ELF, and
		     exceptions
Affected Component : ELF Linker

Description: 
When doing a partial link using ELF file format and exceptions enabled,
if the partial link includes a TI RTS library, then the final link
using that partial linked output file will segfault.  This may also
occur with other large customer libraries with exceptions enabled.

Later versions of the tools will fault with an internal error during
the partial link with this sort of message
  INTERNAL ERROR Could not find the collection item for linked-to
section .textxxxxxxx

Workaround:
Do not partial link against a TI RTS library. For customer libraries, split 
the libraries into two parts such that the partial link only uses the 
library with object files that it requires.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00044316
------------------------------------------------------------------------------

Summary            : INTERNAL ERROR Corrupted IR detected during
		     check_mve/spilling
Affected Component : Code Generator

Description: 
% cl6x cutdown.sa -mv6600 -mw -o
Renamed pair with base %s above window		       DCMPGTU4       
.S1	VRA302VRA285,VRA268VRA267,VRA290      ; |40| 
>> cutdown.sa, line 37 INTERNAL ERROR Corrupted IR detected during
			check_mve/spilling

[This appears to be a bug in software pipelining spilling]

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00044366
------------------------------------------------------------------------------

Summary            : SPMASK circumflexes appearing on incorrect instructions
		     when using disassembler .so library
Affected Component : Disassembler (dis)

Description: 
When using the disassembler's library API for the following sequence of
instructions, the circumflexes for SPMASK'd instructions are appearing
in the wrong place.

108037a0		   SPMASK	 L2
108037a2	 ||^	   MV.L2X	 A28,B4
108037a4	 ||	   ADD.L1	 A7,A4,A4
108037a8		   LDNDW.D2T2	 *B4++[1],B17B16
108037ac		   NOP		 4
108037ae		   SPMASK	 S2
108037b0	 ||^	   CMPEQ.L2	 B16,B8,B2
108037b4	 ||	   MV.S2X	 A23,B6
108037b6		   SPMASK	 L2
108037b8	 || [ B2]  LDW.D1T2	 *+A4[0],B19
108037c0	 ||^	   MV.L2X	 A5,B7
108037c4	   ^[!B2]  MVK.S2	 0x0000,B0
108037c8	 || [ B2]  CMPLTU.L2	 B6,B7,B0
108037cc	    [ B0]  MV.L1X	 B6,A5
108037d0	 || [ B0]  MVK.L2	 4,B21

Note the incorrect location of some of the "^" characters above.

This is what dis6x shows for the same code sequence (which is correct)

108037a0       2ce6	      SPMASK	    L2
108037a2       9e07 ||^       MV.L2X	    A28,B4
108037a4   0210e078 ||	      ADD.L1	    A7,A4,A4
108037a8   089037a6	      .word	    0x089037a6
108037ac       6c6e	      NOP	    4
108037ae       2e66	      SPMASK	    S2
108037b0   01220a7b ||	      CMPEQ.L2	    B16,B8,B2
108037b4       db8f ||^       MV.S2X	    A23,B6
108037b6       2ce6	      SPMASK	    L2
108037b8   69900267 || [ B2]  LDW.D1T2	    *+A4[0],B19
108037bc   e5200883	      .fphead	    n, l, W, BU, nobr, nosat,
0101001b
108037c0   03941fda ||^       MV.L2X	    A5,B7
108037c4   7000002b    [!B2]  MVK.S2	    0x0000,B0
108037c8   601ccbfa || [ B2]  CMPLTU.L2     B6,B7,B0
108037cc   22981fd9    [ B0]  MV.L1X	    B6,A5
108037d0   2a90a35a || [ B0]  MVK.L2	    4,B21


------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00044393
------------------------------------------------------------------------------

Summary            : C6000 linker silently ignores an output section placement
		     spec with missing ">" in the SECTIONS
		     directive
Affected Component : Linker

Description: 
If SECTIONS directive in the linker command file contains a line such
as:
	important_section > AREA2

this will result in important_section to be placed in AREA2. 
But if the ">" is missing, such as in:

	important_section  AREA2

the linker silently ignores this and places important_section in the
first available memory space as specified by the MEMORY directive. This
can lead to bugs that are difficult to find. According to SPRU186 the
linker behavior should be the same with or without the ">".


------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00044527
------------------------------------------------------------------------------

Summary            : Code generator removes weak object pointer check
Affected Component : Code Generator

Description: 

The test case carefully checks whether the weak object is actually
defined before calling printf(), but the codegen removes this check,
apparently assuming that the address of any object is non-NULL.  This
is not true for WEAK objects.  The test case will generate a NULL
pointer dereference at run-time.

The problem is in dc_uand, when EV_CONTROL, where it says "an address
is always 'true' if evaluated for control."  This is not true if the
operand of the UAND is a weak symbol.  We may assume that the UAND is
non-NULL unless the operand is a weak NAME or VARADDR.

At one point in time for C6000, this was going to be resolved by the
linker, which would turn all calls to unresolved weak functions into
either a nop (B B3) or a branch to __c6xabi_weak_return, but we
eventually decided that this would not be acceptable in all cases, due
to the way GCC supports weak function calls.  If the user has an
explicit test for NULL pointer, we should not remove it.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00044918
------------------------------------------------------------------------------

Summary            : SPLOOP loop cannot be interrupted safely
Affected Component : Code Generator

Description: 
The compiler generates a SPLOOP loop with a FADDSP in the last cycle. 
When an interrupt occurs, the loop drains and the FADDSP is still
in-flight when interrupts are enabled.	The interrupt is taken and
anuls the FADDSP.  The interrupt is processed and returns back to the
SPLOOP instruction.  The result of the intermediate FADDSP is lost.


------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00044972
------------------------------------------------------------------------------

Summary            : openMP default clause is ignored
Affected Component : C/C++ Compiler (cl)

Description: 
See Details.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00045207
------------------------------------------------------------------------------

Summary            : Option --adviceperformance_file interface does not work
		     well in CCS build environment
Affected Component : C/C++ Compiler (cl)

Description: 
The option --adviceperformance_file names the file where performance
advice is written.  In the CCS build window, this option can be used to
name only one file.  In a project with multiple C files, this option is
the same for all of them.  Thus, this file captures the advice only for
the last file compiled.  The advice for all previous files is
overwritten.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00045211
------------------------------------------------------------------------------

Summary            : Linker GROUP directive fails to allow NOINIT output
		     sections and regular output sections
		     to be together in the group
Affected Component : Linker

Description: 
If one output section in a GROUP is NOINIT, and one or more other
output sections in the GROUP are not NOINIT, the linker rejects it with
an error diagnostic similar to

    error #10367-D output section "INIT_NO_INIT" cannot mix noinit
sections with sections that require initialization

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00045358
------------------------------------------------------------------------------

Summary            : cl6x compiled routine never returns
Affected Component : Code Generator

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00045360
------------------------------------------------------------------------------

Summary            : cg6x hangs up on compile of a function.
Affected Component : Code Generator

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00045388
------------------------------------------------------------------------------

Summary            : missing unaligned _mem4() access after optimization
Affected Component : Optimizer

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00045417
------------------------------------------------------------------------------

Summary            : bool and _Bool are not defined correctly
Affected Component : C/C++ Compiler (cl)

Description: 
The C++ type "bool" and the C99 type "_Bool" should have the same type,
but in the TI toolset they have different sizes, which means that C++
modules which use "bool" are not compatible with C modules which
include stdbool.h and use "bool".

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00045452
------------------------------------------------------------------------------

Summary            : Compiler misreports MISRA warning 17.6
Affected Component : C/C++ Compiler (cl)

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00045473
------------------------------------------------------------------------------

Summary            : Compiler misreports violation of Misra 9.2 for zero
		     initialization of structures
Affected Component : C/C++ Compiler (cl)

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00045504
------------------------------------------------------------------------------

Summary            : offsetof implementation incompatible with c++
Affected Component : Runtime Support Libraries (RTS)

Description: 
In stddef.h c6000 7.4.1

#define offsetof(_type, _ident) ((size_t)__intaddr__(&(((_type
*)0)->_ident)))

doesn't work because size_t needs to be qualified with std

The simplest fix is

#define offsetof(_type, _ident) ((__SIZE_T_TYPE__)__intaddr__(&(((_type
*)0)->_ident)))

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00045562
------------------------------------------------------------------------------

Summary            : Type of multiplication incorrect
Affected Component : Optimizer

Description: 
The problem is that the optimizer changed an expression of the form

    unsigned long x;
    x * 0x10000000uLL

to

    (unsigned long long)(x << 28)

The shift must be done as unsigned long long.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00045580
------------------------------------------------------------------------------

Summary            : Dwarf information is corrupt
Affected Component : ELF Linker

Description: 
CCS has trouble loading symbols because the dwarf information included
with the out file is corrupt. 
