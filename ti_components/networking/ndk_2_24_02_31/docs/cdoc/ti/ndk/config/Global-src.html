<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>module ti.ndk.config.Global</title>
<meta name="googlebot" content="noindex,nofollow">
<link rel="stylesheet" type="text/css" href="../../../src.css"/>
</head>
<body>
<pre class=src>
     1    <span class="comment">/*
</span>     2    <span class="comment"> * Copyright (c) 2012-2015, Texas Instruments Incorporated
</span>     3    <span class="comment"> * All rights reserved.
</span>     4    <span class="comment"> *
</span>     5    <span class="comment"> * Redistribution and use in source and binary forms, with or without
</span>     6    <span class="comment"> * modification, are permitted provided that the following conditions
</span>     7    <span class="comment"> * are met:
</span>     8    <span class="comment"> *
</span>     9    <span class="comment"> * *  Redistributions of source code must retain the above copyright
</span>    10    <span class="comment"> *    notice, this list of conditions and the following disclaimer.
</span>    11    <span class="comment"> *
</span>    12    <span class="comment"> * *  Redistributions in binary form must reproduce the above copyright
</span>    13    <span class="comment"> *    notice, this list of conditions and the following disclaimer in the
</span>    14    <span class="comment"> *    documentation and/or other materials provided with the distribution.
</span>    15    <span class="comment"> *
</span>    16    <span class="comment"> * *  Neither the name of Texas Instruments Incorporated nor the names of
</span>    17    <span class="comment"> *    its contributors may be used to endorse or promote products derived
</span>    18    <span class="comment"> *    from this software without specific prior written permission.
</span>    19    <span class="comment"> *
</span>    20    <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
</span>    21    <span class="comment"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
</span>    22    <span class="comment"> * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
</span>    23    <span class="comment"> * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
</span>    24    <span class="comment"> * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
</span>    25    <span class="comment"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
</span>    26    <span class="comment"> * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
</span>    27    <span class="comment"> * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
</span>    28    <span class="comment"> * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
</span>    29    <span class="comment"> * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
</span>    30    <span class="comment"> * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</span>    31    <span class="comment"> * */</span>
    32    <span class="comment">/*
</span>    33    <span class="comment"> *  ======== Global.xdc ========
</span>    34    <span class="comment"> *  Global module definition file and initial values.
</span>    35    <span class="comment"> */</span>
    36    
    37    <span class="xdoc">/*!
</span>    38    <span class="xdoc"> *  ======== Global ========
</span>    39    <span class="xdoc"> *  High level NDK stack configuration and settings.
</span>    40    <span class="xdoc"> *  
</span>    41    <span class="xdoc"> *  The Global module is required to be used by an NDK application.  At
</span>    42    <span class="xdoc"> *  minimum, it is used to link in the default flavor of the NDK stack library,
</span>    43    <span class="xdoc"> *  as well as the other core libraries, and generates no code.
</span>    44    <span class="xdoc"> *
</span>    45    <span class="xdoc"> *  However, if the user desires, it may be used to link in libraries,
</span>    46    <span class="xdoc"> *  configure global stack settings, and generate NDK C configuration code.
</span>    47    <span class="xdoc"> *  
</span>    48    <span class="xdoc"> *  The following libraries are linked in by default via the Global Module:
</span>    49    <span class="xdoc"> *  <b>@p(blist)</b>
</span>    50    <span class="xdoc"> *      - stack.lib
</span>    51    <span class="xdoc"> *      - cgi.lib
</span>    52    <span class="xdoc"> *      - console.lib
</span>    53    <span class="xdoc"> *      - hdlc.lib
</span>    54    <span class="xdoc"> *      - miniPrintf.lib
</span>    55    <span class="xdoc"> *      - netctrl.lib
</span>    56    <span class="xdoc"> *      - nettool.lib
</span>    57    <span class="xdoc"> *      - os.lib
</span>    58    <span class="xdoc"> *      - servers.lib
</span>    59    <span class="xdoc"> *  <b>@p</b>
</span>    60    <span class="xdoc"> *  
</span>    61    <span class="xdoc"> *  The user can select which version of "stack.lib" to use via the following
</span>    62    <span class="xdoc"> *  configuration parameters:
</span>    63    <span class="xdoc"> *  
</span>    64    <span class="xdoc"> *  <b>@p(code)</b>
</span>    65    <span class="xdoc"> *      config stackLibProtocol stackLibType
</span>    66    <span class="xdoc"> *      config IPv6
</span>    67    <span class="xdoc"> *  <b>@p</b>
</span>    68    <span class="xdoc"> *  
</span>    69    <span class="xdoc"> *  stackLibType may be set to the following values. If the configuration
</span>    70    <span class="xdoc"> *  parameter 'IPv6' is set to 'true', then this will result in the
</span>    71    <span class="xdoc"> *  following IPv6 library selections:
</span>    72    <span class="xdoc"> *  
</span>    73    <span class="xdoc"> *  <b>@p(blist)</b>
</span>    74    <span class="xdoc"> *  - Global.MIN                : stk6.lib
</span>    75    <span class="xdoc"> *  - Global.NONE               : stack.lib (default)
</span>    76    <span class="xdoc"> *  - Global.NAT                : stk6_nat.lib
</span>    77    <span class="xdoc"> *  - Global.NAT_PPP            : stk6_nat_ppp.lib
</span>    78    <span class="xdoc"> *  - Global.NAT_PPP_PPPOE      : stk6_nat_ppp_pppoe.lib
</span>    79    <span class="xdoc"> *  - Global.PPP                : stk6_ppp.lib
</span>    80    <span class="xdoc"> *  - Global.PPP_PPPOE          : stk6_ppp_pppoe.lib
</span>    81    <span class="xdoc"> *  <b>@p</b>
</span>    82    <span class="xdoc"> *  
</span>    83    <span class="xdoc"> *  If the configuration parameter 'IPv6' is set to 'false', then this will
</span>    84    <span class="xdoc"> *  result in the following IPv4 library selections:
</span>    85    <span class="xdoc"> *  
</span>    86    <span class="xdoc"> *  <b>@p(blist)</b>
</span>    87    <span class="xdoc"> *  - Global.MIN                : stk.lib
</span>    88    <span class="xdoc"> *  - Global.NONE               : stk_ppp_pppoe.lib (default)
</span>    89    <span class="xdoc"> *  - Global.NAT                : stk_nat.lib
</span>    90    <span class="xdoc"> *  - Global.NAT_PPP            : stk_nat_ppp.lib
</span>    91    <span class="xdoc"> *  - Global.NAT_PPP_PPPOE      : stk_nat_ppp_pppoe.lib
</span>    92    <span class="xdoc"> *  - Global.PPP                : stk_ppp.lib
</span>    93    <span class="xdoc"> *  - Global.PPP_PPPOE          : stk_ppp_pppoe.lib
</span>    94    <span class="xdoc"> *  <b>@p</b>
</span>    95    <span class="xdoc"> *  
</span>    96    <span class="xdoc"> *  In addition to NDK library selection, the Global module may be used to
</span>    97    <span class="xdoc"> *  change global configuration settings of the stack.  This includes settings
</span>    98    <span class="xdoc"> *  for the:
</span>    99    <span class="xdoc"> *  <b>@p(blist)</b>
</span>   100    <span class="xdoc"> *       - NDK OSAL
</span>   101    <span class="xdoc"> *       - Debug settings
</span>   102    <span class="xdoc"> *       - Default stack task priority levels and stack sizes
</span>   103    <span class="xdoc"> *       - Priority level and operating mode of the NDK scheduler thread.
</span>   104    <span class="xdoc"> *       - Calling user defined hook functions
</span>   105    <span class="xdoc"> *       - Enabling or disabling code generation.
</span>   106    <span class="xdoc"> *  <b>@p</b>
</span>   107    <span class="xdoc"> *  
</span>   108    <span class="xdoc"> *  Note that the Global module generates NDK C configuration code in order to
</span>   109    <span class="xdoc"> *  manipulate the settings of the above mentioned items.  In order for these
</span>   110    <span class="xdoc"> *  settings to take effect, code generation must be enabled in the Global
</span>   111    <span class="xdoc"> *  module.
</span>   112    <span class="xdoc"> *
</span>   113    <span class="xdoc"> *  If the code generation feature is enabled, then it's important to note that
</span>   114    <span class="xdoc"> *  the C code for several functions will be created, which may cause a
</span>   115    <span class="xdoc"> *  conflict if a program already has defined these functions, and then
</span>   116    <span class="xdoc"> *  later enables code generation.  These functions may also be updated
</span>   117    <span class="xdoc"> *  with C API calls that will correspond to the RTSC configuration settings
</span>   118    <span class="xdoc"> *  that were made.
</span>   119    <span class="xdoc"> *  
</span>   120    <span class="xdoc"> *  The following list is a list of the C functions that are generated as a
</span>   121    <span class="xdoc"> *  result of using the NDK RTSC configuration's code generating feature:
</span>   122    <span class="xdoc"> *  <b>@p(blist)</b>
</span>   123    <span class="xdoc"> *  - ti_ndk_config_Global_stackThread(): The NDK stack thread function.
</span>   124    <span class="xdoc"> *  - NetworkOpen(): function that is called automatically by NC_NetStart().
</span>   125    <span class="xdoc"> *  - NetworkClose(): function that is called automatically by NC_NetStart().
</span>   126    <span class="xdoc"> *  - NetworkIPAddr(): function that is called automatically by NC_NetStart().
</span>   127    <span class="xdoc"> *  - ti_ndk_config_Global_serviceReport(): Service report callback function.
</span>   128    <span class="xdoc"> *  <b>@p</b>
</span>   129    <span class="xdoc"> *  
</span>   130    <span class="xdoc"> *  The NDK RTSC configuration and code generation feature is really intended
</span>   131    <span class="xdoc"> *  to be used with a new NDK program, not with an existing one.  For example,
</span>   132    <span class="xdoc"> *  if the user has an already existing NDK program, and they wish to change
</span>   133    <span class="xdoc"> *  one of the configuration settings to that already existing program, then
</span>   134    <span class="xdoc"> *  the NDK RTSC configuration should *not* be used.  If the user were to use
</span>   135    <span class="xdoc"> *  the NDK RTSC configuration in this manner, then the resulting program
</span>   136    <span class="xdoc"> *  behavior would become unpredictable, due to having multiple NDK stack
</span>   137    <span class="xdoc"> *  threads running with different configuration settings.
</span>   138    <span class="xdoc"> *  
</span>   139    <span class="xdoc"> *  However, one could create a new NDK program that uses the RTSC
</span>   140    <span class="xdoc"> *  configuration in order to easily see the C configuration code needed to
</span>   141    <span class="xdoc"> *  change a particular stack setting.  This generated C configuration code
</span>   142    <span class="xdoc"> *  could then be copied from the new NDK program, and then pasted into the
</span>   143    <span class="xdoc"> *  user's existing program to add that setting.
</span>   144    <span class="xdoc"> *  
</span>   145    <span class="xdoc"> *  User Defined Hook Functions
</span>   146    <span class="xdoc"> *
</span>   147    <span class="xdoc"> *  Since the NDK stack thread function (as well as the other functions listed
</span>   148    <span class="xdoc"> *  above) is generated when using this code generation feature, the user will
</span>   149    <span class="xdoc"> *  not be able to directly add custom code into it.  In order to allow this,
</span>   150    <span class="xdoc"> *  a set of hook functions are provided.  These hook functions may be called
</span>   151    <span class="xdoc"> *  from various places from within the generated code.  The user can define
</span>   152    <span class="xdoc"> *  these hook functions as appropriate, and then assign the function names to
</span>   153    <span class="xdoc"> *  the Global modules ndkHookFxn configuration parameters.  For each
</span>   154    <span class="xdoc"> *  ndkHookFxn configuration paramter that is defined, a call to that
</span>   155    <span class="xdoc"> *  function will be added into the generated C code, as described by that
</span>   156    <span class="xdoc"> *  ndkHookFxn parameter.  Note that for some of these hook calls will be made
</span>   157    <span class="xdoc"> *  with useful parameters in order to pass down information into the user's
</span>   158    <span class="xdoc"> *  code (please refer to the hook descriptions for details on arguments
</span>   159    <span class="xdoc"> *  passed and prototype signature for these hooks).
</span>   160    <span class="xdoc"> *  
</span>   161    <span class="xdoc"> *  Note if the user specifies a hook function in the RTSC configuration
</span>   162    <span class="xdoc"> *  script, but does not define this function in their C code, a linker error
</span>   163    <span class="xdoc"> *  will result.
</span>   164    <span class="xdoc"> */</span>  
   165    
   166    @Template(<span class="string">"./Global.xdt"</span>)
   167    
   168    <span class=key>metaonly</span> <span class=key>module</span> Global {
   169    
   170        <span class="xdoc">/*!
</span>   171    <span class="xdoc">     *  ======== NetEventSchedPri ========
</span>   172    <span class="xdoc">     *  This defines the legal values for the priority setting for the Network
</span>   173    <span class="xdoc">     *  event scheduler task.
</span>   174    <span class="xdoc">     */</span>
   175        <span class=key>enum</span> NetEventSchedPri {
   176            NC_PRIORITY_LOW,  <span class="xdoc">/*! Low Priority */</span>
   177            NC_PRIORITY_HIGH  <span class="xdoc">/*! High Priority */</span>
   178        }
   179    
   180        <span class="xdoc">/*!
</span>   181    <span class="xdoc">     *  ======== NetEventSchedOp ========
</span>   182    <span class="xdoc">     *  This defines the legal values for the operating mode setting for the
</span>   183    <span class="xdoc">     *  Network event scheduler task.
</span>   184    <span class="xdoc">     */</span>
   185        <span class=key>enum</span> NetEventSchedOp {
   186            NC_OPMODE_POLLING,  <span class="xdoc">/*! Polling Mode */</span>
   187            NC_OPMODE_INTERRUPT <span class="xdoc">/*! Interrupt Mode */</span>
   188        }
   189    
   190        <span class="xdoc">/*!
</span>   191    <span class="xdoc">     *  ======== DebugLevel ========
</span>   192    <span class="xdoc">     *  This defines the legal values for the severity level of debug messages
</span>   193    <span class="xdoc">     *  and debug aborts in the stack.
</span>   194    <span class="xdoc">     */</span>
   195        <span class=key>enum</span> DebugLevel {
   196            DBG_INFO = 1,  <span class="xdoc">/*! Information Messages (DBG_INFO)*/</span>
   197            DBG_WARN,  <span class="xdoc">/*! Warning Messages (DBG_WARN)*/</span>
   198            DBG_ERROR, <span class="xdoc">/*! Error Messages (DBG_ERROR)*/</span>
   199            DBG_NONE   <span class="xdoc">/*! No Messages (DBG_NONE)*/</span>
   200        }
   201    
   202        <span class="xdoc">/*!
</span>   203    <span class="xdoc">     *  ======== StackLibProtocol ======== 
</span>   204    <span class="xdoc">     *  Defines the set of legal stack library types.
</span>   205    <span class="xdoc">     */</span>
   206        <span class=key>enum</span> StackLibProtocol {
   207            NONE,
   208            NAT,
   209            NAT_PPP,
   210            NAT_PPP_PPPOE,
   211            PPP,
   212            PPP_PPPOE,
   213            MIN
   214        };
   215    
   216        <span class="xdoc">/*! This data structure is used to add a user account */</span>
   217        <span class=key>struct</span> Account {
   218            String username;
   219            String password;
   220        };
   221    
   222        <span class="xdoc">/*! Array that holds all of the user accounts to be created. */</span>
   223        <span class=key>config</span> Account userAccounts[<span class=key>length</span>] = [];
   224    
   225        <span class="xdoc">/*! Function signature for user defined NDK hook functions */</span>
   226        <span class=key>typedef</span> Void (*ndkHookFxn)();
   227    
   228        <span class="xdoc">/*!
</span>   229    <span class="xdoc">     *  ======== StackRunModeFlags ========
</span>   230    <span class="xdoc">     *  This defines the legal values for the flags that can be used for setting
</span>   231    <span class="xdoc">     *  multiCoreStackRun, which determines the processors for which the stack
</span>   232    <span class="xdoc">     *  should run on when multiple cores are present.
</span>   233    <span class="xdoc">     */</span>
   234    
   235        <span class="xdoc">/*! Type used to specify bits in mode */</span>
   236        <span class=key>typedef</span> Bits32 StackRunModeFlags;
   237    
   238        <span class=key>const</span> StackRunModeFlags STACKRUN_FLG_CORE_0       = 0x1;
   239        <span class=key>const</span> StackRunModeFlags STACKRUN_FLG_CORE_1       = 0x2;
   240        <span class=key>const</span> StackRunModeFlags STACKRUN_FLG_CORE_2       = 0x4;
   241        <span class=key>const</span> StackRunModeFlags STACKRUN_FLG_CORE_3       = 0x8;
   242        <span class=key>const</span> StackRunModeFlags STACKRUN_FLG_CORE_4       = 0x10;
   243        <span class=key>const</span> StackRunModeFlags STACKRUN_FLG_CORE_5       = 0x20;
   244        <span class=key>const</span> StackRunModeFlags STACKRUN_FLG_CORE_6       = 0x40;
   245        <span class=key>const</span> StackRunModeFlags STACKRUN_FLG_CORE_7       = 0x80;
   246        <span class=key>const</span> StackRunModeFlags STACKRUN_FLG_CORE_8       = 0x100;
   247        <span class=key>const</span> StackRunModeFlags STACKRUN_FLG_CORE_9       = 0x200;
   248        <span class=key>const</span> StackRunModeFlags STACKRUN_FLG_CORE_10      = 0x400;
   249        <span class=key>const</span> StackRunModeFlags STACKRUN_FLG_CORE_11      = 0x800;
   250        <span class=key>const</span> StackRunModeFlags STACKRUN_FLG_CORE_12      = 0x1000;
   251        <span class=key>const</span> StackRunModeFlags STACKRUN_FLG_CORE_13      = 0x2000;
   252        <span class=key>const</span> StackRunModeFlags STACKRUN_FLG_CORE_14      = 0x4000;
   253        <span class=key>const</span> StackRunModeFlags STACKRUN_FLG_CORE_15      = 0x8000;
   254        <span class=key>const</span> StackRunModeFlags STACKRUN_FLG_CORE_16      = 0x10000;
   255        <span class=key>const</span> StackRunModeFlags STACKRUN_FLG_CORE_17      = 0x20000;
   256        <span class=key>const</span> StackRunModeFlags STACKRUN_FLG_CORE_18      = 0x40000;
   257        <span class=key>const</span> StackRunModeFlags STACKRUN_FLG_CORE_19      = 0x80000;
   258        <span class=key>const</span> StackRunModeFlags STACKRUN_FLG_CORE_20      = 0x100000;
   259        <span class=key>const</span> StackRunModeFlags STACKRUN_FLG_CORE_21      = 0x200000;
   260        <span class=key>const</span> StackRunModeFlags STACKRUN_FLG_CORE_22      = 0x400000;
   261        <span class=key>const</span> StackRunModeFlags STACKRUN_FLG_CORE_23      = 0x800000;
   262        <span class=key>const</span> StackRunModeFlags STACKRUN_FLG_CORE_24      = 0x1000000;
   263        <span class=key>const</span> StackRunModeFlags STACKRUN_FLG_CORE_25      = 0x2000000;
   264        <span class=key>const</span> StackRunModeFlags STACKRUN_FLG_CORE_26      = 0x4000000;
   265        <span class=key>const</span> StackRunModeFlags STACKRUN_FLG_CORE_27      = 0x8000000;
   266        <span class=key>const</span> StackRunModeFlags STACKRUN_FLG_CORE_28      = 0x10000000;
   267        <span class=key>const</span> StackRunModeFlags STACKRUN_FLG_CORE_29      = 0x20000000;
   268        <span class=key>const</span> StackRunModeFlags STACKRUN_FLG_CORE_30      = 0x40000000;
   269        <span class=key>const</span> StackRunModeFlags STACKRUN_FLG_CORE_31      = 0x80000000;
   270    
   271        <span class="xdoc">/*!
</span>   272    <span class="xdoc">     * Default values
</span>   273    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   274    <span class="xdoc">     */</span>
   275        <span class=key>const</span> DebugLevel defaultDebugPrintLevel = DBG_INFO;
   276        <span class=key>const</span> DebugLevel defaultDebugAbortLevel = DBG_ERROR;
   277        <span class=key>const</span> Int defaultLowTaskPriLevel  = 3;
   278        <span class=key>const</span> Int defaultNormTaskPriLevel = 5;
   279        <span class=key>const</span> Int defaultHighTaskPriLevel = 7;
   280        <span class=key>const</span> Int defaultKernTaskPriLevel = 9;
   281        <span class=key>const</span> Int defaultLowTaskStackSize  = 3072;
   282        <span class=key>const</span> Int defaultNormTaskStackSize = 4096;
   283        <span class=key>const</span> Int defaultHighTaskStackSize = 5120;
   284        <span class=key>const</span> Int defaultNdkTaskStackSize  = 8192;
   285        <span class=key>const</span> Int defaultNdkTickPeriod     = 100;
   286    
   287    
   288        <span class="xdoc">/*!
</span>   289    <span class="xdoc">     *  Set of flags which used to specify which cores the NDK stack should run
</span>   290    <span class="xdoc">     *  on for multi-core processors.  Default is to run the stack on core 0.
</span>   291    <span class="xdoc">     *
</span>   292    <span class="xdoc">     *  This configuration parameter is only valid for C6000 multi-core
</span>   293    <span class="xdoc">     *  processors.
</span>   294    <span class="xdoc">     *  
</span>   295    <span class="xdoc">     *  The following flag values may be set either individually, or by OR-ing
</span>   296    <span class="xdoc">     *  flags together, in order to run the stack on other cores
</span>   297    <span class="xdoc">     *  (or combination of cores):
</span>   298    <span class="xdoc">     *
</span>   299    <span class="xdoc">     *  Currently supports up to 32 cores.
</span>   300    <span class="xdoc">     *
</span>   301    <span class="xdoc">     * <b>@p(blist)</b>
</span>   302    <span class="xdoc">     *    - STACKRUN_FLG_CORE_0 - specifies that the stack should run on core 0
</span>   303    <span class="xdoc">     *  
</span>   304    <span class="xdoc">     *    - STACKRUN_FLG_CORE_1 - specifies that the stack should run on core 1
</span>   305    <span class="xdoc">     *  
</span>   306    <span class="xdoc">     *    - STACKRUN_FLG_CORE_2 - specifies that the stack should run on core 2
</span>   307    <span class="xdoc">     *  
</span>   308    <span class="xdoc">     *    - STACKRUN_FLG_CORE_3 - specifies that the stack should run on core 3
</span>   309    <span class="xdoc">     *  
</span>   310    <span class="xdoc">     *    - STACKRUN_FLG_CORE_4 - specifies that the stack should run on core 4
</span>   311    <span class="xdoc">     *  
</span>   312    <span class="xdoc">     *    - STACKRUN_FLG_CORE_5 - specifies that the stack should run on core 5
</span>   313    <span class="xdoc">     *  
</span>   314    <span class="xdoc">     * <b>@p</b>
</span>   315    <span class="xdoc">     */</span>
   316        <span class=key>config</span> StackRunModeFlags multiCoreStackRunMode = STACKRUN_FLG_CORE_0;
   317    
   318        <span class="xdoc">/*!
</span>   319    <span class="xdoc">     *  When true, the IPv6 version of the NDK libraries will be used, otherwise
</span>   320    <span class="xdoc">     *  the IPv4 versions will be linked.
</span>   321    <span class="xdoc">     *
</span>   322    <span class="xdoc">     *  Default is IPv6.
</span>   323    <span class="xdoc">     */</span>
   324        <span class=key>config</span> Bool IPv6 = <span class=key>true</span>;
   325    
   326        <span class="xdoc">/*!
</span>   327    <span class="xdoc">     *  Variable used for choosing the NDK library to be linked into a program.
</span>   328    <span class="xdoc">     *  Default stack library is PPP_PPPOE
</span>   329    <span class="xdoc">     *
</span>   330    <span class="xdoc">     *  NONE:          Links in support for NAT, PPP, and PPPoE (default).
</span>   331    <span class="xdoc">     *  NAT:           Links in support for NAT.
</span>   332    <span class="xdoc">     *  NAT_PPP:       Links in support for NAT and PPP.
</span>   333    <span class="xdoc">     *  NAT_PPP_PPPOE: Links in support for NAT, PPP, and PPPoE.
</span>   334    <span class="xdoc">     *  PPP:           Links in support for PPP.
</span>   335    <span class="xdoc">     *  PPP_PPPOE:     Links in support for PPP and PPPoE.
</span>   336    <span class="xdoc">     *  MIN:           Minimal stack library.  Does not link any support NAT, PPP or PPPoE.
</span>   337    <span class="xdoc">     */</span>
   338        <span class=key>config</span> StackLibProtocol stackLibType = NONE;
   339    
   340        <span class="xdoc">/*!
</span>   341    <span class="xdoc">     *  Variable to cause the semaphore version of the NDK libraries to be linked into a program.
</span>   342    <span class="xdoc">     * 
</span>   343    <span class="xdoc">     *  true: link libraries which use Semaphore for kernel mode. 
</span>   344    <span class="xdoc">     *  false: (Default) link libraries which use Task priority for kernel mode. 
</span>   345    <span class="xdoc">     */</span>
   346        <span class=key>config</span> Bool useSemLibs = <span class=key>false</span>;
   347    
   348        <span class="xdoc">/*!
</span>   349    <span class="xdoc">     *  Sets the severity level of system debug messages that are recorded to
</span>   350    <span class="xdoc">     *  the debug log.
</span>   351    <span class="xdoc">     */</span>
   352        <span class=key>config</span> DebugLevel debugPrintLevel = defaultDebugPrintLevel;
   353    
   354        <span class="xdoc">/*!
</span>   355    <span class="xdoc">     *  Sets the severity level of system debug messages that that result in a
</span>   356    <span class="xdoc">     *  system shutdown.
</span>   357    <span class="xdoc">     */</span>
   358        <span class=key>config</span> DebugLevel debugAbortLevel = defaultDebugAbortLevel;
   359    
   360        <span class="xdoc">/*! Sets the priority value for low priority NDK tasks */</span>
   361        <span class=key>config</span> Int lowTaskPriLevel  = defaultLowTaskPriLevel;
   362    
   363        <span class="xdoc">/*! Sets the priority value for normal priority NDK tasks */</span>
   364        <span class=key>config</span> Int normTaskPriLevel = defaultNormTaskPriLevel;
   365    
   366        <span class="xdoc">/*! Sets the priority value for high priority NDK tasks */</span>
   367        <span class=key>config</span> Int highTaskPriLevel = defaultHighTaskPriLevel;
   368    
   369        <span class="xdoc">/*! Sets the priority value for kernel priority NDK tasks */</span>
   370        <span class=key>config</span> Int kernTaskPriLevel = defaultKernTaskPriLevel;
   371    
   372        <span class="xdoc">/*! Sets the default stack size for low priority NDK tasks */</span>
   373        <span class=key>config</span> Int lowTaskStackSize = defaultLowTaskStackSize;
   374    
   375        <span class="xdoc">/*! Sets the default stack size for normal priority NDK tasks */</span>
   376        <span class=key>config</span> Int normTaskStackSize = defaultNormTaskStackSize;
   377    
   378        <span class="xdoc">/*! Sets the default stack size for high priority NDK tasks */</span>
   379        <span class=key>config</span> Int highTaskStackSize = defaultHighTaskStackSize;
   380    
   381        <span class="xdoc">/*!
</span>   382    <span class="xdoc">     *  Enables the NDK stack thread and C stack configuration code to be
</span>   383    <span class="xdoc">     *  generated automatically for the application. When false, no C code is
</span>   384    <span class="xdoc">     *  generated, but NDK libraries are still linked into the application
</span>   385    <span class="xdoc">     *  automatically.
</span>   386    <span class="xdoc">     */</span>
   387        <span class=key>config</span> Bool enableCodeGeneration = <span class=key>true</span>;
   388    
   389        <span class="xdoc">/*!
</span>   390    <span class="xdoc">     *  Automatically open/close file descriptor session
</span>   391    <span class="xdoc">     *  
</span>   392    <span class="xdoc">     *  When true, calls to fdOpenSession and fdCloseSession will be made
</span>   393    <span class="xdoc">     *  automatically for dynamically created Tasks.  This allows standard BSD
</span>   394    <span class="xdoc">     *  sockets code fit more easily into an NDK application.
</span>   395    <span class="xdoc">     *  
</span>   396    <span class="xdoc">     *  Note that this is only supported for dynamically created tasks that are
</span>   397    <span class="xdoc">     *  created from within Task context (i.e. from within an already running
</span>   398    <span class="xdoc">     *  Task function).  Tasks created from the configuration or dynamically
</span>   399    <span class="xdoc">     *  in main or a Hwi or Swi thread will not have support for this feature.  
</span>   400    <span class="xdoc">     *
</span>   401    <span class="xdoc">     *  Disabled by default.
</span>   402    <span class="xdoc">     */</span>
   403        <span class=key>config</span> Bool autoOpenCloseFD = <span class=key>false</span>;
   404    
   405    
   406        <span class="xdoc">/*!
</span>   407    <span class="xdoc">     *  Allows user to define their own implementation of the NDK stack thread
</span>   408    <span class="xdoc">     *
</span>   409    <span class="xdoc">     *  If set, the user is responsible for defining the NDK stack
</span>   410    <span class="xdoc">     *  thread, which has no return value and has two parameters of type UArg.
</span>   411    <span class="xdoc">     *
</span>   412    <span class="xdoc">     *  For example (C code):
</span>   413    <span class="xdoc">     *
</span>   414    <span class="xdoc">     *      Void MYMODULE_stackThreadUser(UArg arg0, UArg arg1);
</span>   415    <span class="xdoc">     *
</span>   416    <span class="xdoc">     *  And in the configuration file:
</span>   417    <span class="xdoc">     *
</span>   418    <span class="xdoc">     *      Global.stackThreadUser = '&amp;MYMODULE_stackThreadUser';
</span>   419    <span class="xdoc">     *
</span>   420    <span class="xdoc">     *  The user is also responsible for creating the SYS/BIOS Clock
</span>   421    <span class="xdoc">     *  instance for the NDK 100ms heartbeat, calling appropriate NC_* APIs,
</span>   422    <span class="xdoc">     *  and adding the appropriate C run time configuration code that matches
</span>   423    <span class="xdoc">     *  the settings of the BIOS config file in the function. (e.g. if
</span>   424    <span class="xdoc">     *  configuring the Ip module, the stack thread must call NC_SystemOpen(),
</span>   425    <span class="xdoc">     *  'ti_ndk_config_ip_init(hCfg)', etc.).
</span>   426    <span class="xdoc">     */</span>
   427        <span class=key>config</span> ndkHookFxn stackThreadUser = <span class=key>null</span>;
   428    
   429        <span class="xdoc">/*! Priority of the generated NDK task 'ti_ndk_config_Global_stackThread' */</span>
   430        <span class=key>config</span> Int ndkThreadPri = defaultNormTaskPriLevel;
   431    
   432        <span class="xdoc">/*! Stack size of the generated NDK task 'ti_ndk_config_Global_stackThread' */</span>
   433        <span class=key>config</span> Int ndkThreadStackSize = defaultNdkTaskStackSize;
   434    
   435        <span class="xdoc">/*!
</span>   436    <span class="xdoc">     *  Tick period in Clock ticks for the NDK heartbeat
</span>   437    <span class="xdoc">     *
</span>   438    <span class="xdoc">     *  Default value set to 100 ticks to match the default tick rate of
</span>   439    <span class="xdoc">     *  1 tick = 1 millisecond.  Note that if the a custom Timer is configured
</span>   440    <span class="xdoc">     *  to drive the Clock module with a period other than 1 millisecond
</span>   441    <span class="xdoc">     *  per tick, then you must adjust the ndkTickPeriod accordingly.
</span>   442    <span class="xdoc">    */</span>
   443        <span class=key>config</span> Int ndkTickPeriod = defaultNdkTickPeriod;
   444    
   445        <span class="xdoc">/*! The priority level at which the NDK net scheduler task runs. */</span>
   446        <span class=key>config</span> NetEventSchedPri netSchedulerPri = NC_PRIORITY_LOW;
   447    
   448        <span class="xdoc">/*! The manner at which the NDK net scheduler task runs. */</span>
   449        <span class=key>config</span> NetEventSchedOp netSchedulerOpMode = NC_OPMODE_INTERRUPT;
   450    
   451        <span class="xdoc">/*! The name for authorization realm 1 */</span>
   452        <span class=key>config</span> String realm1Name = <span class=key>null</span>;
   453    
   454        <span class="xdoc">/*! The name for authorization realm 2 */</span>
   455        <span class=key>config</span> String realm2Name = <span class=key>null</span>;
   456    
   457        <span class="xdoc">/*! The name for authorization realm 3 */</span>
   458        <span class=key>config</span> String realm3Name = <span class=key>null</span>;
   459    
   460        <span class="xdoc">/*! The name for authorization realm 4 */</span>
   461        <span class=key>config</span> String realm4Name = <span class=key>null</span>;
   462    
   463        <span class="xdoc">/*!
</span>   464    <span class="xdoc">     *  Packet Buffer Manager (PBM) number of frames
</span>   465    <span class="xdoc">     *
</span>   466    <span class="xdoc">     *  Used to set the size of PBM 'pBufMem[]'.
</span>   467    <span class="xdoc">     */</span>
   468        <span class=key>config</span> Int pktNumFrameBufs = 192;
   469    
   470        <span class="xdoc">/*!
</span>   471    <span class="xdoc">     *  Packet Buffer Manager (PBM) size frame buffer
</span>   472    <span class="xdoc">     *
</span>   473    <span class="xdoc">     *  Used to set the size of PBM 'pHdrMem[]'.
</span>   474    <span class="xdoc">     */</span>
   475        <span class=key>config</span> Int pktSizeFrameBuf = 1536;
   476    
   477        <span class="xdoc">/*!
</span>   478    <span class="xdoc">     *  Packet Buffer Manager (PBM) buffer data section
</span>   479    <span class="xdoc">     *
</span>   480    <span class="xdoc">     *  Section to place PBM buffers 'pBufMem' and 'pHdrMem'.
</span>   481    <span class="xdoc">     */</span>
   482        <span class=key>config</span> String pbmDataSection = <span class="string">".far:NDK_PACKETMEM"</span>;
   483    
   484        <span class="xdoc">/*!
</span>   485    <span class="xdoc">     *  Memory Manager page size
</span>   486    <span class="xdoc">     *
</span>   487    <span class="xdoc">     *  Used to set the size of OSAL's 'pitBuffer[]'.
</span>   488    <span class="xdoc">     */</span>
   489        <span class=key>config</span> Int memRawPageSize = 3072;
   490    
   491        <span class="xdoc">/*!
</span>   492    <span class="xdoc">     *  Memory Manager page count
</span>   493    <span class="xdoc">     *
</span>   494    <span class="xdoc">     *  Used to set the size of OSAL's 'pit[]' and 'pitBuffer[]'.
</span>   495    <span class="xdoc">     */</span>
   496        <span class=key>config</span> Int memRawPageCount = 16;
   497    
   498        <span class="xdoc">/*!
</span>   499    <span class="xdoc">     *  Memory Manager buffer data section
</span>   500    <span class="xdoc">     *
</span>   501    <span class="xdoc">     *  Section to place NDK memory manager buffers 'pit[]', 'pitBuffer[]' and
</span>   502    <span class="xdoc">     *   'Id2Size[]'.
</span>   503    <span class="xdoc">     */</span>
   504        <span class=key>config</span> String memDataSection = <span class="string">".far:NDK_MMBUFFER"</span>;
   505    
   506        <span class="xdoc">/*!
</span>   507    <span class="xdoc">     *  User defined hook function to run in the NDK stack thread
</span>   508    <span class="xdoc">     *  ti_ndk_config_Global_stackThread().  This function will run at
</span>   509    <span class="xdoc">     *  the very beginning of the stack thread, before the call to
</span>   510    <span class="xdoc">     *  NC_SystemOpen() is made.  It will not be passed any arguments.
</span>   511    <span class="xdoc">     *
</span>   512    <span class="xdoc">     *  For example, if your configuration sets 'stackBeginHook' to a function
</span>   513    <span class="xdoc">     *  called "myBeginFxn":
</span>   514    <span class="xdoc">     *
</span>   515    <span class="xdoc">     *      var Global = xdc.useModule('ti.ndk.config.Global');
</span>   516    <span class="xdoc">     *      Global.stackBeginHook = '&amp;myBeginFxn';
</span>   517    <span class="xdoc">     *
</span>   518    <span class="xdoc">     *  Then a call to "myBeginFxn" will be generated as follows:
</span>   519    <span class="xdoc">     *
</span>   520    <span class="xdoc">     *      myBeginFxn();
</span>   521    <span class="xdoc">     *
</span>   522    <span class="xdoc">     */</span>
   523        <span class=key>config</span> ndkHookFxn stackBeginHook = <span class=key>null</span>;
   524    
   525        <span class="xdoc">/*!
</span>   526    <span class="xdoc">     *  User defined hook function to run in the NDK stack thread
</span>   527    <span class="xdoc">     *  ti_ndk_config_Global_stackThread().  This function will run immediately
</span>   528    <span class="xdoc">     *  after the function call to create a new configuration, CfgNew(), and
</span>   529    <span class="xdoc">     *  will be passed the handle to that configuration.
</span>   530    <span class="xdoc">     *
</span>   531    <span class="xdoc">     *  For example, if your configuration sets 'stackInitHook' to a function
</span>   532    <span class="xdoc">     *  called "myInitFxn":
</span>   533    <span class="xdoc">     *
</span>   534    <span class="xdoc">     *      var Global = xdc.useModule('ti.ndk.config.Global');
</span>   535    <span class="xdoc">     *      Global.stackInitHook = '&amp;myInitFxn';
</span>   536    <span class="xdoc">     *
</span>   537    <span class="xdoc">     *  Then a call to "myInitFxn" will be generated as follows:
</span>   538    <span class="xdoc">     *
</span>   539    <span class="xdoc">     *      myInitFxn(hCfg);
</span>   540    <span class="xdoc">     *
</span>   541    <span class="xdoc">     *  Therefore, if you wish to use the configuration handle in "myInitFxn",
</span>   542    <span class="xdoc">     *  then you should define it so that it can accept the handle passed to it:
</span>   543    <span class="xdoc">     *  
</span>   544    <span class="xdoc">     *      Void myInitFxn(HANDLE hCfg)
</span>   545    <span class="xdoc">     *      {  
</span>   546    <span class="xdoc">     *          ...
</span>   547    <span class="xdoc">     *      }  
</span>   548    <span class="xdoc">     */</span>
   549        <span class=key>config</span> ndkHookFxn stackInitHook = <span class=key>null</span>;
   550    
   551        <span class="xdoc">/*!
</span>   552    <span class="xdoc">     *  User defined hook function to run in the NDK stack thread
</span>   553    <span class="xdoc">     *  ti_ndk_config_Global_stackThread().  This function will run immediately
</span>   554    <span class="xdoc">     *  after the return from NC_NetStart() and within the while() loop which contains
</span>   555    <span class="xdoc">     *  the NC_NetStart() call.  It will be passed a handle to the configuration
</span>   556    <span class="xdoc">     *  as well as the valued returned from NC_NetStart.
</span>   557    <span class="xdoc">     *
</span>   558    <span class="xdoc">     *  For example, if your configuration sets 'stackRebootHook' to a function
</span>   559    <span class="xdoc">     *  called "myRebootFxn":
</span>   560    <span class="xdoc">     *
</span>   561    <span class="xdoc">     *      var Global = xdc.useModule('ti.ndk.config.Global');
</span>   562    <span class="xdoc">     *      Global.stackRebootHook = '&amp;myRebootFxn';
</span>   563    <span class="xdoc">     *
</span>   564    <span class="xdoc">     *  Then a call to "myRebootFxn" will be generated after the call to
</span>   565    <span class="xdoc">     *  NC_NetStart(), but within the do/while loop, which allows this hook to
</span>   566    <span class="xdoc">     *  run for the case of the NDK stack thread rebooting.  The generated code
</span>   567    <span class="xdoc">     *  will look similar to the following:
</span>   568    <span class="xdoc">     *
</span>   569    <span class="xdoc">     *      do
</span>   570    <span class="xdoc">     *      {
</span>   571    <span class="xdoc">     *           rc = NC_NetStart(hCfg, ti_ndk_config_Global_NetworkOpen,
</span>   572    <span class="xdoc">     *                   ti_ndk_config_Global_NetworkClose,
</span>   573    <span class="xdoc">     *                   ti_ndk_config_Global_NetworkIPAddr);
</span>   574    <span class="xdoc">     *
</span>   575    <span class="xdoc">     *           myRebootFxn(hCfg, rc);
</span>   576    <span class="xdoc">     *
</span>   577    <span class="xdoc">     *      } while( rc &gt; 0 );
</span>   578    <span class="xdoc">     *
</span>   579    <span class="xdoc">     *
</span>   580    <span class="xdoc">     *  Therefore, if you wish to use the configuration handle and return code
</span>   581    <span class="xdoc">     *  in "myRebootFxn", then you should define it so that it has such
</span>   582    <span class="xdoc">     *  parameters:
</span>   583    <span class="xdoc">     *
</span>   584    <span class="xdoc">     *      Void myRebootFxn(HANDLE hCfg, int rc)
</span>   585    <span class="xdoc">     *      {
</span>   586    <span class="xdoc">     *          ...
</span>   587    <span class="xdoc">     *      }
</span>   588    <span class="xdoc">     */</span>
   589        <span class=key>config</span> ndkHookFxn stackRebootHook = <span class=key>null</span>;
   590    
   591        <span class="xdoc">/*!
</span>   592    <span class="xdoc">     *  User defined hook function to run in the NDK stack thread
</span>   593    <span class="xdoc">     *  ti_ndk_config_Global_stackThread().  This function will run immediately
</span>   594    <span class="xdoc">     *  after exiting from the while() loop which contains the call to
</span>   595    <span class="xdoc">     *  NC_NetStart(), but before the subsequent calls to CfgFree( hCfg ) and
</span>   596    <span class="xdoc">     *  NC_SystemClose().  It will be passed a handle to the configuration as
</span>   597    <span class="xdoc">     *  well as the valued returned from NC_NetStart.
</span>   598    <span class="xdoc">     *
</span>   599    <span class="xdoc">     *  For example, if your configuration sets 'stackDeleteHook' to a function
</span>   600    <span class="xdoc">     *  called "myDeleteFxn":
</span>   601    <span class="xdoc">     *
</span>   602    <span class="xdoc">     *      var Global = xdc.useModule('ti.ndk.config.Global');
</span>   603    <span class="xdoc">     *      Global.stackDeleteHook = '&amp;myDeleteFxn';
</span>   604    <span class="xdoc">     *
</span>   605    <span class="xdoc">     *  Then a call to "myDeleteFxn" will be generated after the call to
</span>   606    <span class="xdoc">     *  NC_NetStart(), similar to the following:
</span>   607    <span class="xdoc">     *
</span>   608    <span class="xdoc">     *      do
</span>   609    <span class="xdoc">     *      {
</span>   610    <span class="xdoc">     *           rc = NC_NetStart(hCfg, ti_ndk_config_Global_NetworkOpen, 
</span>   611    <span class="xdoc">     *                   ti_ndk_config_Global_NetworkClose, 
</span>   612    <span class="xdoc">     *                   ti_ndk_config_Global_NetworkIPAddr);
</span>   613    <span class="xdoc">     *      } while( rc &gt; 0 );
</span>   614    <span class="xdoc">     *
</span>   615    <span class="xdoc">     *      myDeleteFxn(hCfg, rc);
</span>   616    <span class="xdoc">     *
</span>   617    <span class="xdoc">     *  Therefore, if you wish to use the configuration handle in "myDeleteFxn",
</span>   618    <span class="xdoc">     *  then you should define it so that it can accept the handle passed to it:
</span>   619    <span class="xdoc">     *  
</span>   620    <span class="xdoc">     *      Void myDeleteFxn(HANDLE hCfg, int rc)
</span>   621    <span class="xdoc">     *      {  
</span>   622    <span class="xdoc">     *          ...
</span>   623    <span class="xdoc">     *      }  
</span>   624    <span class="xdoc">     */</span>
   625        <span class=key>config</span> ndkHookFxn stackDeleteHook = <span class=key>null</span>;
   626    
   627        <span class="xdoc">/*!
</span>   628    <span class="xdoc">     *  User defined hook function to run in the NDK status report callback
</span>   629    <span class="xdoc">     *  funtion, ti_ndk_config_Global_serviceReport().  This function will run
</span>   630    <span class="xdoc">     *  at the beginning of the service report function and will be passed the
</span>   631    <span class="xdoc">     *  the same arguments passed to ti_ndk_config_Global_serviceReport(),
</span>   632    <span class="xdoc">     *  Item, Status, Report and h.
</span>   633    <span class="xdoc">     *
</span>   634    <span class="xdoc">     *  For example, if your configuration sets 'serviceReportHook' to a function
</span>   635    <span class="xdoc">     *  called "myReportFxn":
</span>   636    <span class="xdoc">     *
</span>   637    <span class="xdoc">     *      var Global = xdc.useModule('ti.ndk.config.Global');
</span>   638    <span class="xdoc">     *      Global.serviceReportHook = '&amp;myReportFxn';
</span>   639    <span class="xdoc">     *
</span>   640    <span class="xdoc">     *  Then a call to "myReportFxn" will be generated as follows:
</span>   641    <span class="xdoc">     *
</span>   642    <span class="xdoc">     *      myReportFxn(Item, Status, Report, h);
</span>   643    <span class="xdoc">     *
</span>   644    <span class="xdoc">     *  Therefore, if you wish to use the configuration handle in "myReportFxn",
</span>   645    <span class="xdoc">     *  then you should define it so that it can accept the handle passed to it:
</span>   646    <span class="xdoc">     *  
</span>   647    <span class="xdoc">     *      Void myReportFxn(uint Item, uint Status, uint Report, HANDLE h)
</span>   648    <span class="xdoc">     *      {  
</span>   649    <span class="xdoc">     *          ...
</span>   650    <span class="xdoc">     *      }  
</span>   651    <span class="xdoc">     */</span>
   652        <span class=key>config</span> ndkHookFxn serviceReportHook = <span class=key>null</span>;
   653    
   654        <span class="xdoc">/*!
</span>   655    <span class="xdoc">     *  User defined hook function to run inside the NDK Network Start callback
</span>   656    <span class="xdoc">     *  function, NetworkOpen().  The Network Start callback function is called
</span>   657    <span class="xdoc">     *  when the stack is ready to begin the creation of application supplied
</span>   658    <span class="xdoc">     *  network tasks.  This hook function will run immediately, upon entering
</span>   659    <span class="xdoc">     *  the NetworkOpen() function.  Note that this function is called during
</span>   660    <span class="xdoc">     *  the early stages of the stack startup, and must return in order for the
</span>   661    <span class="xdoc">     *  stack to resume operations.  It will not be passed any arguments.
</span>   662    <span class="xdoc">     *
</span>   663    <span class="xdoc">     *  For example, if your configuration sets 'networkOpenHook' to a function
</span>   664    <span class="xdoc">     *  called "myNetOpenFxn":
</span>   665    <span class="xdoc">     *
</span>   666    <span class="xdoc">     *      var Global = xdc.useModule('ti.ndk.config.Global');
</span>   667    <span class="xdoc">     *      Global.networkOpenHook = '&amp;myNetOpenFxn';
</span>   668    <span class="xdoc">     *
</span>   669    <span class="xdoc">     *  Then a call to "myNetOpenFxn" will be generated as follows:
</span>   670    <span class="xdoc">     *
</span>   671    <span class="xdoc">     *      myNetOpenFxn();
</span>   672    <span class="xdoc">     *
</span>   673    <span class="xdoc">     */</span>
   674        <span class=key>config</span> ndkHookFxn networkOpenHook = <span class=key>null</span>;
   675    
   676        <span class="xdoc">/*!
</span>   677    <span class="xdoc">     *  User defined hook function to run in the NDK Network Stop callback
</span>   678    <span class="xdoc">     *  function, NetworkClose().  The Network Close callback function is
</span>   679    <span class="xdoc">     *  called when the stack is about to shut down.  This hook function will
</span>   680    <span class="xdoc">     *  run immediately, upon entering the NetworkClose() function. It will not
</span>   681    <span class="xdoc">     *  be passed any arguments.
</span>   682    <span class="xdoc">     *
</span>   683    <span class="xdoc">     *  For example, if your configuration sets 'networkCloseHook' to a function
</span>   684    <span class="xdoc">     *  called "myNetCloseFxn":
</span>   685    <span class="xdoc">     *
</span>   686    <span class="xdoc">     *      var Global = xdc.useModule('ti.ndk.config.Global');
</span>   687    <span class="xdoc">     *      Global.networkCloseHook = '&amp;myNetCloseFxn';
</span>   688    <span class="xdoc">     *
</span>   689    <span class="xdoc">     *  Then a call to "myNetCloseFxn" will be generated as follows:
</span>   690    <span class="xdoc">     *
</span>   691    <span class="xdoc">     *      myNetCloseFxn();
</span>   692    <span class="xdoc">     *
</span>   693    <span class="xdoc">     */</span>
   694        <span class=key>config</span> ndkHookFxn networkCloseHook = <span class=key>null</span>;
   695    
   696        <span class="xdoc">/*!
</span>   697    <span class="xdoc">     *  User defined hook function to run in the NDK Network IP address
</span>   698    <span class="xdoc">     *  callback function, NetworkIPAddr().  The Network IP address callback
</span>   699    <span class="xdoc">     *  function is called when an IP address is added or removed from the
</span>   700    <span class="xdoc">     *  system.  This hook function will run immediately, upon entering the
</span>   701    <span class="xdoc">     *  NetworkIPAddr() function and is passed the same arguments passed to
</span>   702    <span class="xdoc">     *  NetworkIPAddr(), IPAddr, IfIdx, fAdd.
</span>   703    <span class="xdoc">     *
</span>   704    <span class="xdoc">     *  For example, if your configuration sets 'networkIPAddrHook' to a
</span>   705    <span class="xdoc">     *  function called "myIPAddrHook":
</span>   706    <span class="xdoc">     *
</span>   707    <span class="xdoc">     *      var Global = xdc.useModule('ti.ndk.config.Global');
</span>   708    <span class="xdoc">     *      Global.networkIPAddrHook = '&amp;myIPAddrHook';
</span>   709    <span class="xdoc">     *
</span>   710    <span class="xdoc">     *  Then a call to "myIPAddrHook" will be generated as follows:
</span>   711    <span class="xdoc">     *
</span>   712    <span class="xdoc">     *      myIPAddrHook(hCfg);
</span>   713    <span class="xdoc">     *
</span>   714    <span class="xdoc">     *  Therefore, if you wish to use the configuration handle in "myIPAddrHook",
</span>   715    <span class="xdoc">     *  then you should define it so that it can accept the arguments passed to
</span>   716    <span class="xdoc">     *  it:
</span>   717    <span class="xdoc">     *  
</span>   718    <span class="xdoc">     *      Void myIPAddrHook(IPN IPAddr, uint IfIdx, uint fAdd)
</span>   719    <span class="xdoc">     *      {  
</span>   720    <span class="xdoc">     *          ...
</span>   721    <span class="xdoc">     *      }  
</span>   722    <span class="xdoc">     */</span>
   723        <span class=key>config</span> ndkHookFxn networkIPAddrHook = <span class=key>null</span>;
   724    
   725        <span class="xdoc">/*!
</span>   726    <span class="xdoc">     *  ======== addUserAccount ========
</span>   727    <span class="xdoc">     *  addUserAccount is used in a config file to add a new user account into
</span>   728    <span class="xdoc">     *  the set of user accounts (and corresponding passwords) that will be
</span>   729    <span class="xdoc">     *  added into the NDK configuration.
</span>   730    <span class="xdoc">     *
</span>   731    <span class="xdoc">     *  A user account is created by making a struct Account, setting that
</span>   732    <span class="xdoc">     *  structs username and password for the account to be added, and then
</span>   733    <span class="xdoc">     *  calling this function to add it. For example:
</span>   734    <span class="xdoc">     *  
</span>   735    <span class="xdoc">     *  
</span>   736    <span class="xdoc">     *       Account acct1;
</span>   737    <span class="xdoc">     *       acct1.username = "user1";  
</span>   738    <span class="xdoc">     *       acct1.password = "user1pass";  
</span>   739    <span class="xdoc">     *  
</span>   740    <span class="xdoc">     *       addUserAccount(acct1);
</span>   741    <span class="xdoc">     *
</span>   742    <span class="xdoc">     *  <b>@param(account)</b> structure of type Account
</span>   743    <span class="xdoc">     */</span>
   744        <span class=key>metaonly</span> Void addUserAccount(Account account);
   745    }
   746    
</pre>
</body></html>
