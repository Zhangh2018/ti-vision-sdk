/*==========================================================================*/
/*      Copyright (C) 2009-2013 Texas Instruments Incorporated.             */
/*                      All Rights Reserved                                 */
/*==========================================================================*/
/*                                                                          */
/* NAME:                                                                    */
/*     vcop_nonMaxSuppress_mxn_16s_kernel                                   */
/*                                                                          */
/* USAGE:                                                                   */
/*     This routine is C-callable and can be called as:                     */
/*                                                                          */
/*     void vcop_nonMaxSuppress_mxn_16s                                     */
/*     (                                                                    */
/*         __vptr_uint16 im_A,                                              */
/*         __vptr_uint8  out_B,                                             */
/*         __vptr_uint16 scratch_B,                                         */
/*         __vptr_uint16 scratch_C,                                         */
/*         int           height,                                            */
/*         int           width,                                             */
/*         int           m,                                                 */
/*         int           n,                                                 */
/*         short         thresh                                             */
/*     )                                                                    */
/*                                                                          */
/*     im_A       :  16-bit input image. This buffer should contain         */
/*                   height*width half-words.                               */
/*     out_B      :  8-bit binary output image. The buffer width should be  */
/*                   equal to 'width' bytes and height should be atleast    */
/*                   2*ceil((height-m+1)/2). Valid output will be present   */
/*                   at the first (height-m+1) rows and first (width-n+1)   */
/*                   columns.                                               */
/*     scratch_B  :  Scratch buffer 1. User need to allocate at least       */
/*                   2*(height-m+1)*width + 32 bytes for scratch_B.         */
/*     scratch_C  :  Scratch buffer 2. User need to allocate at least       */
/*                   4*ceil((height-m+1)/2)*width bytes for scratch_C.      */
/*     height     :  Height of the input image.                             */
/*     width      :  Width of the input image. This should be a multiple    */
/*                   of 8.                                                  */
/*     m          :  Height of the NMS window.                              */
/*     n          :  Width of the NMS window.                               */
/*     thresh     :  Threshold for pruning peaks.                           */
/*                                                                          */
/*     Returns :  None or void.                                             */
/*                                                                          */
/* DESCRIPTION:                                                             */
/*             This routine accepts an 16-bit input image and outputs non-  */
/*     maxima suppressed image using an mxn window. The recomended memory   */
/*     bank for each of the buffers is captured as A/B/C as part of the     */
/*     buffer pointer. A/B/C can either be IMBUF High, IMBUF low or WMEM.   */
/*     Further out_B and scratch_B can safely overlap without causing data  */
/*     corruption.                                                          */
/*             The kernel assumes that the NMS window is centered at        */
/*     [floor((m-1)/2), floor((n-1)/2)]. The NMS output starts at the       */
/*     top-left pixel in the output buffer. User is expected to take care   */
/*     of the resulting pixel shift in the output.                          */
/*                                                                          */
/* PERFORMANCE MEASUREMENT:                                                 */
/*             For an input block of width = 32, height = 32 and an NMS     */
/*     window of width = 3 and height = 7, the kernel took 842 VCOP cycles  */
/*     on CentEVE platform.                                                 */
/*                                                                          */
/* AUTHOR:                                                                  */
/*             Anoop K P(a-kp@ti.com)                                       */
/*                                                                          */
/* VERSION:                                                                 */
/*            1.0 (March 2013) : Base version.                              */
/*                                                                          */
/*==========================================================================*/
#if VCOP_HOST_EMULATION
#include <vcop.h>
#endif

#define ELEMSZ          sizeof(*im_A)
#define ELEMSZ1         sizeof(*out_B)
#define VECTORSZ        (VCOP_SIMD_WIDTH*ELEMSZ)
#define VECTORSZ1       (VCOP_SIMD_WIDTH*ELEMSZ1)

#define   VCOP_2SIMD_WIDTH   (2 * VCOP_SIMD_WIDTH)

#define ALIGN_SIMD(a)   (((a) + VCOP_SIMD_WIDTH-1) & ~(VCOP_SIMD_WIDTH-1))
#define ALIGN_2SIMD(a)   (((a) + VCOP_2SIMD_WIDTH-1) & ~(VCOP_2SIMD_WIDTH-1))


void vcop_nonMaxSuppress_mxn_16s
(
    __vptr_uint16 im_A,
    __vptr_uint8  out_B,
    __vptr_uint16 scratch_B,
    __vptr_uint16 scratch_C,
    unsigned short height,
    unsigned short width,
    unsigned short input_stride,
    unsigned short output_stride,
    unsigned short m,
    unsigned short n,
    short         thresh
)
{
  __vector K0   ;
  __vector K0p  ;
  __vector maxs ;
  __vector maxsp;
  __vector R0   ;
  __vector R1   ;
  __vector I0  ;
  __vector I1  ;
  __vector max0;
  __vector max1;
  __vector Rthr   ;
  __vector K255   ;
  __vector Ieqmax0;
  __vector Ieqmax1;
  __vector Igtthr0;
  __vector Igtthr1;
  __vector C0     ;
  __vector C1     ;

    K0 = 0;
    K0p = 0;
    for (int i = 0; i < height-m+1; i++)
    {
        for (int j = 0; j < ALIGN_2SIMD(width)/ VCOP_2SIMD_WIDTH; j++)
        {
            __agen Addr1, Addr2,Addr3;
            Addr1 = i * width * ELEMSZ + j * VECTORSZ * 2;
            Addr2 = i*output_stride*ELEMSZ1 + j*VECTORSZ1*2;
            Addr3 = i * input_stride * ELEMSZ + j * VECTORSZ * 2;

            (maxs,maxsp) = (im_A)[Addr3].deinterleave();

            for (int k = 0; k < (m-1); k++)
            {
                __agen Addr0;
                Addr0 = i*input_stride*ELEMSZ + j*VECTORSZ*2 + k*input_stride*ELEMSZ;

                (R0,R1) = (im_A + input_stride*ELEMSZ)[Addr0].deinterleave();

                maxs  = max(R0, maxs);
                maxsp = max(R1, maxsp);
            }

            scratch_B[Addr1].interleave() = (maxs,maxsp);
            out_B[Addr2].interleave() = (K0, K0p);
        }
    }

    for (int i = 0; i < (height-m+2)/2; i++)
    {
        for (int j = 0; j < ALIGN_SIMD(width - m + 1) / VCOP_SIMD_WIDTH; j++)
        {
            __agen Addr1, Addr2;
            Addr1 = i * ELEMSZ * width * 2 + j * VECTORSZ;
            Addr2 = i * ELEMSZ * width * 2 + j * VECTORSZ;

            max0 = (scratch_B)[Addr1];
            max1 = (scratch_B + ELEMSZ * width)[Addr1];

            for (int k = 0; k < (n-1); k++)
            {
                __agen Addr0;
                Addr0 = i * ELEMSZ * width * 2 + j * VECTORSZ + k * ELEMSZ;

                I0 = (scratch_B + ELEMSZ)[Addr0];
                I1 = (scratch_B + ELEMSZ * width + ELEMSZ)[Addr0];

                max0 = max(I0, max0);
                max1 = max(I1, max1);
            }

            scratch_C[Addr2] = max0;
            (scratch_C+ ELEMSZ * width)[Addr2] = max1;
         }
    }

    Rthr = thresh;
    K255 = 255;
    for (int i = 0; i < (height-m+2)/2; i++)
    {
        for (int j = 0; j < ALIGN_SIMD(width - m + 1) / VCOP_SIMD_WIDTH; j++)
        {
            __agen Addr1, Addr2, Addr3;

            Addr1 = i * 2 * width * ELEMSZ + j*VECTORSZ;
            Addr2 = i*2*output_stride*ELEMSZ1 + j*VECTORSZ1;
            Addr3 = i * 2 * input_stride * ELEMSZ  + j * VECTORSZ;

            I0 = (im_A+((m-1)/2)*input_stride*ELEMSZ+((n-1)/2)*ELEMSZ)[Addr3];
            I1 = (im_A+((m-1)/2)*input_stride*ELEMSZ+((n-1)/2)*ELEMSZ + input_stride*ELEMSZ)[Addr3];

            max0 = scratch_C[Addr1];
            max1 = (scratch_C + width * ELEMSZ)[Addr1];

            Ieqmax0 = (I0 == max0);
            Ieqmax1 = (I1 == max1);

            Igtthr0 = (I0 > Rthr);
            Igtthr1 = (I1 > Rthr);

            C0 = Ieqmax0 & Igtthr0;
            C1 = Ieqmax1 & Igtthr1;

            out_B[Addr2] = K255.predicate(C0);
            (out_B + output_stride*ELEMSZ1)[Addr2] = K255.predicate(C1);
        }
    }
}




#define VECTORSZ_BITIMAGE       (ELEMSZ1)



/* ==================================================
 *  @kernel     vcop_nonMaxSuppress_mxn_16sbitPack
 *
 *  @desc     This kernel nms of the given input data and outputs the data in packed format
 *
 *  @inputs   This kernel takes following Inputs
 *                  im_A :
 *                          Pointer to the input image buffer
 *                  width :
 *                          Width of the input block
 *                  height :
 *                          Height of the input block
 *                  input_stride :
 *                          Stride of the input block
 *                  output_stride :
 *                          Stride of the output block
 *                  windowWidth :
 *                          Window width for NMS
 *                  windowHeight :
 *                          Window Height for NMS
 *                  thresh :
 *                          Threshold to be used with NMS
 *
 *  @scratch   This kernel needs  following scratch buffers
 *                  scratch_B :
 *                          This is pointer  to an intermediate scratch buffer which contains maximum values
 *                           calculated in vertical direction. Size of this buffer should be (ALIGN_2SIMD(width) * height * sizeof(uint16_t))
 *                  scratch_C :
 *                          This is pointer  to an intermediate scratch buffer which contains maximum values
 *                          calculated in horizontal direction. Size of this buffer should be (ALIGN_SIMD(width - windowWidth + 1) *
 *                           height * sizeof(uint16_t))
 *
 *  @outputs   This kernel produce following outputs
 *                  out_B :
 *                          Pointer to the buffer which will store the binpacked output after NMS and thresholding
 *                          should be ALIGN_SIMD(width  - windowWidth + 1) * height * sizeof(uint16_t))
 *
 *  @remarks  Following is the buffer placement assumed for optimal performance of this kernel
 *                          im_A -> VCOP_IBUFLA
 *                          scratch_B -> VCOP_WMEM
 *                          scratch_C -> VCOP_IBUFHA
 *                          out_B -> VCOP_IBUFHA
 *
 *  @constraints Following constraints
 *                          width should be multiple of 8
 *                           height should be multiple of 2
 *
 *  @return    NONE
 *
 *  =======================================================
 */

void vcop_nonMaxSuppress_mxn_16sbitPack
(
    __vptr_int16  im_A,
    __vptr_uint8  out_B,
    __vptr_uint16 scratch_B,
    __vptr_uint16 scratch_C,
    unsigned short width,
    unsigned short height,
    unsigned short input_stride,
    unsigned short output_stride,
    unsigned short windowWidth,
    unsigned short windowHeight,
    short         thresh
)
{
    __vector maxs ;
    __vector maxsp;
    __vector R0   ;
    __vector R1   ;
    __vector I0  ;
    __vector I1  ;
    __vector max0;
    __vector max1;
    __vector Rthr   ;
    __vector Ieqmax0;
    __vector Ieqmax1;
    __vector Igtthr0;
    __vector Igtthr1;
    __vector C0     ;
    __vector C1     ;
    __vector K1     ;

    for (int i = 0; i < height- windowHeight + 1; i++)
    {
        for (int j = 0; j < ALIGN_2SIMD(width)/ VCOP_2SIMD_WIDTH; j++)
        {
            __agen addrOut, addrIn;

            addrIn  = i * input_stride * ELEMSZ + j * VECTORSZ * 2;
            addrOut = i * width * ELEMSZ + j * VECTORSZ * 2;

            (maxs,maxsp) = (im_A)[addrIn].deinterleave();

            /* Now find the maximum of all the elements in vertical direction for window Height*/
            for (int k = 0; k < (windowHeight -1); k++)
            {
                __agen Addr0;
                Addr0 = i * input_stride * ELEMSZ + j*VECTORSZ*2 + k*input_stride*ELEMSZ;

                (R0,R1) = (im_A + input_stride*ELEMSZ)[Addr0].deinterleave();

                maxs  = max(R0, maxs);
                maxsp = max(R1, maxsp);
            }

            scratch_B[addrOut].interleave() = (maxs,maxsp);
        }
    }

    for (int i = 0; i < (height - windowHeight + 2)/2; i++)
    {
        for (int j = 0; j < ALIGN_SIMD(width - windowWidth + 1) / VCOP_SIMD_WIDTH; j++)
        {
            __agen addrInOut;
            /* Multiplication by 2 in i direction because we are working with two rows at a time */
            addrInOut = i * ELEMSZ * width * 2 + j * VECTORSZ;

            max0 = (scratch_B)[addrInOut];
            max1 = (scratch_B + ELEMSZ * width)[addrInOut];

            for (int k = 0; k < (windowWidth - 1); k++)
            {
                __agen Addr0;
                Addr0 = i * ELEMSZ * width * 2 + j * VECTORSZ + k * ELEMSZ;

                I0 = (scratch_B + ELEMSZ)[Addr0];
                I1 = (scratch_B + ELEMSZ * width  + ELEMSZ)[Addr0];

                max0 = max(I0, max0);
                max1 = max(I1, max1);
            }

            scratch_C[addrInOut] = max0;
            (scratch_C + ELEMSZ * width)[addrInOut] = max1;
         }
    }

    Rthr = thresh;
    K1 = 1;

    for (int i = 0; i < (height - windowHeight +2)/2; i++)
    {
        for (int j = 0; j < ALIGN_SIMD(width - windowWidth + 1) / VCOP_SIMD_WIDTH; j++)
        {
            __agen addrInData, addrMaxVal, addrBinPack;
            __vector binaryMask1;
            __vector binaryMask2;

            addrInData = i * 2 * input_stride * ELEMSZ  + j * VECTORSZ;

            addrMaxVal = i * 2 * width * ELEMSZ + j*VECTORSZ;
            addrBinPack = i * 2 * output_stride * ELEMSZ1 + j * VECTORSZ_BITIMAGE;


            I0 = (im_A+((windowHeight-1)/2)*input_stride*ELEMSZ+((windowWidth-1)/2)*ELEMSZ)[addrInData];
            I1 = (im_A+((windowHeight-1)/2)*input_stride*ELEMSZ+((windowWidth-1)/2)*ELEMSZ + input_stride*ELEMSZ)[addrInData];

            max0 = scratch_C[addrMaxVal];
            max1 = (scratch_C + width * ELEMSZ)[addrMaxVal];

            Ieqmax0 = (I0 == max0);
            Ieqmax1 = (I1 == max1);

            Igtthr0 = (I0 > Rthr);
            Igtthr1 = (I1 > Rthr);

            C0 = Ieqmax0 & Igtthr0;
            C1 = Ieqmax1 & Igtthr1;

            binaryMask1 = pack(C0 >= K1);
            binaryMask2 = pack(C1 >= K1);
            out_B[addrBinPack].onept() = binaryMask1;
            (out_B + output_stride*ELEMSZ1)[addrBinPack].onept() = binaryMask2;
        }
    }
}


/* ==================================================
 *  @kernel     vcop_nonMaxSuppress_mxn_16sUpdateDstPtr
 *
 *  @desc     This kernel updates the param block of the destination pointer for NMS
 *
 *  @inputs   This kernel takes following Inputs
 *                  pBlock :
 *                          Pointer to the param block whose entries needs to be updated
 *                  pDstPtr1 :
 *                          Address of the destination1 which need to be updated
 *                  pDstPtr2 :
 *                          Address of the destination2 which need to be updated
 *                  pDstPtrOffset :
 *                          Offset that needs to be added to destination1 and destination2
 *                  nmsBinPackPrmBlockOffset1 :
 *                          Offset in pBlock where pDstPtr1 is stored
 *                  nmsBinPackPrmBlockOffset2 :
 *                          Offset in pBlock where pDstPtr2 is stored
 *
 *  @scratch   This kernel needs  following scratch buffers
 *                  NONE
 *
 *  @return    NONE
 *
 *  =======================================================
 */
void vcop_nonMaxSuppress_mxn_16sUpdateDstPtr(
      __vptr_uint32 pBlock,
      unsigned int  pDstPtr1,
      unsigned int  pDstPtr2,
      __vptr_uint16 pDstPtrOffset,
      unsigned short nmsBinPackPrmBlockOffset1,
      unsigned short nmsBinPackPrmBlockOffset2)
{

    __agen Addr0;
    __vector vNumElmts;
    __vector vDstPtr1, vDstPtr2;

  Addr0        = 0;
  vDstPtr1      = pDstPtr1;
  vDstPtr2      = pDstPtr2;

  vNumElmts= pDstPtrOffset[Addr0].onept();

  for (int i=0; i<1; i++)
  {
      vDstPtr1 += vNumElmts;
      vDstPtr2 += vNumElmts;

      (pBlock + nmsBinPackPrmBlockOffset1*sizeof(*pBlock))[Addr0].onept()= vDstPtr1;
      (pBlock + nmsBinPackPrmBlockOffset2*sizeof(*pBlock))[Addr0].onept()= vDstPtr2;
  }
}

