
#define WR_MEM_32(addr, data)    *(unsigned int*)(addr) =(unsigned int)(data)
#define RD_MEM_32(addr)          *(unsigned int*)(addr)
#define UWORD32                  unsigned int

/***************************************************************************************************************
                        DM8148 REGISTER MAP DEFINES
***************************************************************************************************************/

#define PRCM_BASE_ADDR              (0x48180000)
#define DMM_BASE_ADDR               (0x4E000000)
#define EMIF4_0_CFG_BASE_ADDR       (0x4C000000)
#define EMIF4_1_CFG_BASE_ADDR       (0x4D000000)
#define GPMC_MEM_BASE_ADDR          (0x02000000)
#define DDR_MEM_BASE_ADDR           (0x80000000)
#define DUCATI_BASE_ADDR            (0x55020000)
#define DUCATI_MMU_CFG              (0x55080000)
#define CTRL_MODULE_BASE_ADDR       (0x48140000)
#define C674x_L2RAM_BASE_ADDR       (0x40800000)

/* Control Module */
#define DSPBOOTADDR             (CTRL_MODULE_BASE_ADDR + 0x0048)
#define GMII_SEL                (CTRL_MODULE_BASE_ADDR + 0x0650)


/* PRCM */
#define CM_CLKOUT_CTRL              (PRCM_BASE_ADDR + 0x0100)
#define CM_CTRL_CLKCTRL             (PRCM_BASE_ADDR + 0x15C4)
#define CM_ALWON_L3_SLOW_CLKSTCTRL  (PRCM_BASE_ADDR + 0x1400)

/* GMAC_SW */
#define CM_ALWON_ETHERNET_CLKSTCTRL (PRCM_BASE_ADDR + 0x1404)
#define CM_ALWON_ETHERNET_0_CLKCTRL (PRCM_BASE_ADDR + 0x15D4)
#define CM_ALWON_ETHERNET_1_CLKCTRL (PRCM_BASE_ADDR + 0x15D8)

/* UART */
#define CM_ALWON_UART_0_CLKCTRL     (PRCM_BASE_ADDR + 0x1550)
#define CM_ALWON_UART_1_CLKCTRL     (PRCM_BASE_ADDR + 0x1554)
#define CM_ALWON_UART_2_CLKCTRL     (PRCM_BASE_ADDR + 0x1558)
#define CM_DEFAULT_DUCATI_CLKSTCTRL (PRCM_BASE_ADDR + 0x0518)
#define CM_DEFAULT_DUCATI_CLKCTRL   (PRCM_BASE_ADDR + 0x0574)
#define RM_DEFAULT_RSTCTRL          (PRCM_BASE_ADDR + 0x0B10)
#define RM_DEFAULT_RSTST            (PRCM_BASE_ADDR + 0x0B14)
#define CM_ALWON_OCMC_0_CLKSTCTRL   (PRCM_BASE_ADDR + 0x1414)
#define CM_ALWON_OCMC_0_CLKCTRL     (PRCM_BASE_ADDR + 0x15B4)
#define CM_ALWON_GPMC_CLKCTRL       (PRCM_BASE_ADDR + 0x15D0)


/* McASP2 PRCM definitions */
#define CM_ALWON_MCA_0_CLKSTCTRL        (PRCM_BASE_ADDR + 0x1540)
#define CM_ALWON_MCA_1_CLKSTCTRL        (PRCM_BASE_ADDR + 0x1544)
#define CM_ALWON_MCA_2_CLKSTCTRL        (PRCM_BASE_ADDR + 0x1548)
#define CM_ALWON_I2C_0_CLKSTCTRL        (PRCM_BASE_ADDR + 0x1564)
#define CM_ALWON_I2C_1_CLKSTCTRL        (PRCM_BASE_ADDR + 0x1568)
#define CM_ALWON_MCA_345_CLKSTCTL       (PRCM_BASE_ADDR + 0x156C)
#define CM_ALWON_SPI_0_CLKSTCTRL        (PRCM_BASE_ADDR + 0x1590)
#define CM_ALWON_MMC_HS_0_CLKSTCTRL        (PRCM_BASE_ADDR + 0x161C)
#define CM_ALWON_MMC_HS_1_CLKSTCTRL        (PRCM_BASE_ADDR + 0x1620)
#define CM_ALWON_DCAN_0_CLKCTRL         (PRCM_BASE_ADDR + 0x1618)

/*HDVICP PRCM Definition*/
#define CM_HDVICP_CLKSTCTRL         (PRCM_BASE_ADDR + 0x0600)
#define CM_HDVICP_CLKCTRL           (PRCM_BASE_ADDR + 0x0620)
#define CM_HDVICP_SL2_CLKCTRL       (PRCM_BASE_ADDR + 0x0624)
#define PM_HDVICP_PWRSTST           (PRCM_BASE_ADDR + 0x0C04)
#define RM_HDVICP_RSTCTRL           (PRCM_BASE_ADDR + 0x0C10)
#define RM_HDVICP_RSTST             (PRCM_BASE_ADDR + 0x0C14)
/*END OF HDVICP PRCM Definition*/


/*C674x PRCM definition*/
#define CM_C674x_CLKSTCTRL          (PRCM_BASE_ADDR + 0x0400)
#define CM_ACTIVE_C674x_CLKCTRL     (PRCM_BASE_ADDR + 0x0420)
#define PM_ACTIVE_PWRSTST           (PRCM_BASE_ADDR + 0x0A04)
#define RM_ACTIVE_RSTCTRL           (PRCM_BASE_ADDR + 0x0A10)
#define RM_ACTIVE_RSTST             (PRCM_BASE_ADDR + 0x0A14)

#define CM_MMU_CLKSTCTRL            (PRCM_BASE_ADDR + 0x140C)
#define CM_ALWON_MMUDATA_CLKCTRL    (PRCM_BASE_ADDR + 0x159C)

#define CM_MMUCFG_CLKSTCTRL         (PRCM_BASE_ADDR + 0x1410)
#define CM_ALWON_MMUCFG_CLKCTRL     (PRCM_BASE_ADDR + 0x15A8)
/*END OF C674x PRCM Definition*/

//Control Module Always on ClockControl
#define CM_ALWON_L3_SLOW_CLKSTCTRL      (PRCM_BASE_ADDR + 0x1400)
#define CM_ALWON_TIMER_0_CLKCTRL        (PRCM_BASE_ADDR + 0x156C)
#define CM_ALWON_TIMER_1_CLKCTRL        (PRCM_BASE_ADDR + 0x1570)
#define CM_ALWON_TIMER_2_CLKCTRL        (PRCM_BASE_ADDR + 0x1574)
#define CM_ALWON_TIMER_3_CLKCTRL        (PRCM_BASE_ADDR + 0x1578)
#define CM_ALWON_TIMER_4_CLKCTRL        (PRCM_BASE_ADDR + 0x157C)
#define CM_ALWON_TIMER_5_CLKCTRL        (PRCM_BASE_ADDR + 0x1580)
#define CM_ALWON_TIMER_6_CLKCTRL        (PRCM_BASE_ADDR + 0x1584)
#define CM_ALWON_TIMER_7_CLKCTRL        (PRCM_BASE_ADDR + 0x1588)
#define CM_ALWON_SYSCLK5_CLKSTCTRL      (PRCM_BASE_ADDR + 0x1424)
#define CM_ALWON_DCAN_0_1_CLKCTRL       (PRCM_BASE_ADDR + 0x1618)

#define CM_TIMER0_CLKSEL                (PRCM_BASE_ADDR + 0x038C)
#define CM_TIMER1_CLKSEL                (PRCM_BASE_ADDR + 0x0390)
#define CM_TIMER2_CLKSEL                (PRCM_BASE_ADDR + 0x0394)
#define CM_TIMER3_CLKSEL                (PRCM_BASE_ADDR + 0x0398)
#define CM_TIMER4_CLKSEL                (PRCM_BASE_ADDR + 0x039C)
#define CM_TIMER5_CLKSEL                (PRCM_BASE_ADDR + 0x03A0)
#define CM_TIMER6_CLKSEL                (PRCM_BASE_ADDR + 0x03A4)
#define CM_TIMER7_CLKSEL                (PRCM_BASE_ADDR + 0x03A8)



//#define SIZE 0x8000
//#define DATA_SIZE 10
#define OCMC0RAM_BASE_ADDR              0x40300000
#define OCMC1RAM_BASE_ADDR              0x40400000

#define DMTIMER0_BASE_ADDR              0x4802C000
#define DMTIMER1_BASE_ADDR              0x4802E000

#define DMTIMER2_BASE_ADDR              0x48040000
#define DMTIMER3_BASE_ADDR              0x48042000
#define DMTIMER4_BASE_ADDR              0x48044000
#define DMTIMER5_BASE_ADDR              0x48046000
#define DMTIMER6_BASE_ADDR              0x48048000
#define DMTIMER7_BASE_ADDR              0x4804A000

/*****************************************************************************/
/*EMIF4 PRCM Defintion*/
#define CM_DEFAULT_L3_FAST_CLKSTCTRL    (PRCM_BASE_ADDR + 0x0508)
#define CM_DEFAULT_EMIF_0_CLKCTRL       (PRCM_BASE_ADDR + 0x0520)
#define CM_DEFAULT_EMIF_1_CLKCTRL       (PRCM_BASE_ADDR + 0x0524)
#define CM_DEFAULT_DMM_CLKCTRL          (PRCM_BASE_ADDR + 0x0528)
#define CM_DEFAULT_FW_CLKCTRL           (PRCM_BASE_ADDR + 0x052C)
/*end of EMIF4 PRCM definition*/

#define    DDR0_PHY_BASE_ADDR           0x47C0C400
#define    DDR1_PHY_BASE_ADDR           0x47C0C800
#define    DDR0_IO_CTRL                 0x48140E04
#define    DDR1_IO_CTRL                 0x48140E08
#define    VTP0_CTRL_REG                0x48140E0C
#define    VTP1_CTRL_REG                0x48140E10
#define    EMIF4_0_CFG_BASE_ADDR        0x4C000000
#define    EMIF4_1_CFG_BASE_ADDR        0x4D000000
#define    DMM_BASE_ADDR                0x4E000000

//-DMM & EMIF4 MMR Declaration
#define DMM_LISA_MAP__0                 (DMM_BASE_ADDR + 0x40)
#define DMM_LISA_MAP__1                 (DMM_BASE_ADDR + 0x44)
#define DMM_LISA_MAP__2                 (DMM_BASE_ADDR + 0x48)
#define DMM_LISA_MAP__3                 (DMM_BASE_ADDR + 0x4C)
#define DMM_PAT_BASE_ADDR               (DMM_BASE_ADDR + 0x460)

#define EMIF4_0_SDRAM_CONFIG            (EMIF4_0_CFG_BASE_ADDR + 0x08)
#define EMIF4_0_SDRAM_CONFIG2           (EMIF4_0_CFG_BASE_ADDR + 0x0C)
#define EMIF4_0_SDRAM_REF_CTRL          (EMIF4_0_CFG_BASE_ADDR + 0x10)
#define EMIF4_0_SDRAM_REF_CTRL_SHADOW   (EMIF4_0_CFG_BASE_ADDR + 0x14)
#define EMIF4_0_SDRAM_TIM_1             (EMIF4_0_CFG_BASE_ADDR + 0x18)
#define EMIF4_0_SDRAM_TIM_1_SHADOW      (EMIF4_0_CFG_BASE_ADDR + 0x1C)
#define EMIF4_0_SDRAM_TIM_2             (EMIF4_0_CFG_BASE_ADDR + 0x20)
#define EMIF4_0_SDRAM_TIM_2_SHADOW      (EMIF4_0_CFG_BASE_ADDR + 0x24)
#define EMIF4_0_SDRAM_TIM_3             (EMIF4_0_CFG_BASE_ADDR + 0x28)
#define EMIF4_0_SDRAM_TIM_3_SHADOW      (EMIF4_0_CFG_BASE_ADDR + 0x2C)
#define EMIF4_0_DDR_PHY_CTRL_1          (EMIF4_0_CFG_BASE_ADDR + 0xE4)
#define EMIF4_0_DDR_PHY_CTRL_1_SHADOW   (EMIF4_0_CFG_BASE_ADDR + 0xE8)
#define EMIF4_0_SDRAM_ZQCR                    (EMIF4_0_CFG_BASE_ADDR + 0xC8)
#define EMIF4_0_RDWR_LVL_RMP_CTRL        (EMIF4_0_CFG_BASE_ADDR + 0xD8)
#define EMIF4_0_RDWR_LVL_CTRL            (EMIF4_0_CFG_BASE_ADDR + 0xDC)


#define EMIF4_1_SDRAM_CONFIG            (EMIF4_1_CFG_BASE_ADDR + 0x08)
#define EMIF4_1_SDRAM_CONFIG2            (EMIF4_1_CFG_BASE_ADDR + 0x0C)
#define EMIF4_1_SDRAM_REF_CTRL            (EMIF4_1_CFG_BASE_ADDR + 0x10)
#define EMIF4_1_SDRAM_REF_CTRL_SHADOW        (EMIF4_1_CFG_BASE_ADDR + 0x14)
#define EMIF4_1_SDRAM_TIM_1            (EMIF4_1_CFG_BASE_ADDR + 0x18)
#define EMIF4_1_SDRAM_TIM_1_SHADOW        (EMIF4_1_CFG_BASE_ADDR + 0x1C)
#define EMIF4_1_SDRAM_TIM_2            (EMIF4_1_CFG_BASE_ADDR + 0x20)
#define EMIF4_1_SDRAM_TIM_2_SHADOW        (EMIF4_1_CFG_BASE_ADDR + 0x24)
#define EMIF4_1_SDRAM_TIM_3            (EMIF4_1_CFG_BASE_ADDR + 0x28)
#define EMIF4_1_SDRAM_TIM_3_SHADOW        (EMIF4_1_CFG_BASE_ADDR + 0x2C)
#define EMIF4_1_DDR_PHY_CTRL_1            (EMIF4_1_CFG_BASE_ADDR + 0xE4)
#define EMIF4_1_DDR_PHY_CTRL_1_SHADOW        (EMIF4_1_CFG_BASE_ADDR + 0xE8)
#define EMIF4_1_SDRAM_ZQCR                    (EMIF4_1_CFG_BASE_ADDR + 0xC8)
#define EMIF4_1_RDWR_LVL_RMP_CTRL        (EMIF4_1_CFG_BASE_ADDR + 0xD8)
#define EMIF4_1_RDWR_LVL_CTRL            (EMIF4_1_CFG_BASE_ADDR + 0xDC)




//- DDR0 Phy MMRs
#define     CMD0_REG_PHY0_CTRL_SLAVE_RATIO_0 (0x01C + DDR0_PHY_BASE_ADDR)
#define     CMD0_REG_PHY0_DLL_LOCK_DIFF_0    (0x028 + DDR0_PHY_BASE_ADDR)
#define     CMD0_REG_PHY0_INVERT_CLKOUT_0    (0x02C + DDR0_PHY_BASE_ADDR)
#define     CMD1_REG_PHY0_CTRL_SLAVE_RATIO_0 (0x050 + DDR0_PHY_BASE_ADDR)
#define     CMD1_REG_PHY0_DLL_LOCK_DIFF_0    (0x05C + DDR0_PHY_BASE_ADDR)
#define     CMD1_REG_PHY0_INVERT_CLKOUT_0    (0x060 + DDR0_PHY_BASE_ADDR)
#define     CMD2_REG_PHY0_CTRL_SLAVE_RATIO_0 (0x084 + DDR0_PHY_BASE_ADDR)
#define     CMD2_REG_PHY0_DLL_LOCK_DIFF_0    (0x090 + DDR0_PHY_BASE_ADDR)
#define     CMD2_REG_PHY0_INVERT_CLKOUT_0    (0x094 + DDR0_PHY_BASE_ADDR)

#define     DATA0_REG_PHY0_RD_DQS_SLAVE_RATIO_0  (0x0C8 + DDR0_PHY_BASE_ADDR)
#define     DATA0_REG_PHY0_WR_DQS_SLAVE_RATIO_0  (0x0DC + DDR0_PHY_BASE_ADDR)
#define     DATA0_REG_PHY0_WRLVL_INIT_RATIO_0    (0x0F0 + DDR0_PHY_BASE_ADDR)
#define     DATA0_REG_PHY0_WRLVL_INIT_MODE_0     (0x0F8 + DDR0_PHY_BASE_ADDR)
#define     DATA0_REG_PHY0_GATELVL_INIT_RATIO_0  (0x0FC + DDR0_PHY_BASE_ADDR)
#define     DATA0_REG_PHY0_GATELVL_INIT_MODE_0   (0x104 + DDR0_PHY_BASE_ADDR)
#define     DATA0_REG_PHY0_FIFO_WE_SLAVE_RATIO_0 (0x108 + DDR0_PHY_BASE_ADDR)
#define     DATA0_REG_PHY0_WR_DATA_SLAVE_RATIO_0 (0x120 + DDR0_PHY_BASE_ADDR)
#define     DATA0_REG_PHY0_USE_RANK0_DELAYS      (0x134 + DDR0_PHY_BASE_ADDR)
#define     DATA0_REG_PHY0_DLL_LOCK_DIFF_0       (0x138 + DDR0_PHY_BASE_ADDR)

#define     DATA1_REG_PHY0_RD_DQS_SLAVE_RATIO_0  (0x16C + DDR0_PHY_BASE_ADDR)
#define     DATA1_REG_PHY0_WR_DQS_SLAVE_RATIO_0  (0x180 + DDR0_PHY_BASE_ADDR)
#define     DATA1_REG_PHY0_WRLVL_INIT_RATIO_0    (0x194 + DDR0_PHY_BASE_ADDR)
#define     DATA1_REG_PHY0_WRLVL_INIT_MODE_0     (0x19C + DDR0_PHY_BASE_ADDR)
#define     DATA1_REG_PHY0_GATELVL_INIT_RATIO_0  (0x1A0 + DDR0_PHY_BASE_ADDR)
#define     DATA1_REG_PHY0_GATELVL_INIT_MODE_0   (0x1A8 + DDR0_PHY_BASE_ADDR)
#define     DATA1_REG_PHY0_FIFO_WE_SLAVE_RATIO_0 (0x1AC + DDR0_PHY_BASE_ADDR)
#define     DATA1_REG_PHY0_WR_DATA_SLAVE_RATIO_0 (0x1C4 + DDR0_PHY_BASE_ADDR)
#define     DATA1_REG_PHY0_USE_RANK0_DELAYS      (0x1D8 + DDR0_PHY_BASE_ADDR)
#define     DATA1_REG_PHY0_DLL_LOCK_DIFF_0       (0x1DC + DDR0_PHY_BASE_ADDR)

#define     DATA2_REG_PHY0_RD_DQS_SLAVE_RATIO_0  (0x210 + DDR0_PHY_BASE_ADDR)
#define     DATA2_REG_PHY0_WR_DQS_SLAVE_RATIO_0  (0x224 + DDR0_PHY_BASE_ADDR)
#define     DATA2_REG_PHY0_WRLVL_INIT_RATIO_0    (0x238 + DDR0_PHY_BASE_ADDR)
#define     DATA2_REG_PHY0_WRLVL_INIT_MODE_0     (0x240 + DDR0_PHY_BASE_ADDR)
#define     DATA2_REG_PHY0_GATELVL_INIT_RATIO_0  (0x244 + DDR0_PHY_BASE_ADDR)
#define     DATA2_REG_PHY0_GATELVL_INIT_MODE_0   (0x24C + DDR0_PHY_BASE_ADDR)
#define     DATA2_REG_PHY0_FIFO_WE_SLAVE_RATIO_0 (0x250 + DDR0_PHY_BASE_ADDR)
#define     DATA2_REG_PHY0_WR_DATA_SLAVE_RATIO_0 (0x268 + DDR0_PHY_BASE_ADDR)
#define     DATA2_REG_PHY0_USE_RANK0_DELAYS      (0x27C + DDR0_PHY_BASE_ADDR)
#define     DATA2_REG_PHY0_DLL_LOCK_DIFF_0       (0x280 + DDR0_PHY_BASE_ADDR)

#define     DATA3_REG_PHY0_RD_DQS_SLAVE_RATIO_0  (0x2B4 + DDR0_PHY_BASE_ADDR)
#define     DATA3_REG_PHY0_WR_DQS_SLAVE_RATIO_0  (0x2C8 + DDR0_PHY_BASE_ADDR)
#define     DATA3_REG_PHY0_WRLVL_INIT_RATIO_0    (0x2DC + DDR0_PHY_BASE_ADDR)
#define     DATA3_REG_PHY0_WRLVL_INIT_MODE_0     (0x2E4 + DDR0_PHY_BASE_ADDR)
#define     DATA3_REG_PHY0_GATELVL_INIT_RATIO_0  (0x2E8 + DDR0_PHY_BASE_ADDR)
#define     DATA3_REG_PHY0_GATELVL_INIT_MODE_0   (0x2F0 + DDR0_PHY_BASE_ADDR)
#define     DATA3_REG_PHY0_FIFO_WE_SLAVE_RATIO_0 (0x2F4 + DDR0_PHY_BASE_ADDR)
#define     DATA3_REG_PHY0_WR_DATA_SLAVE_RATIO_0 (0x30C + DDR0_PHY_BASE_ADDR)
#define     DATA3_REG_PHY0_USE_RANK0_DELAYS      (0x320 + DDR0_PHY_BASE_ADDR)
#define     DATA3_REG_PHY0_DLL_LOCK_DIFF_0       (0x324 + DDR0_PHY_BASE_ADDR)


//- DDR1 Phy MMRs
#define     CMD0_REG_PHY1_CTRL_SLAVE_RATIO_0    (0x01C + DDR1_PHY_BASE_ADDR)
#define     CMD0_REG_PHY1_DLL_LOCK_DIFF_0       (0x028 + DDR1_PHY_BASE_ADDR)
#define     CMD0_REG_PHY1_INVERT_CLKOUT_0       (0x02C + DDR1_PHY_BASE_ADDR)
#define     CMD1_REG_PHY1_CTRL_SLAVE_RATIO_0    (0x050 + DDR1_PHY_BASE_ADDR)
#define     CMD1_REG_PHY1_DLL_LOCK_DIFF_0       (0x05C + DDR1_PHY_BASE_ADDR)
#define     CMD1_REG_PHY1_INVERT_CLKOUT_0       (0x060 + DDR1_PHY_BASE_ADDR)
#define     CMD2_REG_PHY1_CTRL_SLAVE_RATIO_0    (0x084 + DDR1_PHY_BASE_ADDR)
#define     CMD2_REG_PHY1_DLL_LOCK_DIFF_0       (0x090 + DDR1_PHY_BASE_ADDR)
#define     CMD2_REG_PHY1_INVERT_CLKOUT_0       (0x094 + DDR1_PHY_BASE_ADDR)

#define     DATA0_REG_PHY1_RD_DQS_SLAVE_RATIO_0    (0x0C8 + DDR1_PHY_BASE_ADDR)
#define     DATA0_REG_PHY1_WR_DQS_SLAVE_RATIO_0    (0x0DC + DDR1_PHY_BASE_ADDR)
#define     DATA0_REG_PHY1_WRLVL_INIT_RATIO_0    (0x0F0 + DDR1_PHY_BASE_ADDR)
#define     DATA0_REG_PHY1_WRLVL_INIT_MODE_0     (0x0F8 + DDR1_PHY_BASE_ADDR)
#define     DATA0_REG_PHY1_GATELVL_INIT_RATIO_0     (0x0FC + DDR1_PHY_BASE_ADDR)
#define     DATA0_REG_PHY1_GATELVL_INIT_MODE_0     (0x104 + DDR1_PHY_BASE_ADDR)
#define     DATA0_REG_PHY1_FIFO_WE_SLAVE_RATIO_0 (0x108 + DDR1_PHY_BASE_ADDR)
#define     DATA0_REG_PHY1_WR_DATA_SLAVE_RATIO_0 (0x120 + DDR1_PHY_BASE_ADDR)
#define     DATA0_REG_PHY1_USE_RANK0_DELAYS     (0x134 + DDR1_PHY_BASE_ADDR)
#define     DATA0_REG_PHY1_DLL_LOCK_DIFF_0     (0x138 + DDR1_PHY_BASE_ADDR)

#define     DATA1_REG_PHY1_RD_DQS_SLAVE_RATIO_0     (0x16C + DDR1_PHY_BASE_ADDR)
#define     DATA1_REG_PHY1_WR_DQS_SLAVE_RATIO_0     (0x180 + DDR1_PHY_BASE_ADDR)
#define     DATA1_REG_PHY1_WRLVL_INIT_RATIO_0     (0x194 + DDR1_PHY_BASE_ADDR)
#define     DATA1_REG_PHY1_WRLVL_INIT_MODE_0     (0x19C + DDR1_PHY_BASE_ADDR)
#define     DATA1_REG_PHY1_GATELVL_INIT_RATIO_0     (0x1A0 + DDR1_PHY_BASE_ADDR)
#define     DATA1_REG_PHY1_GATELVL_INIT_MODE_0     (0x1A8 + DDR1_PHY_BASE_ADDR)
#define     DATA1_REG_PHY1_FIFO_WE_SLAVE_RATIO_0 (0x1AC + DDR1_PHY_BASE_ADDR)
#define     DATA1_REG_PHY1_WR_DATA_SLAVE_RATIO_0 (0x1C4 + DDR1_PHY_BASE_ADDR)
#define     DATA1_REG_PHY1_USE_RANK0_DELAYS     (0x1D8 + DDR1_PHY_BASE_ADDR)
#define     DATA1_REG_PHY1_DLL_LOCK_DIFF_0     (0x1DC + DDR1_PHY_BASE_ADDR)

#define     DATA2_REG_PHY1_RD_DQS_SLAVE_RATIO_0     (0x210 + DDR1_PHY_BASE_ADDR)
#define     DATA2_REG_PHY1_WR_DQS_SLAVE_RATIO_0     (0x224 + DDR1_PHY_BASE_ADDR)
#define     DATA2_REG_PHY1_WRLVL_INIT_RATIO_0     (0x238 + DDR1_PHY_BASE_ADDR)
#define     DATA2_REG_PHY1_WRLVL_INIT_MODE_0     (0x240 + DDR1_PHY_BASE_ADDR)
#define     DATA2_REG_PHY1_GATELVL_INIT_RATIO_0     (0x244 + DDR1_PHY_BASE_ADDR)
#define     DATA2_REG_PHY1_GATELVL_INIT_MODE_0     (0x24C + DDR1_PHY_BASE_ADDR)
#define     DATA2_REG_PHY1_FIFO_WE_SLAVE_RATIO_0 (0x250 + DDR1_PHY_BASE_ADDR)
#define     DATA2_REG_PHY1_WR_DATA_SLAVE_RATIO_0 (0x268 + DDR1_PHY_BASE_ADDR)
#define     DATA2_REG_PHY1_USE_RANK0_DELAYS     (0x27C + DDR1_PHY_BASE_ADDR)
#define     DATA2_REG_PHY1_DLL_LOCK_DIFF_0     (0x280 + DDR1_PHY_BASE_ADDR)

#define     DATA3_REG_PHY1_RD_DQS_SLAVE_RATIO_0     (0x2B4 + DDR1_PHY_BASE_ADDR)
#define     DATA3_REG_PHY1_WR_DQS_SLAVE_RATIO_0     (0x2C8 + DDR1_PHY_BASE_ADDR)
#define     DATA3_REG_PHY1_WRLVL_INIT_RATIO_0     (0x2DC + DDR1_PHY_BASE_ADDR)
#define     DATA3_REG_PHY1_WRLVL_INIT_MODE_0     (0x2E4 + DDR1_PHY_BASE_ADDR)
#define     DATA3_REG_PHY1_GATELVL_INIT_RATIO_0     (0x2E8 + DDR1_PHY_BASE_ADDR)
#define     DATA3_REG_PHY1_GATELVL_INIT_MODE_0     (0x2F0 + DDR1_PHY_BASE_ADDR)
#define     DATA3_REG_PHY1_FIFO_WE_SLAVE_RATIO_0 (0x2F4 + DDR1_PHY_BASE_ADDR)
#define     DATA3_REG_PHY1_WR_DATA_SLAVE_RATIO_0 (0x30C + DDR1_PHY_BASE_ADDR)
#define     DATA3_REG_PHY1_USE_RANK0_DELAYS     (0x320 + DDR1_PHY_BASE_ADDR)
#define     DATA3_REG_PHY1_DLL_LOCK_DIFF_0     (0x324 + DDR1_PHY_BASE_ADDR)

#define     DATA_MACRO_0             0
#define     DATA_MACRO_1             1
#define     DATA_MACRO_2             2
#define     DATA_MACRO_3             3
#define     DDR_PHY0          0
#define     DDR_PHY1          1

#define     DDR_FREQ         800 // 333MHz

//- Common DDR PHY parameters
#define       PHY_INVERT_CLKOUT_DEFINE         0
#define       DDR3_PHY_INVERT_CLKOUT_ON     1
#define       DDR3_PHY_INVERT_CLKOUT_OFF     0

#define       PHY_REG_USE_RANK0_DELAY_DEFINE     0
#define       PHY_DLL_LOCK_DIFF_DEFINE             0x4
#define       PHY_CMD0_DLL_LOCK_DIFF_DEFINE    0x4

#define       PHY_GATELVL_INIT_CS0_DEFINE           0x0
#define       PHY_WRLVL_INIT_CS0_DEFINE         0x0

#define       PHY_GATELVL_INIT_CS1_DEFINE           0x0
#define       PHY_WRLVL_INIT_CS1_DEFINE         0x0
#define       PHY_CTRL_SLAVE_RATIO_CS1_DEFINE       0x80

//- DDR2 parameters

#define    DDR2_EMIF_READ_LATENCY_DEFINE    0x00173208

#define    DDR2_EMIF_TIM1_DEFINE            0x0888E4E2
#define    DDR2_EMIF_TIM2_DEFINE            0x202D31D2
#define    DDR2_EMIF_TIM3_DEFINE            0x500002AF
#define    DDR2_EMIF_REF_CTRL_DEFINE        0x00000A25
#define    DDR2_EMIF_SDRAM_CONFIG_DEFINE    0x41801832

#define       DDR2_PHY_RD_DQS_CS0_DEFINE    0x34 //- Calculated using ratio calculator
#define       DDR2_PHY_WR_DQS_CS0_DEFINE    0x10
#define       DDR2_PHY_FIFO_WE_CS0_DEFINE    0xA0
#define       DDR2_PHY_WR_DATA_CS0_DEFINE    0x50
#define       DDR2_PHY_CTRL_SLAVE_RATIO_CS0_DEFINE       0x80

//- DDR3 parameters

#define    DDR3_EMIF_REF_CTRL_DEFINE1            0x00004000
#define    DDR3_EMIF_SDRAM_ZQCR_DEFINE          0x50074BE1


//DDR3 300 MHz - CL=5,CWL=5
#define    DDR3_EMIF_TIM1_DEFINE_300            0x0888A394
#define    DDR3_EMIF_TIM2_DEFINE_300            0x20237FE2
#define    DDR3_EMIF_TIM3_DEFINE_300            0x501F820F
#define    DDR3_EMIF_REF_CTRL_DEFINE2_300        0x00000924
#define    DDR3_EMIF_SDRAM_CONFIG_DEFINE_300    0x61C009B2
#define    DDR3_EMIF_READ_LATENCY_DEFINE_300    0x00173208

//DDR3 333 MHz - CL=6,CWL=5
#define    DDR3_EMIF_TIM1_DEFINE_333            0x0888B414
#define    DDR3_EMIF_TIM2_DEFINE_333            0x20277FE2
#define    DDR3_EMIF_TIM3_DEFINE_333            0x501F824F
#define    DDR3_EMIF_REF_CTRL_DEFINE2_333        0x00000A25
#define    DDR3_EMIF_SDRAM_CONFIG_DEFINE_333    0x61C011B2
#define    DDR3_EMIF_READ_LATENCY_DEFINE_333    0x00173209

//DDR3 400 MHz - CL=6,CWL=5
#define    DDR3_EMIF_TIM1_DEFINE_400            0x0AAAD4DB
#define    DDR3_EMIF_TIM2_DEFINE_400            0x682F7FDA
#define    DDR3_EMIF_TIM3_DEFINE_400            0x501F82BF
#define    DDR3_EMIF_REF_CTRL_DEFINE2_400        0x00000C30
#define    DDR3_EMIF_SDRAM_CONFIG_DEFINE_400    0x61C011B2
#define    DDR3_EMIF_READ_LATENCY_DEFINE_400    0x00173209

//DDR3 450 MHz - CL=7,CWL=6
#define    DDR3_EMIF_TIM1_DEFINE_450            0x0CCCF55C
#define    DDR3_EMIF_TIM2_DEFINE_450            0x30357FE2
#define    DDR3_EMIF_TIM3_DEFINE_450            0x501F831F
#define    DDR3_EMIF_REF_CTRL_DEFINE2_450        0x00000DB6
#define    DDR3_EMIF_SDRAM_CONFIG_DEFINE_450    0x61C119B2
#define    DDR3_EMIF_READ_LATENCY_DEFINE_450    0x0017320A

//DDR3 533 MHz - CL=8,CWL=6
#define    DDR3_EMIF_TIM1_DEFINE_533            0x0EEF2664
#define    DDR3_EMIF_TIM2_DEFINE_533            0x303F7FE2
#define    DDR3_EMIF_TIM3_DEFINE_533            0x501F83AF
#define    DDR3_EMIF_REF_CTRL_DEFINE2_533        0x0000103D
#define    DDR3_EMIF_SDRAM_CONFIG_DEFINE_533    0x61C121B2
#define    DDR3_EMIF_READ_LATENCY_DEFINE_533    0x0017320B

//DDR3 666 MHz - CL=9,CWL=7
#define    DDR3_EMIF_TIM1_DEFINE_666            0x1333782C
#define    DDR3_EMIF_TIM2_DEFINE_666            0x404F7FE2
#define    DDR3_EMIF_TIM3_DEFINE_666            0x501F849F
#define    DDR3_EMIF_REF_CTRL_DEFINE2_666        0x0000144A
#define    DDR3_EMIF_SDRAM_CONFIG_DEFINE_666    0x61C229B2
#define    DDR3_EMIF_READ_LATENCY_DEFINE_666    0x0017320C



#define       DDR3_PHY_CTRL_SLAVE_RATIO_CS0_DEFINE       0x80

#define       DDR3_PHY_RD_DQS_CS0_DEFINE   0x30  // software leveling code @400MHz
#define       DDR3_PHY_WR_DQS_CS0_DEFINE    0x21
#define       DDR3_PHY_FIFO_WE_CS0_DEFINE    0xC0
#define       DDR3_PHY_WR_DATA_CS0_DEFINE    0x44


/*************************************************************************/
//Clockout_Enable
// CLKOUT2DIV THis  field controls the external clock divison factor
//          0x0:      SYS_CLKOLUT2/1
//          0x1:      SYS_CLKOUT2/2
//          0x2:      SYS_CLKOUT2/4
//          0x3:      SYS_CLKOUT2/8
//          0x4:      SYS_CLKOUT2/16

// CLKOUT2SOURCE     This field selects the external output clock source
//          0x0:      Source clock is MAIN_PLL_CLK5
//          0x1:      Source clock is DDR_PLL_CLK1
//          0x2:      Source clock is VIDEO_PLL_CLK1
//          0x3:      Source clock is AUDIO_PLL_CLK1

#define CLKOUT2EN    1
#define CLKOUT2DIV  0
#define CLKOUT2SRC  0


/**********************************************************************/
//Pincntrl Configurations
/**********************************************************************/
#define PINCNTL(n)  (*(unsigned int *)(CTRL_MODULE_BASE_ADDR + 0x0800 + (n-1)*4))
#define PINCNTL1    (CTRL_MODULE_BASE_ADDR + 0x0800 + (1-1)*4)
#define PINCNTL2    (CTRL_MODULE_BASE_ADDR + 0x0800 + (2 -1)*4)
#define PINCNTL3    (CTRL_MODULE_BASE_ADDR + 0x0800 + (3 -1)*4)
#define PINCNTL4    (CTRL_MODULE_BASE_ADDR + 0x0800 + (4 -1)*4)
#define PINCNTL5    (CTRL_MODULE_BASE_ADDR + 0x0800 + (5 -1)*4)
#define PINCNTL6    (CTRL_MODULE_BASE_ADDR + 0x0800 + (6 -1)*4)
#define PINCNTL7    (CTRL_MODULE_BASE_ADDR + 0x0800 + (7 -1)*4)
#define PINCNTL8    (CTRL_MODULE_BASE_ADDR + 0x0800 + (8 -1)*4)
#define PINCNTL9    (CTRL_MODULE_BASE_ADDR + 0x0800 + (9 -1)*4)
#define PINCNTL10   (CTRL_MODULE_BASE_ADDR + 0x0800 + (10-1)*4)
#define PINCNTL11   (CTRL_MODULE_BASE_ADDR + 0x0800 + (11-1)*4)
#define PINCNTL12   (CTRL_MODULE_BASE_ADDR + 0x0800 + (12-1)*4)
#define PINCNTL13   (CTRL_MODULE_BASE_ADDR + 0x0800 + (13-1)*4)
#define PINCNTL14   (CTRL_MODULE_BASE_ADDR + 0x0800 + (14-1)*4)
#define PINCNTL15   (CTRL_MODULE_BASE_ADDR + 0x0800 + (15-1)*4)
#define PINCNTL16   (CTRL_MODULE_BASE_ADDR + 0x0800 + (16-1)*4)
#define PINCNTL17   (CTRL_MODULE_BASE_ADDR + 0x0800 + (17-1)*4)
#define PINCNTL18   (CTRL_MODULE_BASE_ADDR + 0x0800 + (18-1)*4)
#define PINCNTL19   (CTRL_MODULE_BASE_ADDR + 0x0800 + (19-1)*4)
#define PINCNTL20   (CTRL_MODULE_BASE_ADDR + 0x0800 + (20-1)*4)
#define PINCNTL21   (CTRL_MODULE_BASE_ADDR + 0x0800 + (21-1)*4)
#define PINCNTL22   (CTRL_MODULE_BASE_ADDR + 0x0800 + (22-1)*4)
#define PINCNTL23   (CTRL_MODULE_BASE_ADDR + 0x0800 + (23-1)*4)
#define PINCNTL24   (CTRL_MODULE_BASE_ADDR + 0x0800 + (24-1)*4)
#define PINCNTL25   (CTRL_MODULE_BASE_ADDR + 0x0800 + (25-1)*4)
#define PINCNTL26   (CTRL_MODULE_BASE_ADDR + 0x0800 + (26-1)*4)
#define PINCNTL27   (CTRL_MODULE_BASE_ADDR + 0x0800 + (27-1)*4)
#define PINCNTL28   (CTRL_MODULE_BASE_ADDR + 0x0800 + (28-1)*4)
#define PINCNTL29   (CTRL_MODULE_BASE_ADDR + 0x0800 + (29-1)*4)
#define PINCNTL30   (CTRL_MODULE_BASE_ADDR + 0x0800 + (30-1)*4)
#define PINCNTL31   (CTRL_MODULE_BASE_ADDR + 0x0800 + (31-1)*4)
#define PINCNTL32   (CTRL_MODULE_BASE_ADDR + 0x0800 + (32-1)*4)
#define PINCNTL33   (CTRL_MODULE_BASE_ADDR + 0x0800 + (33-1)*4)
#define PINCNTL34   (CTRL_MODULE_BASE_ADDR + 0x0800 + (34-1)*4)
#define PINCNTL35   (CTRL_MODULE_BASE_ADDR + 0x0800 + (35-1)*4)
#define PINCNTL36   (CTRL_MODULE_BASE_ADDR + 0x0800 + (36-1)*4)
#define PINCNTL37   (CTRL_MODULE_BASE_ADDR + 0x0800 + (37-1)*4)
#define PINCNTL38   (CTRL_MODULE_BASE_ADDR + 0x0800 + (38-1)*4)
#define PINCNTL39   (CTRL_MODULE_BASE_ADDR + 0x0800 + (39-1)*4)
#define PINCNTL40   (CTRL_MODULE_BASE_ADDR + 0x0800 + (40-1)*4)
#define PINCNTL41   (CTRL_MODULE_BASE_ADDR + 0x0800 + (41-1)*4)
#define PINCNTL42   (CTRL_MODULE_BASE_ADDR + 0x0800 + (42-1)*4)
#define PINCNTL43   (CTRL_MODULE_BASE_ADDR + 0x0800 + (43-1)*4)
#define PINCNTL44   (CTRL_MODULE_BASE_ADDR + 0x0800 + (44-1)*4)
#define PINCNTL45   (CTRL_MODULE_BASE_ADDR + 0x0800 + (45-1)*4)
#define PINCNTL46   (CTRL_MODULE_BASE_ADDR + 0x0800 + (46-1)*4)
#define PINCNTL47   (CTRL_MODULE_BASE_ADDR + 0x0800 + (47-1)*4)
#define PINCNTL48   (CTRL_MODULE_BASE_ADDR + 0x0800 + (48-1)*4)
#define PINCNTL49   (CTRL_MODULE_BASE_ADDR + 0x0800 + (49-1)*4)
#define PINCNTL50   (CTRL_MODULE_BASE_ADDR + 0x0800 + (50-1)*4)
#define PINCNTL51   (CTRL_MODULE_BASE_ADDR + 0x0800 + (51-1)*4)
#define PINCNTL52   (CTRL_MODULE_BASE_ADDR + 0x0800 + (52-1)*4)
#define PINCNTL53   (CTRL_MODULE_BASE_ADDR + 0x0800 + (53-1)*4)
#define PINCNTL54   (CTRL_MODULE_BASE_ADDR + 0x0800 + (54-1)*4)
#define PINCNTL55   (CTRL_MODULE_BASE_ADDR + 0x0800 + (55-1)*4)
#define PINCNTL56   (CTRL_MODULE_BASE_ADDR + 0x0800 + (56-1)*4)
#define PINCNTL57   (CTRL_MODULE_BASE_ADDR + 0x0800 + (57-1)*4)
#define PINCNTL58   (CTRL_MODULE_BASE_ADDR + 0x0800 + (58-1)*4)
#define PINCNTL59   (CTRL_MODULE_BASE_ADDR + 0x0800 + (59-1)*4)
#define PINCNTL60   (CTRL_MODULE_BASE_ADDR + 0x0800 + (60-1)*4)
#define PINCNTL61   (CTRL_MODULE_BASE_ADDR + 0x0800 + (61-1)*4)
#define PINCNTL62   (CTRL_MODULE_BASE_ADDR + 0x0800 + (62-1)*4)
#define PINCNTL63   (CTRL_MODULE_BASE_ADDR + 0x0800 + (63-1)*4)
#define PINCNTL64   (CTRL_MODULE_BASE_ADDR + 0x0800 + (64-1)*4)
#define PINCNTL65   (CTRL_MODULE_BASE_ADDR + 0x0800 + (65-1)*4)
#define PINCNTL66   (CTRL_MODULE_BASE_ADDR + 0x0800 + (66-1)*4)
#define PINCNTL67   (CTRL_MODULE_BASE_ADDR + 0x0800 + (67-1)*4)
#define PINCNTL68   (CTRL_MODULE_BASE_ADDR + 0x0800 + (68-1)*4)
#define PINCNTL69   (CTRL_MODULE_BASE_ADDR + 0x0800 + (69-1)*4)
#define PINCNTL70   (CTRL_MODULE_BASE_ADDR + 0x0800 + (70-1)*4)
#define PINCNTL71   (CTRL_MODULE_BASE_ADDR + 0x0800 + (71-1)*4)
#define PINCNTL72   (CTRL_MODULE_BASE_ADDR + 0x0800 + (72-1)*4)
#define PINCNTL73   (CTRL_MODULE_BASE_ADDR + 0x0800 + (73-1)*4)
#define PINCNTL74   (CTRL_MODULE_BASE_ADDR + 0x0800 + (74-1)*4)
#define PINCNTL75   (CTRL_MODULE_BASE_ADDR + 0x0800 + (75-1)*4)
#define PINCNTL76   (CTRL_MODULE_BASE_ADDR + 0x0800 + (76-1)*4)
#define PINCNTL77   (CTRL_MODULE_BASE_ADDR + 0x0800 + (77-1)*4)
#define PINCNTL78   (CTRL_MODULE_BASE_ADDR + 0x0800 + (78-1)*4)
#define PINCNTL79   (CTRL_MODULE_BASE_ADDR + 0x0800 + (79-1)*4)
#define PINCNTL80   (CTRL_MODULE_BASE_ADDR + 0x0800 + (80-1)*4)
#define PINCNTL81   (CTRL_MODULE_BASE_ADDR + 0x0800 + (81-1)*4)
#define PINCNTL82   (CTRL_MODULE_BASE_ADDR + 0x0800 + (82-1)*4)
#define PINCNTL83   (CTRL_MODULE_BASE_ADDR + 0x0800 + (83-1)*4)
#define PINCNTL84   (CTRL_MODULE_BASE_ADDR + 0x0800 + (84-1)*4)
#define PINCNTL85   (CTRL_MODULE_BASE_ADDR + 0x0800 + (85-1)*4)
#define PINCNTL86   (CTRL_MODULE_BASE_ADDR + 0x0800 + (86-1)*4)
#define PINCNTL87   (CTRL_MODULE_BASE_ADDR + 0x0800 + (87-1)*4)
#define PINCNTL88   (CTRL_MODULE_BASE_ADDR + 0x0800 + (88-1)*4)
#define PINCNTL89   (CTRL_MODULE_BASE_ADDR + 0x0800 + (89-1)*4)
#define PINCNTL90   (CTRL_MODULE_BASE_ADDR + 0x0800 + (90-1)*4)
#define PINCNTL91   (CTRL_MODULE_BASE_ADDR + 0x0800 + (91-1)*4)
#define PINCNTL92   (CTRL_MODULE_BASE_ADDR + 0x0800 + (92-1)*4)
#define PINCNTL93   (CTRL_MODULE_BASE_ADDR + 0x0800 + (93-1)*4)
#define PINCNTL94   (CTRL_MODULE_BASE_ADDR + 0x0800 + (94-1)*4)
#define PINCNTL95   (CTRL_MODULE_BASE_ADDR + 0x0800 + (95-1)*4)
#define PINCNTL96   (CTRL_MODULE_BASE_ADDR + 0x0800 + (96-1)*4)
#define PINCNTL97   (CTRL_MODULE_BASE_ADDR + 0x0800 + (97-1)*4)
#define PINCNTL98   (CTRL_MODULE_BASE_ADDR + 0x0800 + (98-1)*4)
#define PINCNTL99   (CTRL_MODULE_BASE_ADDR + 0x0800 + (99-1)*4)
#define PINCNTL100  (CTRL_MODULE_BASE_ADDR + 0x0800 + (100-1)*4)
#define PINCNTL101  (CTRL_MODULE_BASE_ADDR + 0x0800 + (101 -1)*4)
#define PINCNTL102  (CTRL_MODULE_BASE_ADDR + 0x0800 + (102 -1)*4)
#define PINCNTL103  (CTRL_MODULE_BASE_ADDR + 0x0800 + (103 -1)*4)
#define PINCNTL104  (CTRL_MODULE_BASE_ADDR + 0x0800 + (104 -1)*4)
#define PINCNTL105  (CTRL_MODULE_BASE_ADDR + 0x0800 + (105 -1)*4)
#define PINCNTL106  (CTRL_MODULE_BASE_ADDR + 0x0800 + (106 -1)*4)
#define PINCNTL107  (CTRL_MODULE_BASE_ADDR + 0x0800 + (107 -1)*4)
#define PINCNTL108  (CTRL_MODULE_BASE_ADDR + 0x0800 + (108 -1)*4)
#define PINCNTL109  (CTRL_MODULE_BASE_ADDR + 0x0800 + (109 -1)*4)
#define PINCNTL110  (CTRL_MODULE_BASE_ADDR + 0x0800 + (110-1)*4)
#define PINCNTL111  (CTRL_MODULE_BASE_ADDR + 0x0800 + (111-1)*4)
#define PINCNTL112  (CTRL_MODULE_BASE_ADDR + 0x0800 + (112-1)*4)
#define PINCNTL113  (CTRL_MODULE_BASE_ADDR + 0x0800 + (113-1)*4)
#define PINCNTL114  (CTRL_MODULE_BASE_ADDR + 0x0800 + (114-1)*4)
#define PINCNTL115  (CTRL_MODULE_BASE_ADDR + 0x0800 + (115-1)*4)
#define PINCNTL116  (CTRL_MODULE_BASE_ADDR + 0x0800 + (116-1)*4)
#define PINCNTL117  (CTRL_MODULE_BASE_ADDR + 0x0800 + (117-1)*4)
#define PINCNTL118  (CTRL_MODULE_BASE_ADDR + 0x0800 + (118-1)*4)
#define PINCNTL119  (CTRL_MODULE_BASE_ADDR + 0x0800 + (119-1)*4)
#define PINCNTL120  (CTRL_MODULE_BASE_ADDR + 0x0800 + (120-1)*4)
#define PINCNTL121  (CTRL_MODULE_BASE_ADDR + 0x0800 + (121-1)*4)
#define PINCNTL122  (CTRL_MODULE_BASE_ADDR + 0x0800 + (122-1)*4)
#define PINCNTL123  (CTRL_MODULE_BASE_ADDR + 0x0800 + (123-1)*4)
#define PINCNTL124  (CTRL_MODULE_BASE_ADDR + 0x0800 + (124-1)*4)
#define PINCNTL125  (CTRL_MODULE_BASE_ADDR + 0x0800 + (125-1)*4)
#define PINCNTL126  (CTRL_MODULE_BASE_ADDR + 0x0800 + (126-1)*4)
#define PINCNTL127  (CTRL_MODULE_BASE_ADDR + 0x0800 + (127-1)*4)
#define PINCNTL128  (CTRL_MODULE_BASE_ADDR + 0x0800 + (128-1)*4)
#define PINCNTL129  (CTRL_MODULE_BASE_ADDR + 0x0800 + (129-1)*4)
#define PINCNTL130  (CTRL_MODULE_BASE_ADDR + 0x0800 + (130-1)*4)
#define PINCNTL131  (CTRL_MODULE_BASE_ADDR + 0x0800 + (131-1)*4)
#define PINCNTL132  (CTRL_MODULE_BASE_ADDR + 0x0800 + (132-1)*4)
#define PINCNTL133  (CTRL_MODULE_BASE_ADDR + 0x0800 + (133-1)*4)
#define PINCNTL134  (CTRL_MODULE_BASE_ADDR + 0x0800 + (134-1)*4)
#define PINCNTL135  (CTRL_MODULE_BASE_ADDR + 0x0800 + (135-1)*4)
#define PINCNTL136  (CTRL_MODULE_BASE_ADDR + 0x0800 + (136-1)*4)
#define PINCNTL137  (CTRL_MODULE_BASE_ADDR + 0x0800 + (137-1)*4)
#define PINCNTL138  (CTRL_MODULE_BASE_ADDR + 0x0800 + (138-1)*4)
#define PINCNTL139  (CTRL_MODULE_BASE_ADDR + 0x0800 + (139-1)*4)
#define PINCNTL140  (CTRL_MODULE_BASE_ADDR + 0x0800 + (140-1)*4)
#define PINCNTL141  (CTRL_MODULE_BASE_ADDR + 0x0800 + (141-1)*4)
#define PINCNTL142  (CTRL_MODULE_BASE_ADDR + 0x0800 + (142-1)*4)
#define PINCNTL143  (CTRL_MODULE_BASE_ADDR + 0x0800 + (143-1)*4)
#define PINCNTL144  (CTRL_MODULE_BASE_ADDR + 0x0800 + (144-1)*4)
#define PINCNTL145  (CTRL_MODULE_BASE_ADDR + 0x0800 + (145-1)*4)
#define PINCNTL146  (CTRL_MODULE_BASE_ADDR + 0x0800 + (146-1)*4)
#define PINCNTL147  (CTRL_MODULE_BASE_ADDR + 0x0800 + (147-1)*4)
#define PINCNTL148  (CTRL_MODULE_BASE_ADDR + 0x0800 + (148-1)*4)
#define PINCNTL149  (CTRL_MODULE_BASE_ADDR + 0x0800 + (149-1)*4)
#define PINCNTL150  (CTRL_MODULE_BASE_ADDR + 0x0800 + (150-1)*4)
#define PINCNTL151  (CTRL_MODULE_BASE_ADDR + 0x0800 + (151-1)*4)
#define PINCNTL152  (CTRL_MODULE_BASE_ADDR + 0x0800 + (152-1)*4)
#define PINCNTL153  (CTRL_MODULE_BASE_ADDR + 0x0800 + (153-1)*4)
#define PINCNTL154  (CTRL_MODULE_BASE_ADDR + 0x0800 + (154-1)*4)
#define PINCNTL155  (CTRL_MODULE_BASE_ADDR + 0x0800 + (155-1)*4)
#define PINCNTL156  (CTRL_MODULE_BASE_ADDR + 0x0800 + (156-1)*4)
#define PINCNTL157  (CTRL_MODULE_BASE_ADDR + 0x0800 + (157-1)*4)
#define PINCNTL158  (CTRL_MODULE_BASE_ADDR + 0x0800 + (158-1)*4)
#define PINCNTL159  (CTRL_MODULE_BASE_ADDR + 0x0800 + (159-1)*4)
#define PINCNTL160  (CTRL_MODULE_BASE_ADDR + 0x0800 + (160-1)*4)
#define PINCNTL161  (CTRL_MODULE_BASE_ADDR + 0x0800 + (161-1)*4)
#define PINCNTL162  (CTRL_MODULE_BASE_ADDR + 0x0800 + (162-1)*4)
#define PINCNTL163  (CTRL_MODULE_BASE_ADDR + 0x0800 + (163-1)*4)
#define PINCNTL164  (CTRL_MODULE_BASE_ADDR + 0x0800 + (164-1)*4)
#define PINCNTL165  (CTRL_MODULE_BASE_ADDR + 0x0800 + (165-1)*4)
#define PINCNTL166  (CTRL_MODULE_BASE_ADDR + 0x0800 + (166-1)*4)
#define PINCNTL167  (CTRL_MODULE_BASE_ADDR + 0x0800 + (167-1)*4)
#define PINCNTL168  (CTRL_MODULE_BASE_ADDR + 0x0800 + (168-1)*4)
#define PINCNTL169  (CTRL_MODULE_BASE_ADDR + 0x0800 + (169-1)*4)
#define PINCNTL170  (CTRL_MODULE_BASE_ADDR + 0x0800 + (170-1)*4)
#define PINCNTL171  (CTRL_MODULE_BASE_ADDR + 0x0800 + (171-1)*4)
#define PINCNTL172  (CTRL_MODULE_BASE_ADDR + 0x0800 + (172-1)*4)
#define PINCNTL173  (CTRL_MODULE_BASE_ADDR + 0x0800 + (173-1)*4)
#define PINCNTL174  (CTRL_MODULE_BASE_ADDR + 0x0800 + (174-1)*4)
#define PINCNTL175  (CTRL_MODULE_BASE_ADDR + 0x0800 + (175-1)*4)
#define PINCNTL176  (CTRL_MODULE_BASE_ADDR + 0x0800 + (176-1)*4)
#define PINCNTL177  (CTRL_MODULE_BASE_ADDR + 0x0800 + (177-1)*4)
#define PINCNTL178  (CTRL_MODULE_BASE_ADDR + 0x0800 + (178-1)*4)
#define PINCNTL179  (CTRL_MODULE_BASE_ADDR + 0x0800 + (179-1)*4)
#define PINCNTL180  (CTRL_MODULE_BASE_ADDR + 0x0800 + (180-1)*4)
#define PINCNTL181  (CTRL_MODULE_BASE_ADDR + 0x0800 + (181-1)*4)
#define PINCNTL182  (CTRL_MODULE_BASE_ADDR + 0x0800 + (182-1)*4)
#define PINCNTL183  (CTRL_MODULE_BASE_ADDR + 0x0800 + (183-1)*4)
#define PINCNTL184  (CTRL_MODULE_BASE_ADDR + 0x0800 + (184-1)*4)
#define PINCNTL185  (CTRL_MODULE_BASE_ADDR + 0x0800 + (185-1)*4)
#define PINCNTL186  (CTRL_MODULE_BASE_ADDR + 0x0800 + (186-1)*4)
#define PINCNTL187  (CTRL_MODULE_BASE_ADDR + 0x0800 + (187-1)*4)
#define PINCNTL188  (CTRL_MODULE_BASE_ADDR + 0x0800 + (188-1)*4)
#define PINCNTL189  (CTRL_MODULE_BASE_ADDR + 0x0800 + (189-1)*4)
#define PINCNTL190  (CTRL_MODULE_BASE_ADDR + 0x0800 + (190-1)*4)
#define PINCNTL191  (CTRL_MODULE_BASE_ADDR + 0x0800 + (191-1)*4)
#define PINCNTL192  (CTRL_MODULE_BASE_ADDR + 0x0800 + (192-1)*4)
#define PINCNTL193  (CTRL_MODULE_BASE_ADDR + 0x0800 + (193-1)*4)
#define PINCNTL194  (CTRL_MODULE_BASE_ADDR + 0x0800 + (194-1)*4)
#define PINCNTL195  (CTRL_MODULE_BASE_ADDR + 0x0800 + (195-1)*4)
#define PINCNTL196  (CTRL_MODULE_BASE_ADDR + 0x0800 + (196-1)*4)
#define PINCNTL197  (CTRL_MODULE_BASE_ADDR + 0x0800 + (197-1)*4)
#define PINCNTL198  (CTRL_MODULE_BASE_ADDR + 0x0800 + (198-1)*4)
#define PINCNTL199  (CTRL_MODULE_BASE_ADDR + 0x0800 + (199-1)*4)
#define PINCNTL200  (CTRL_MODULE_BASE_ADDR + 0x0800 + (200-1)*4)
#define PINCNTL201  (CTRL_MODULE_BASE_ADDR + 0x0800 + (201-1)*4)
#define PINCNTL202  (CTRL_MODULE_BASE_ADDR + 0x0800 + (202 -1)*4)
#define PINCNTL203  (CTRL_MODULE_BASE_ADDR + 0x0800 + (203 -1)*4)
#define PINCNTL204  (CTRL_MODULE_BASE_ADDR + 0x0800 + (204 -1)*4)
#define PINCNTL205  (CTRL_MODULE_BASE_ADDR + 0x0800 + (205 -1)*4)
#define PINCNTL206  (CTRL_MODULE_BASE_ADDR + 0x0800 + (206 -1)*4)
#define PINCNTL207  (CTRL_MODULE_BASE_ADDR + 0x0800 + (207 -1)*4)
#define PINCNTL208  (CTRL_MODULE_BASE_ADDR + 0x0800 + (208 -1)*4)
#define PINCNTL209  (CTRL_MODULE_BASE_ADDR + 0x0800 + (209 -1)*4)
#define PINCNTL210  (CTRL_MODULE_BASE_ADDR + 0x0800 + (210-1)*4)
#define PINCNTL211  (CTRL_MODULE_BASE_ADDR + 0x0800 + (211-1)*4)
#define PINCNTL212  (CTRL_MODULE_BASE_ADDR + 0x0800 + (212-1)*4)
#define PINCNTL213  (CTRL_MODULE_BASE_ADDR + 0x0800 + (213-1)*4)
#define PINCNTL214  (CTRL_MODULE_BASE_ADDR + 0x0800 + (214-1)*4)
#define PINCNTL215  (CTRL_MODULE_BASE_ADDR + 0x0800 + (215-1)*4)
#define PINCNTL216  (CTRL_MODULE_BASE_ADDR + 0x0800 + (216-1)*4)
#define PINCNTL217  (CTRL_MODULE_BASE_ADDR + 0x0800 + (217-1)*4)
#define PINCNTL218  (CTRL_MODULE_BASE_ADDR + 0x0800 + (218-1)*4)
#define PINCNTL219  (CTRL_MODULE_BASE_ADDR + 0x0800 + (219-1)*4)
#define PINCNTL220  (CTRL_MODULE_BASE_ADDR + 0x0800 + (220-1)*4)
#define PINCNTL221  (CTRL_MODULE_BASE_ADDR + 0x0800 + (221-1)*4)
#define PINCNTL222  (CTRL_MODULE_BASE_ADDR + 0x0800 + (222-1)*4)
#define PINCNTL223  (CTRL_MODULE_BASE_ADDR + 0x0800 + (223-1)*4)
#define PINCNTL224  (CTRL_MODULE_BASE_ADDR + 0x0800 + (224-1)*4)
#define PINCNTL225  (CTRL_MODULE_BASE_ADDR + 0x0800 + (225-1)*4)
#define PINCNTL226  (CTRL_MODULE_BASE_ADDR + 0x0800 + (226-1)*4)
#define PINCNTL227  (CTRL_MODULE_BASE_ADDR + 0x0800 + (227-1)*4)
#define PINCNTL228  (CTRL_MODULE_BASE_ADDR + 0x0800 + (228-1)*4)
#define PINCNTL229  (CTRL_MODULE_BASE_ADDR + 0x0800 + (229-1)*4)
#define PINCNTL230  (CTRL_MODULE_BASE_ADDR + 0x0800 + (230-1)*4)
#define PINCNTL231  (CTRL_MODULE_BASE_ADDR + 0x0800 + (231-1)*4)
#define PINCNTL232  (CTRL_MODULE_BASE_ADDR + 0x0800 + (232-1)*4)
#define PINCNTL233  (CTRL_MODULE_BASE_ADDR + 0x0800 + (233-1)*4)
#define PINCNTL234  (CTRL_MODULE_BASE_ADDR + 0x0800 + (234-1)*4)
#define PINCNTL235  (CTRL_MODULE_BASE_ADDR + 0x0800 + (235-1)*4)
#define PINCNTL236  (CTRL_MODULE_BASE_ADDR + 0x0800 + (236-1)*4)
#define PINCNTL237  (CTRL_MODULE_BASE_ADDR + 0x0800 + (237-1)*4)
#define PINCNTL238  (CTRL_MODULE_BASE_ADDR + 0x0800 + (238-1)*4)
#define PINCNTL239  (CTRL_MODULE_BASE_ADDR + 0x0800 + (239-1)*4)
#define PINCNTL240  (CTRL_MODULE_BASE_ADDR + 0x0800 + (240-1)*4)
#define PINCNTL241  (CTRL_MODULE_BASE_ADDR + 0x0800 + (241-1)*4)
#define PINCNTL242  (CTRL_MODULE_BASE_ADDR + 0x0800 + (242-1)*4)
#define PINCNTL243  (CTRL_MODULE_BASE_ADDR + 0x0800 + (243-1)*4)
#define PINCNTL244  (CTRL_MODULE_BASE_ADDR + 0x0800 + (244-1)*4)
#define PINCNTL245  (CTRL_MODULE_BASE_ADDR + 0x0800 + (245-1)*4)
#define PINCNTL246  (CTRL_MODULE_BASE_ADDR + 0x0800 + (246-1)*4)
#define PINCNTL247  (CTRL_MODULE_BASE_ADDR + 0x0800 + (247-1)*4)
#define PINCNTL248  (CTRL_MODULE_BASE_ADDR + 0x0800 + (248-1)*4)
#define PINCNTL249  (CTRL_MODULE_BASE_ADDR + 0x0800 + (249-1)*4)
#define PINCNTL250  (CTRL_MODULE_BASE_ADDR + 0x0800 + (250-1)*4)
#define PINCNTL251  (CTRL_MODULE_BASE_ADDR + 0x0800 + (251-1)*4)
#define PINCNTL252  (CTRL_MODULE_BASE_ADDR + 0x0800 + (252-1)*4)
#define PINCNTL253  (CTRL_MODULE_BASE_ADDR + 0x0800 + (253-1)*4)
#define PINCNTL254  (CTRL_MODULE_BASE_ADDR + 0x0800 + (254-1)*4)
#define PINCNTL255  (CTRL_MODULE_BASE_ADDR + 0x0800 + (255-1)*4)
#define PINCNTL256  (CTRL_MODULE_BASE_ADDR + 0x0800 + (256-1)*4)
#define PINCNTL257  (CTRL_MODULE_BASE_ADDR + 0x0800 + (257-1)*4)
#define PINCNTL258  (CTRL_MODULE_BASE_ADDR + 0x0800 + (258-1)*4)
#define PINCNTL259  (CTRL_MODULE_BASE_ADDR + 0x0800 + (259-1)*4)
#define PINCNTL260  (CTRL_MODULE_BASE_ADDR + 0x0800 + (260-1)*4)
#define PINCNTL261  (CTRL_MODULE_BASE_ADDR + 0x0800 + (261-1)*4)
#define PINCNTL262  (CTRL_MODULE_BASE_ADDR + 0x0800 + (262-1)*4)
#define PINCNTL263  (CTRL_MODULE_BASE_ADDR + 0x0800 + (263-1)*4)
#define PINCNTL264  (CTRL_MODULE_BASE_ADDR + 0x0800 + (264-1)*4)
#define PINCNTL265  (CTRL_MODULE_BASE_ADDR + 0x0800 + (265-1)*4)
#define PINCNTL266  (CTRL_MODULE_BASE_ADDR + 0x0800 + (266-1)*4)
#define PINCNTL267  (CTRL_MODULE_BASE_ADDR + 0x0800 + (267-1)*4)
#define PINCNTL268  (CTRL_MODULE_BASE_ADDR + 0x0800 + (268-1)*4)
#define PINCNTL269  (CTRL_MODULE_BASE_ADDR + 0x0800 + (269-1)*4)
#define PINCNTL270  (CTRL_MODULE_BASE_ADDR + 0x0800 + (270-1)*4)
#define PINCNTL271  (CTRL_MODULE_BASE_ADDR + 0x0800 + (271-1)*4)



/****************** PLL Configuration ******************************************/

/***    PLL,Control Base Adress   ***********/
#define PLL_BASE_ADDRESS         0x481C5000
#define CONTROL_BASE_ADDRESS     0x48140000
#define OSC_SRC_CTRL            (PLL_BASE_ADDRESS+0x02c0)
#define ARM_SRC_CLK             (PLL_BASE_ADDRESS+0x02c4)

/***    Top Level ADPLLJ  Base Address   ***********/
#define L3_PLL_BASE             (PLL_BASE_ADDRESS+0x110)
#define HDVICP_PLL_BASE         (PLL_BASE_ADDRESS+0x0E0)
#define DSS_PLL_BASE            (PLL_BASE_ADDRESS+0x170)
#define SGX_PLL_BASE            (PLL_BASE_ADDRESS+0x0B0)
#define DSP_PLL_BASE            (PLL_BASE_ADDRESS+0x080)
#define ISS_PLL_BASE            (PLL_BASE_ADDRESS+0x140)
#define USB_PLL_BASE            (PLL_BASE_ADDRESS+0x260)
#define AUDIO_PLL_BASE          (PLL_BASE_ADDRESS+0x230)
#define VIDEO_0_PLL_BASE        (PLL_BASE_ADDRESS+0x1A0)
#define VIDEO_1_PLL_BASE        (PLL_BASE_ADDRESS+0x1D0)
#define HDMI_PLL_BASE           (PLL_BASE_ADDRESS+0x200)
#define DDR_PLL_BASE            (PLL_BASE_ADDRESS+0x290)

/********** ADPLL intrnal Offset Registers  ***********/
#define CLKCTRL                 0x4
#define TENABLE                 0x8
#define TENABLEDIV              0xC
#define M2NDIV                  0x10
#define MN2DIV                  0x14
#define STATUS                  0x24

/*********** A8 ADPLLS REGISTERS  *********/
#define A8PLL_CLKCTRL       (PLL_BASE_ADDRESS+0x04c)
#define A8PLL_TENABLE       (PLL_BASE_ADDRESS+0x050)
#define A8PLL_TENABLEDIV    (PLL_BASE_ADDRESS+0x054)
#define A8PLL_M2NDIV        (PLL_BASE_ADDRESS+0x058)
#define A8PLL_MN2DIV        (PLL_BASE_ADDRESS+0x05c)
#define A8PLL_STATUS        (PLL_BASE_ADDRESS+0x06c)

/********   SATA PLL REGISTERS   **************/
#define SATA_PLLCFG0            (CONTROL_BASE_ADDRESS+0x720)
#define SATA_PLLCFG1            (CONTROL_BASE_ADDRESS+0x724)
#define SATA_PLLCFG2            (CONTROL_BASE_ADDRESS+0x728)
#define SATA_PLLCFG3            (CONTROL_BASE_ADDRESS+0x72c)
#define SATA_PLLCFG4            (CONTROL_BASE_ADDRESS+0x730)
#define SATA_PLLSTATUS          (CONTROL_BASE_ADDRESS+0x734)
#define SATA_RXSTATUS           (CONTROL_BASE_ADDRESS+0x738)
#define SATA_TXSTATUS           (CONTROL_BASE_ADDRESS+0x73c)

/********   PCIE PLL REGISTERS   **************/
#define PCIE_PLLCFG0            (CONTROL_BASE_ADDRESS+0x6D8)
#define PCIE_PLLCFG1            (CONTROL_BASE_ADDRESS+0x6DC)
#define PCIE_PLLCFG2            (CONTROL_BASE_ADDRESS+0x6E0)
#define PCIE_PLLCFG3            (CONTROL_BASE_ADDRESS+0x6E4)
#define PCIE_PLLCFG4            (CONTROL_BASE_ADDRESS+0x6E8)
#define PCIE_PLLSTATUS          (CONTROL_BASE_ADDRESS+0x6EC)
#define PCIE_RXSTATUS           (CONTROL_BASE_ADDRESS+0x6F0)
#define PCIE_TXSTATUS           (CONTROL_BASE_ADDRESS+0x6F4)
#define SERDES_REFCLK_CTL       (CONTROL_BASE_ADDRESS+0xE24)

#define CONTROL_STATUS              (CTRL_MODULE_BASE_ADDR + 0x040)
#define BANDGAP0_TRIM       (CTRL_MODULE_BASE_ADDR + 0x44C)
#define BANDGAP1_TRIM       (CTRL_MODULE_BASE_ADDR + 0x454)
#define PLL_SUBSYSTEM_BASE_ADDR       PLL_BASE_ADDRESS
#define DSPPLL_CLOCK_CONTROL       (PLL_SUBSYSTEM_BASE_ADDR + 0x084)
#define SGXPLL_CLOCK_CONTROL       (PLL_SUBSYSTEM_BASE_ADDR + 0x0B4)
#define HDVICPPLL_CLOCK_CONTROL    (PLL_SUBSYSTEM_BASE_ADDR + 0x0E4)
#define L3PLL_CLOCK_CONTROL        (PLL_SUBSYSTEM_BASE_ADDR + 0x114)
#define DSSPLL_CLOCK_CONTROL       (PLL_SUBSYSTEM_BASE_ADDR + 0x174)
#define VID0PLL_CLOCK_CONTROL      (PLL_SUBSYSTEM_BASE_ADDR + 0x1A4)
#define VID1PLL_CLOCK_CONTROL      (PLL_SUBSYSTEM_BASE_ADDR + 0x1D4)
#define HDMIPLL_CLOCK_CONTROL      (PLL_SUBSYSTEM_BASE_ADDR + 0x204)
#define AUDIOPLL_CLOCK_CONTROL     (PLL_SUBSYSTEM_BASE_ADDR + 0x234)
#define USBPLL_CLOCK_CONTROL       (PLL_SUBSYSTEM_BASE_ADDR + 0x264)
#define DDRPLL_CLOCK_CONTROL       (PLL_SUBSYSTEM_BASE_ADDR + 0x294)
#define A8PLL_CLOCK_CONTROL        (PLL_SUBSYSTEM_BASE_ADDR + 0x04C)


/*************************************************************************************************************
                                 ADPLLJ CLKCNTRL REGISTER CONFIGURATIONS
***************************************************************************************************************/
// ADPLLJ_CLKCRTL_Register Value Configurations
//add ntrim values for test device  --- Rajesh/Hemanth(bits 28:24)
#define ADPLLJ_CLKCRTL_HS2       0x00000801 //HS2 Mode,TINTZ =1  --used by all PLL's except HDMI
#define ADPLLJ_CLKCRTL_HS1       0x00001001 //HS1 Mode,TINTZ =1  --used only for HDMI
#define ADPLLJ_CLKCRTL_CLKDCO    0x200a0000 // Enable CLKDCOEN,CLKLDOEN,CLKDCOPWDNZ -- used for HDMI,USB

/****************************************************************************************************************/
// CONTROL MMMR LOCK and UNLOCK Registers
#define control_pllss_mmr_lock                     0x481C5040
#define control_mmr_lock0                          0x48140060
#define control_mmr_lock1                          0x48140064
#define control_mmr_lock2                          0x48140068
#define control_mmr_lock3                          0x4814006c
#define control_mmr_lock4                          0x48140070

#define control_pllss_mmr_lock_unlock_val          0x1EDA4C3D
#define control_mmr_lock0_unlock_val               0x2FF1AC2B
#define control_mmr_lock1_unlock_val               0xF757FDC0
#define control_mmr_lock2_unlock_val               0xE2BC3A6D
#define control_mmr_lock3_unlock_val               0x1EBF131D
#define control_mmr_lock4_unlock_val               0x6F361E05


/****************************************************************************************************************/




menuitem "DM8148 System Initialization"
    hotmenu mmr_unlock_API()
    {
        mmr_unlock();
    }

    hotmenu ALL_ADPLL_CLOCKS_ENABLE_API()
    {
        GEL_TextOut("\t ****  DM8148 ALL ADPLL INIT IS In Progress ......... \n");
        Setup_PLL();
        GEL_TextOut("\t ****  DM8148 ALL ADPLL INIT IS  Done ************** \n");
    }

/********************************************************************************************
    //Note: By default the Values of ADPLL are set using "ALL_ADPLL_CLOCKS_ENABLE" function if called.

    //CONFIGURE ADPLL TO GET REQUIRED CLKOUTS  with your required values of N,M,M2

    //RUN THE HOTMENU of the REQUIRED CHANGED PLL
*********************************************************************************************/

    /***********************************************************************************
        Change the values of N,M,M2 to get the Required ADPLL Clockout
        cmdxxxxPLL(int CLKIN,int N, int M, int M2)

        ****   REF_CLK       = (CLKIP)/N+1  [  REF_CLK < 2.5MHz      ]
        ****   DCOCLK_HS2    = (REF_CLK)*M     [500  < DCOCLK < 1000MHz ]
        ****   DCOCLK_HS1    = (REF_CLK)*M     [1000 < DCOCLK < 2000MHz ]--used for HDMI CLKDCO
        ****   CLKOUT        =  DCOCLK/M2      [10   < CLKOUT < 2000MHz ]
        ****   N+1                                   [1..256]
        ****   M                                  [2..4095]
        ****   M2                                  [1..127]
        ****
    *************************************************************************************/

    /***************************************************************************
            CONTROL MODULE,ADPLL,C674x,HDVICP,GPMC Clock ENABLES
    *********************************************************************************/
menuitem "DM8148 CORE_CLKS Configuration"
    /********* Enable the OCMC0RAM Clocks ************/
    hotmenu PrcmAlwayOnClkEnable_API()
    {
        PrcmAlwayOnClkEnable();
    }

    /************ Enable the HDVICP Clocks ***************/
    hotmenu HDVICPClkEnable_API()
    {
        HDVICPClkEnable();
    }

    /************ Enable the C674x Clocks ***************/
    hotmenu C674xClkEnable_API()
    {
        C674xClkEnable();
    }

   /********************************************************************************
                          PERIPHERAL CLOCK ENABLES
                        EMAC,UART,DSS,MLB,DCAN
   *********************************************************************************/
   /*** ADD Here if any required Module clocks *************/

menuitem "DM8148 Peripheral Clock Init"
    hotmenu ControlModule_ClkEnable_API()
    {
        ControlModule_ClkEnable();
    }

     hotmenu PrcmOCMCClkEnable_API()
    {
        PrcmOCMCClkEnable();
    }

    hotmenu Clockout_Enable_API()
    {
        Clockout_Enable();
    }

    hotmenu UARTClkEnable_API()
    {
        UARTClkEnable();
    }

    hotmenu DSSClkEnable_API()
    {
        DSSClkEnable();
    }

    hotmenu MLBClkEnable_API()
    {
        MLBClkEnable();
    }

    hotmenu DCANClkEnable_API()
    {
        DCANClkEnable();
    }

    hotmenu GPMC_ClkEnable_API()
    {
        GPMC_ClkEnable();
    }

/********************************************************************************/


/*******************************************************************************************************
****
****                                   ********* RANGE ************
****   REF_CLK       = (OSC_FREQ)/N+1  [  REF_CLK < 2.5MHz      ]
****   DCOCLK_HS2    = (REF_CLK)*M     [500  < DCOCLK < 1000MHz ]
****   DCOCLK_HS1    = (REF_CLK)*M     [1000 < DCOCLK < 2000MHz ]--used for HDMI CLKDCO
****   CLKOUT        =  DCOCLK/M2      [10   < CLKOUT < 2000MHz ]
****   N+1                                   [1..256]
****   M                                  [2..4095]
****   M2                                  [1..127]
****
****
******************************************************************************************************/

/***************************************************************

 **** PLEASE DONT CHANGE THE BELOW CONFIGURED VALUES OF Setup_PLL *****

   IF NOT required do not call ALL_ADPLL_CLOCKS_ENABLE function(hotmenu)

***************************************************************/

int CLKIN = 20;
int HSMODE,CLKOUT = 0;
/* ------------------------------------------------------------------------ *
 *                                                                          *
 *  Setup_PLL( )                                                            *
 *      Setup PLL                                                           *
 *                                                                          *
 *       PLL output = CLKINP * M/(N+1) * 1/M2                               *
 *                                                                          *
 * ------------------------------------------------------------------------ */
Setup_PLL()
{
    GEL_TextOut("    Initializing PLLs....\n");
    // 600 MHz Cortex A8 core
    cmdMPUPLL(CLKIN,1, 60 ,1);       // 20 * 60 /(1 +1) * 1/1 = 600 MHz : Cortex A8

    cmdL3PLL(CLKIN, 19, 800, 4);     // 20 * 800/(19+1) * 1/2 = 200 MHz : L3 Interconnect

    cmdDSPPLL(CLKIN,19, 500, 1);

    cmdDSSPLL(CLKIN,19, 800, 4);

    cmdISSPLL(CLKIN,19, 800 ,2);

    cmdHDVICPPLL(CLKIN,19, 532, 2);

    cmdSGXPLL(CLKIN,19, 800, 4);

    cmdUSBPLL(CLKIN,19,960,5);

    // For RGMII Ethernet, need 250MHz clock
    //cmdVIDEO0PLL(CLKIN,19, 540,10);
    cmdVIDEO0PLL(CLKIN,19, 500, 2);

    cmdVIDEO1PLL(CLKIN,19, 594,4);

    cmdHDMIPLL(CLKIN,19, 1485,10);

    cmdAUDIOPLL(CLKIN,19,800,4);

    GEL_TextOut("    PLL Initialization Done\n");
}

cmdMPUPLL(int CLKIN,int N, int M, int M2)
{
    A8_PLL_Config(CLKIN,N,M,M2);
    GEL_TextOut("\t A8 ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
}

cmdL3PLL(int CLKIN,int N, int M, int M2)
{
    DCOCLK_COMP(CLKIN,N,M);
    if(HSMODE == 2)
    {
        PLL_Clocks_Config(L3_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS2);
        GEL_TextOut("\t L3  ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
    }
    else if (HSMODE == 1)
    {
        PLL_Clocks_Config(L3_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS1);
        GEL_TextOut("\t L3  ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
    }
    else
    {
        GEL_TextOut("\t L3 PLL NOT Configured.Wrong DCOCLK Output\n");
    }
}

cmdDSPPLL(int CLKIN,int N, int M, int M2)
{
    DCOCLK_COMP(CLKIN,N,M);
    if(HSMODE == 2)
    {
        PLL_Clocks_Config(DSP_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS2);
        GEL_TextOut("\t DSP ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
    }
    else if (HSMODE == 1)
    {
        PLL_Clocks_Config(DSP_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS1);
        GEL_TextOut("\t DSP ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
    }
    else
    {
        GEL_TextOut("\t DSP PLL NOT Configured.Wrong DCOCLK Output\n");
    }
}

cmdDSSPLL(int CLKIN, int N, int M, int M2)
{
    DCOCLK_COMP(CLKIN,N,M);
    if(HSMODE == 2)
    {
        PLL_Clocks_Config(DSS_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS2);
        GEL_TextOut("\t DSS ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
    }
    else if (HSMODE == 1)
    {
        PLL_Clocks_Config(DSS_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS1);
        GEL_TextOut("\t DSS ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
    }
    else
    {
        GEL_TextOut("\t DSS PLL NOT Configured.Wrong DCOCLK Output\n");
    }
}

cmdSGXPLL(int CLKIN, int N, int M, int M2)
{
    DCOCLK_COMP(CLKIN,N,M);
    if(HSMODE == 2)
    {
        PLL_Clocks_Config(SGX_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS2);
        GEL_TextOut("\t SGX ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
    }
    else if (HSMODE == 1)
    {
        PLL_Clocks_Config(SGX_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS1);
        GEL_TextOut("\t SGX ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
    }
    else
    {
        GEL_TextOut("\t SGX PLL NOT Configured.Wrong DCOCLK Output\n");
    }
}

cmdHDVICPPLL(int CLKIN,int N, int M, int M2)
{
    DCOCLK_COMP(CLKIN,N,M);
    if(HSMODE == 2)
    {
        PLL_Clocks_Config(HDVICP_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS2);
        GEL_TextOut("\t HDVICP ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
    }
    else if (HSMODE == 1)
    {
        PLL_Clocks_Config(HDVICP_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS1);
        GEL_TextOut("\t HDVICP ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
    }
    else
    {
        GEL_TextOut("\t HDVICP PLL NOT Configured.Wrong DCOCLK Output\n");
    }
}

cmdISSPLL(int CLKIN,int N, int M, int M2)
{
        DCOCLK_COMP(CLKIN,N,M);
        if(HSMODE == 2)
        {
            PLL_Clocks_Config(ISS_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS2);
            GEL_TextOut("\t ISS ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
        }
        else if (HSMODE == 1)
        {
            PLL_Clocks_Config(ISS_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS1);
            GEL_TextOut("\t ISS ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
        }
        else
        {
            GEL_TextOut("\t ISS PLL NOT Configured.Wrong DCOCLK Output\n");
        }

}

// enabling the CLKOUTDCO,CLKDCOLDO
cmdUSBPLL(int CLKIN,int N, int M, int M2)
{
        DCOCLK_COMP(CLKIN,N,M);
        if(HSMODE == 2){
            PLL_Clocks_Config(USB_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS2+ADPLLJ_CLKCRTL_CLKDCO);
             GEL_TextOut("\t USB ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
        }
        else if (HSMODE == 1){
            PLL_Clocks_Config(USB_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS1+ADPLLJ_CLKCRTL_CLKDCO);
             GEL_TextOut("\t USB ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
        }
        else {
                  GEL_TextOut("\t USB PLL NOT Configured.Wrong DCOCLK Output\n");
        }

}

cmdVIDEO0PLL(int CLKIN,int N, int M, int M2)
{
        DCOCLK_COMP(CLKIN,N,M);
        if(HSMODE == 2){
            PLL_Clocks_Config(VIDEO_0_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS2);
             GEL_TextOut("\t VIDEO-0 ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
        }
        else if (HSMODE == 1){
            PLL_Clocks_Config(VIDEO_0_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS1);
             GEL_TextOut("\t VIDEO-0 ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
        }
        else {
                  GEL_TextOut("\t VIDEO-0 PLL NOT Configured.Wrong DCOCLK Output\n");
        }


}

cmdVIDEO1PLL(int CLKIN,int N, int M, int M2)
{
        DCOCLK_COMP(CLKIN,N,M);
        if(HSMODE == 2){
            PLL_Clocks_Config(VIDEO_1_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS2);
             GEL_TextOut("\t VIDEO-1 ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
        }
        else if (HSMODE == 1){
            PLL_Clocks_Config(VIDEO_1_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS1);
             GEL_TextOut("\t VIDEO-1 ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
        }
        else {
                  GEL_TextOut("\t VIDEO-1 PLL NOT Configured.Wrong DCOCLK Output\n");
        }

}

cmdHDMIPLL(int CLKIN,int N, int M, int M2)
{
        DCOCLK_COMP(CLKIN,N,M);
        if(HSMODE == 2){
            PLL_Clocks_Config(HDMI_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS2+ADPLLJ_CLKCRTL_CLKDCO);
             GEL_TextOut("\t VIDEO-2/HDMI ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
        }
        else if (HSMODE == 1){
            PLL_Clocks_Config(HDMI_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS1+ADPLLJ_CLKCRTL_CLKDCO);
             GEL_TextOut("\t VIDEO-2/HDMI ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
        }
        else {
                  GEL_TextOut("\t VIDEO-2/HDMI PLL NOT Configured.Wrong DCOCLK Output\n");
        }

}

cmdDDRPLL(int CLKIN,int N, int M, int M2)
{
    DCOCLK_COMP(CLKIN,N,M);
    if(HSMODE == 2)
    {
        PLL_Clocks_Config(DDR_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS2);
        GEL_TextOut("\t DDR ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
    }
    else if (HSMODE == 1)
    {
        PLL_Clocks_Config(DDR_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS1);
        GEL_TextOut("\t DDR ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
    }
    else
    {
        GEL_TextOut("\t DDR PLL NOT Configured.Wrong DCOCLK Output\n");
    }
}

cmdAUDIOPLL(int CLKIN,int N, int M, int M2)
{
    DCOCLK_COMP(CLKIN,N,M);
    if(HSMODE == 2)
    {
        PLL_Clocks_Config(AUDIO_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS2);
        GEL_TextOut("\t AUDIO ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
    }
    else if (HSMODE == 1)
    {
        PLL_Clocks_Config(AUDIO_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS1);
        GEL_TextOut("\t AUDIO ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
    }
    else
    {
        GEL_TextOut("\t AUDIO PLL NOT Configured.Wrong DCOCLK Output\n");
    }
}
 menuitem "DM8148 INDIVIDUAL PLL Config"
//cmdxxxxPLL(int CLKIN,int N, int M, int M2)
hotmenu    MPU_PLL_CONFIG()
{
        GEL_TextOut("\t ****  DM8148 MPU ADPLL INIT IS in Progress ......... \n");
        cmdMPUPLL(CLKIN,1,60,1);

}

hotmenu L3_PLL_Config()
{
        GEL_TextOut("\t ****  DM8148 L3 ADPLL INIT IS in Progress ......... \n");
        cmdL3PLL(CLKIN,19, 800, 4);
        //GEL_TextOut("\t ****  DM8148 L3 ADPLL INIT IS Done ......... \n");
}

hotmenu DSS_PLL_Config()
{
         GEL_TextOut("\t ****  DM8148 DSS ADPLL INIT IS in Progress ......... \n");
           cmdDSSPLL(CLKIN,19, 600, 4);
           //GEL_TextOut("\t ****  DM8148 DSS ADPLL INIT IS Done ......... \n");
}

hotmenu SGX_PLL_Config(){
        GEL_TextOut("\t ****  DM8148 SGX ADPLL INIT IS in Progress ......... \n");
        cmdSGXPLL(CLKIN,19, 800, 4);
        //GEL_TextOut("\t ****  DM8148 SGX ADPLL INIT IS Done ......... \n");
}

hotmenu HDVICP_PLL_Config()
{
        GEL_TextOut("\t ****  DM8148 HDVICP ADPLL INIT IS in Progress ......... \n");
        cmdHDVICPPLL(CLKIN,19, 532, 2);
        //GEL_TextOut("\t ****  DM8148 HDVICP ADPLL INIT IS Done ......... \n");
}

hotmenu USB_PLL_Config()
{
        GEL_TextOut("\t ****  DM8148 USB ADPLL INIT IS in Progress ......... \n");
        cmdUSBPLL(CLKIN,19, 960 ,5);
        //GEL_TextOut("\t ****  DM8148 USB ADPLL INIT IS Done ......... \n");
}

hotmenu VIDEO_0_PLL_Config()
{
    GEL_TextOut("\t ****  DM8148 VIDEO-0 ADPLL INIT IS in Progress ......... \n");
    cmdVIDEO0PLL(CLKIN,19, 540,10);
    //GEL_TextOut("\t ****  DM8148 VIDEO-0 ADPLL INIT IS Done ......... \n");
}

hotmenu VIDEO_1_PLL_Config()
{
    GEL_TextOut("\t ****  DM8148 VIDEO-1 ADPLL INIT IS in Progress ......... \n");
    cmdVIDEO1PLL(CLKIN,19, 600,4);
    //GEL_TextOut("\t ****  DM8148 VIDEO-1 ADPLL INIT IS Done ......... \n");
}

hotmenu HDMI_PLL_Config()
{
    GEL_TextOut("\t ****  DM8148 HDMI ADPLL INIT IS in Progress ......... \n");
    cmdHDMIPLL(CLKIN,19, 1485,10);
    //GEL_TextOut("\t ****  DM8148 HDMI ADPLL INIT IS Done ......... \n");
}

hotmenu AUDIO_PLL_Config()
{
    GEL_TextOut("\t ****  DM8148 AUDIO ADPLL INIT IS in Progress ......... \n");
   cmdAUDIOPLL(CLKIN,19,800,4);
   //GEL_TextOut("\t ****  DM8148 AUDIO ADPLL INIT IS Done ......... \n");
}

hotmenu DDR_PLL_Config()
{
    GEL_TextOut("\t ****  DM8148 DDR ADPLL INIT IS in Progress ......... \n");
   cmdDDRPLL(CLKIN,19,DDR_FREQ, 2);
   //GEL_TextOut("\t ****  DM8148 DDR ADPLL INIT IS Done ......... \n");
}
hotmenu SATA_PLL_Config()
{
    GEL_TextOut("\t ****  DM8148 SATA PLL INIT IS In Progress ......... \n");
    cmdSATAPLL();
    GEL_TextOut("\t ****  DM8148 SATA PLL INIT IS DONE  ********* \n");

}

hotmenu PCIE_PLL_Config(){
    GEL_TextOut("\t ****  DM8148 PCIE PLL INIT IS In Progress ......... \n");
    cmdPCIEPLL();
    GEL_TextOut("\t ****  DM8148 PCIE PLL INIT IS DONE  ********* \n");

}

#define CM_SYSCLK18_CLKSRC                (CTRL_MODULE_BASE_ADDR + 0x020F)
#define CM_SYSCLK18_CLKSEL                (PRCM_BASE_ADDR + 0x0378)
#define CM_DMTIMER_CLKSRC                (CTRL_MODULE_BASE_ADDR + 0x02E0)

hotmenu TIMER_CLOCKS_Config()
{
    GEL_TextOut("\t ***** Initializing Timer-6....***** \n");

    WR_MEM_32(CM_SYSCLK18_CLKSEL, 0x1);
    WR_MEM_32(CM_SYSCLK18_CLKSRC, 0x1); /* Set clksrc to 32.768 MHz, Lock Bit? */

    WR_MEM_32(CM_DMTIMER_CLKSRC, RD_MEM_32(CM_DMTIMER_CLKSRC) & 0xFE3FFFFF); /* Selected sysclk18 */

    WR_MEM_32(CM_TIMER6_CLKSEL, 0x1);

    WR_MEM_32(CM_ALWON_TIMER_6_CLKCTRL,    0x2); /* Enable Timer-6 Clock */
    while((RD_MEM_32(CM_ALWON_TIMER_6_CLKCTRL) & 0x0F) !=0x2);        /* Poll for Module is functional */

    WR_MEM_32(PINCNTL115, 0x00010040);
    GEL_TextOut("\t ***** Timer-6 Initialized....***** \n");
}

//PLL program sequence to get 125Mhz ethernet clockout.
cmdSATAPLL()
{
  GEL_TextOut("\t **** SATA PLL INIT IS In Progress Please wait ..... \n");
  WR_MEM_32(SATA_PLLCFG0, 0x00000004);    //cfgpll0
  wait_delay(35);
  WR_MEM_32(SATA_PLLCFG1, 0xC12C003C);    //cfgpll1
  WR_MEM_32(SATA_PLLCFG3, 0x004008E0);    //cfgpll3
  wait_delay(850);
   //wait for bias to be stable --50us
  WR_MEM_32(SATA_PLLCFG0, 0x00000014);    //cfgpll0
  wait_delay(850);
  WR_MEM_32(SATA_PLLCFG0, 0x00000016);    //cfgpll0
  wait_delay(60);
  WR_MEM_32(SATA_PLLCFG0, 0xC0000016);    //cfgpll0 -----why 2 times???????
  wait_delay(2000);
  WR_MEM_32(SATA_PLLCFG0, 0xC0000017);    //cfgpll0
 //poll the status field to check if pll lock occured.
  while ((RD_MEM_32(SATA_PLLSTATUS) & 0x1) != 0x1);
  GEL_TextOut("\t **** SATA PLL INIT IS In DONE ***************** \n");

}


//PLL program sequence to get 125Mhz ethernet clockout.
hotmenu cmdSATAPLL_Debug()
{
  GEL_TextOut("\t **** SATA PLL INIT IS In Progress Please wait ..... \n");
  //WR_MEM_32(SATA_PLLCFG0, 0x00000004);    //cfgpll0
  //wait_delay(35);
  WR_MEM_32(SATA_PLLCFG1, 0xC12C003C);    //cfgpll1
  wait_delay(35);
  WR_MEM_32(SATA_PLLCFG3, 0x004008E0);    //cfgpll3
  wait_delay(850);
   //wait for bias to be stable --50us
  WR_MEM_32(SATA_PLLCFG0, 0x00000004);    //cfgpll0
  wait_delay(850);
  WR_MEM_32(SATA_PLLCFG0, 0x00000014);    //cfgpll0
  wait_delay(850);
  WR_MEM_32(SATA_PLLCFG0, 0xC0000016);    //cfgpll0 -----why 2 times???????
  wait_delay(850);
  WR_MEM_32(SATA_PLLCFG0, 0xC0000017);    //cfgpll0
 //poll the status field to check if pll lock occured.
  while ((RD_MEM_32(SATA_PLLSTATUS) & 0x1) != 0x1);
  GEL_TextOut("\t **** SATA PLL INIT IS In DONE ***************** \n");

}

//pci express pll sequence
cmdPCIEPLL()
{
    GEL_TextOut("\t **** PCIE PLL INIT IS In Progress Please wait ..... \n");
    WR_MEM_32(SERDES_REFCLK_CTL,0x00000002); //PowerDown 0x00000000-DM8148
    WR_MEM_32(PCIE_PLLCFG0,0x00000000); //cfgpll0
    WR_MEM_32(PCIE_PLLCFG1,0x00640000); //cfgpll1
    WR_MEM_32(PCIE_PLLCFG2,0x00000000); //cfgpll2
    WR_MEM_32(PCIE_PLLCFG3,0x004008E0); //cfgpll3
    WR_MEM_32(PCIE_PLLCFG4,0x0000609C); //cfgpll4

    //WR_MEM_32(0x48141318,0x00000E7B); //pcie_serdes_cfg_misc DM8148 commented
    wait_delay(3); // Wait 100 ns
    WR_MEM_32(PCIE_PLLCFG0,0x00000004); //Config PLL CFG0 bit [2] - ENBGSC_REF
    wait_delay(3); // Wait 250 ns
    WR_MEM_32(PCIE_PLLCFG0,0x00000014); //Config PLL CFG0 bit [4] - DIGLDO
    wait_delay(3); // Wait 200 ns
    WR_MEM_32(PCIE_PLLCFG0,0x00000016); //Config PLL CFG0 bit [1] - ENPLLLDO
    wait_delay(3); // Wait 200 ns
    WR_MEM_32(PCIE_PLLCFG0,0x30000016); // Configure proxy TXLDO and RXLDO enables (DM8148 ECO 3/30/10)
    wait_delay(3); // Wait 200 ns
    WR_MEM_32(PCIE_PLLCFG0,0x70007016); // Configure multiplier
    wait_delay(3); // Wait 200 ns
    WR_MEM_32(PCIE_PLLCFG0,0x70007017);  // Enable PLL
    wait_delay(3); // Wait 200 ns
     //poll the status field to check if pll lock occured.
    while ((RD_MEM_32(PCIE_PLLSTATUS) & 0x1 )!= 0x1);
    GEL_TextOut("\t **** PCIE PLL INIT IS In DONE ***************** \n");
}

wait_delay(UWORD32 noopcount)
{
    int i;
    for(i=0;i<noopcount;i++)
    {
    }
}

PLL_Clocks_Config(UWORD32 Base_Address,UWORD32 CLKIN,UWORD32 N,UWORD32 M,UWORD32 M2,UWORD32 CLKCTRL_VAL)
{
    UWORD32 m2nval,mn2val,read_clkctrl,clk_out,ref_clk,clkout_dco = 0;
    m2nval = (M2<<16) | N;
    mn2val =  M;
    ref_clk     = CLKIN/(N+1);
    clkout_dco  = ref_clk*M;
    clk_out     = clkout_dco/M2;
    WR_MEM_32(Base_Address+CLKCTRL, RD_MEM_32(Base_Address+CLKCTRL)|0x00800000);
    while (( (RD_MEM_32(Base_Address+STATUS)) & 0x00000101) != 0x00000101);
    WR_MEM_32(Base_Address+CLKCTRL, RD_MEM_32(Base_Address+CLKCTRL)& 0xfffffffe);
    wait_delay(3);
    WR_MEM_32((Base_Address+M2NDIV    ),m2nval);
    WR_MEM_32((Base_Address+MN2DIV    ),mn2val);
    wait_delay(3);
    WR_MEM_32((Base_Address+TENABLEDIV),0x1);
    wait_delay(3);
    WR_MEM_32((Base_Address+TENABLEDIV),0x0);
    wait_delay(3);
    WR_MEM_32((Base_Address+TENABLE   ),0x1);
    wait_delay(3);
    WR_MEM_32((Base_Address+TENABLE   ),0x0);
    wait_delay(3);
    read_clkctrl = RD_MEM_32(Base_Address+CLKCTRL);
    //configure the TINITZ(bit0) and CLKDCO BITS IF REQUIRED
    WR_MEM_32(Base_Address+CLKCTRL,(read_clkctrl & 0xff7fe3ff) | CLKCTRL_VAL);
    read_clkctrl = RD_MEM_32(Base_Address+CLKCTRL);
    // poll for the freq,phase lock to occur
    while (( (RD_MEM_32(Base_Address+STATUS)) & 0x00000600) != 0x00000600);
    //wait fot the clocks to get stabized
    wait_delay(10);
    CLKOUT    = clk_out;
}

A8_PLL_Config(UWORD32 CLKIN,UWORD32 N,UWORD32 M,UWORD32 M2)
{
    UWORD32 rval_ctrl,ref_clk,clk_out = 0;
    UWORD32 m2nval,mn2val = 0;
    ref_clk     = CLKIN/(N+1);
    clk_out     = (ref_clk*M)/M2;

    m2nval = (M2<<16) | N; //need to check the bit position of M2
    mn2val =  M;
    WR_MEM_32(A8PLL_M2NDIV      ,m2nval);
    WR_MEM_32(A8PLL_MN2DIV      ,mn2val);
    WR_MEM_32(A8PLL_TENABLEDIV  ,0x1);
    wait_delay(3);
    WR_MEM_32(A8PLL_TENABLEDIV  ,0x0);
    wait_delay(3);
    WR_MEM_32(A8PLL_TENABLE     ,0x1);
    wait_delay(3);
    WR_MEM_32(A8PLL_TENABLE     ,0x0);
    wait_delay(3);
    rval_ctrl = RD_MEM_32(A8PLL_CLKCTRL);
    WR_MEM_32(A8PLL_CLKCTRL,(rval_ctrl & 0xff7fffff) | 0x1);
    while (( (RD_MEM_32(A8PLL_STATUS)) & 0x00000600) != 0x00000600);
    wait_delay(10);
    CLKOUT = clk_out;
}

DCOCLK_COMP(int CLKIN,int N, int M)
{
    int DCOCLK;
    DCOCLK = (CLKIN/(N+1))*M;

    if(DCOCLK >= 500 && DCOCLK < 1000){
            HSMODE = 2;  //HS2 Mode
    }
    else if(DCOCLK >= 1000 && DCOCLK < 2000){
            HSMODE = 1;  //HS1 Mode
    }
    else HSMODE = 0;  //wrong configuration

    //return HSMODE;
}

ControlModule_ClkEnable()
{
    GEL_TextOut("\tPRCM for Control Module in Progress \n");
    /*Enable the  Clocks*/
    WR_MEM_32(CM_CTRL_CLKCTRL,   2);
    while(((RD_MEM_32(CM_CTRL_CLKCTRL)&0x2))!=0x2);
    GEL_TextOut("\tPRCM for Control Module Done \n");
}

PrcmAlwayOnClkEnable()
{
    unsigned int fail=0, k=0;
    GEL_TextOut("\tPRCM for OCMCRAM0/1 Initialization in Progress \n");
    /*Enable the OCMC0RAM Clocks*/
    WR_MEM_32(CM_ALWON_OCMC_0_CLKSTCTRL, 2);
    WR_MEM_32(CM_ALWON_OCMC_0_CLKCTRL,   2);
    while(((RD_MEM_32(CM_ALWON_OCMC_0_CLKSTCTRL) & 0x100)>>8)!=1);
    while(((RD_MEM_32(CM_ALWON_OCMC_0_CLKCTRL)&0x30000)>>17)!=0);
    GEL_TextOut("\tPRCM for OCMCRAM0 Initialization Done \n");


    /*
    for(k=0; k<SIZE; k++)
    {
      WR_MEM_32(OCMC0RAM_BASE_ADDR+4*k, 0x12345678+k);
    }
    for(k=0;  k<SIZE; k++)
    {
      if(RD_MEM_32(OCMC0RAM_BASE_ADDR+4*k) != (0x12345678+k) )
      {
        fail++;
      }
    }

    if(fail!=0)
    {
      GEL_TextOut("\tOCMCRAM0 Accesses FAILED \n");
    }

    GEL_TextOut("\tOCMCRAM0 Accesses PASSED \n");
    */
}

/************ Enable the Ducati Clocks ***************/
DucatiClkEnable()
{
    int i;
    GEL_TextOut("\tPRCM for DucatiSS is in Progress ..... \n");
    //while(RD_MEM_32(CM_DEFAULT_DUCATI_CLKSTCTRL)!=0x1);
    //GEL_TextOut("\tPRCM for DucatiSS is in Progress  \n");
    GEL_TextOut("Tests Executed: %x \n",,,,,*(unsigned int *)CM_DEFAULT_DUCATI_CLKSTCTRL);
    WR_MEM_32(RM_DEFAULT_RSTCTRL,   0xEF); /*Enable the Ducati Logic*/
    WR_MEM_32(CM_DEFAULT_DUCATI_CLKSTCTRL, 2); /*Enable Power Domain Transition*/
    WR_MEM_32(CM_DEFAULT_DUCATI_CLKCTRL,   2); /*Enable Ducati Clocks*/

    /*Check CLKIN200TR & CLKINTR  are active*/
    while(((RD_MEM_32(CM_DEFAULT_DUCATI_CLKSTCTRL)&0x300)>>8)!=3) ;
    GEL_TextOut("\t   Clock is Active  \n");

    //----------------------WR_MEM_32(RM_DEFAULT_RSTCTRL,   0xEF); /*Enable the Ducati Logic*/
    //WR_MEM_32(RM_DEFAULT_RSTCTRL,   0xE3); /*Enable the Ducati Logic*/
    GEL_TextOut("Tests Executed: %x \n",,,,,*(unsigned int *)RM_DEFAULT_RSTCTRL);
    GEL_TextOut("Tests Executed: %x \n",,,,,*(unsigned int *)RM_DEFAULT_RSTST);
    //  for(i=0;i<100;i++);
    //    GEL_TextOut("\tDelay gone  \n");
    /*Write Ducate IRAM Boot Image */
    //  GEL_TextOut("\tAfter RAM written  \n");

    /*Large Page Translations */
    WR_MEM_32(DUCATI_MMU_CFG+0x800,         0x60000000);
    WR_MEM_32(DUCATI_MMU_CFG+0x804,         0x40000000);
    WR_MEM_32(DUCATI_MMU_CFG+0x808,         0x80000000);
    WR_MEM_32(DUCATI_MMU_CFG+0x80C,         0xC0000000);

    WR_MEM_32(DUCATI_MMU_CFG+0x820,         0x60000000);
    WR_MEM_32(DUCATI_MMU_CFG+0x824,         0x40000000);
    WR_MEM_32(DUCATI_MMU_CFG+0x828,         0x80000000);
    WR_MEM_32(DUCATI_MMU_CFG+0x82C,         0xC0000000);

    WR_MEM_32(DUCATI_MMU_CFG+0x840,         0x00020007);
    WR_MEM_32(DUCATI_MMU_CFG+0x844,         0x00000007);
    WR_MEM_32(DUCATI_MMU_CFG+0x848,         0x00030007);
    WR_MEM_32(DUCATI_MMU_CFG+0x84C,         0x00000007);

    /*Medium Page*/
    WR_MEM_32(DUCATI_MMU_CFG+0x860,         0x00300000);
    WR_MEM_32(DUCATI_MMU_CFG+0x864,         0x00400000);
    //WR_MEM_32(DUCATI_MMU_CFG+0x868,       0x00000000);
    //WR_MEM_32(DUCATI_MMU_CFG+0x86C,       0x00000000);

    WR_MEM_32(DUCATI_MMU_CFG+0x8A0,         0x40300000);
    WR_MEM_32(DUCATI_MMU_CFG+0x8A4,         0x40400000);
    //WR_MEM_32(DUCATI_MMU_CFG+0x8A8,       0x00000000);
    //WR_MEM_32(DUCATI_MMU_CFG+0x8AC,       0x00000000);

    WR_MEM_32(DUCATI_MMU_CFG+0x8E0,       0x00000007);
    WR_MEM_32(DUCATI_MMU_CFG+0x8E4,       0x00020007);
    //WR_MEM_32(DUCATI_MMU_CFG+0x8E8,         0x00000000);
    //WR_MEM_32(DUCATI_MMU_CFG+0x8EC,         0xC0000000);

    /*Small Page*/

    WR_MEM_32(DUCATI_MMU_CFG+0x920,       0x00000000);
    WR_MEM_32(DUCATI_MMU_CFG+0x924,       0x40000000);
    WR_MEM_32(DUCATI_MMU_CFG+0x928,       0x00004000);
    WR_MEM_32(DUCATI_MMU_CFG+0x92C,       0x00008000);
    WR_MEM_32(DUCATI_MMU_CFG+0x930,       0x0000C000);

    WR_MEM_32(DUCATI_MMU_CFG+0x9A0,       0x55020000);
    WR_MEM_32(DUCATI_MMU_CFG+0x9A4,       0x55080000);
    WR_MEM_32(DUCATI_MMU_CFG+0x9A8,       0x55024000);
    WR_MEM_32(DUCATI_MMU_CFG+0x9AC,       0x55028000);
    WR_MEM_32(DUCATI_MMU_CFG+0x9B0,       0x5502C000);

    WR_MEM_32(DUCATI_MMU_CFG+0xA20,       0x0001000B);
    WR_MEM_32(DUCATI_MMU_CFG+0xA24,       0x0000000B);
    WR_MEM_32(DUCATI_MMU_CFG+0xA28,       0x00010007);
    WR_MEM_32(DUCATI_MMU_CFG+0xA2C,       0x00000007);
    WR_MEM_32(DUCATI_MMU_CFG+0xA30,       0x00000007);

    WR_MEM_32(DUCATI_BASE_ADDR,       0x10000);
    WR_MEM_32(DUCATI_BASE_ADDR+0x4,   0x9);
    WR_MEM_32(DUCATI_BASE_ADDR+0x8,   0xE7FEE7FE);


    GEL_TextOut("\tDUCATI MMU has been written  \n");

    WR_MEM_32(RM_DEFAULT_RSTCTRL,   0xE3); //0xE3

    /*Check for Ducati M3_0 & M3_1 out of Reset*/
    while(((RD_MEM_32(RM_DEFAULT_RSTST)&0x1C))!=0x1C) ;
    //GEL_TextOut("\tDucati is out of Reset\n");

    /*Check Module is in Functional Mode */
    while(((RD_MEM_32(CM_DEFAULT_DUCATI_CLKCTRL)&0x30000)>>16)!=0) ;

    GEL_TextOut("\tPRCM for DucatiSS is Done Successfully ******** \n");
}

HDVICPClkEnable()
{
    GEL_TextOut("\tPRCM for HDVICP is in Progress, Please wait.....  \n");
    WR_MEM_32(CM_HDVICP_CLKSTCTRL,         2); /*Enable Power Domain Transition*/
    while(RD_MEM_32(PM_HDVICP_PWRSTST)!=0x37);    /*Check Power is ON*/
    WR_MEM_32(CM_HDVICP_CLKCTRL,     2); /*Enable HDVICP Clocks*/
    WR_MEM_32(CM_HDVICP_SL2_CLKCTRL,     2); /*Enable HDVICP SL2 Clocks*/

    while(((RD_MEM_32(CM_HDVICP_CLKSTCTRL)&0x100))!=0x100); /*HDVICP_GCLK is Active*/

    WR_MEM_32(RM_HDVICP_RSTCTRL,     3); /*Enable HDVICP logic & SL2 */

    while((RD_MEM_32(RM_HDVICP_RSTST)&4)!=4);

    WR_MEM_32(0x58088000, 0xEAFFFFFE); /*Write Self Branch Instruction in ICONT1 ITCM 0 Location*/

    WR_MEM_32(0x58098000, 0xEAFFFFFE); /*Write Self Branch Instruction in ICONT2 ITCM 0 Location*/

    WR_MEM_32(RM_HDVICP_RSTCTRL,     0); /*Bring ICONT1 & ICONT2 out of Reset*/

    while(RD_MEM_32(RM_HDVICP_RSTST)!=7); /*ICONT1 & ICONT2 are out of Reset*/

    GEL_TextOut("\tPRCM for HDVICP is Done Successfully  \n");
    GEL_TextOut("\tUser Can Connect to ICONT1 & ICONT2 of HDVICP  \n");
}

C674xClkEnable()
{
    unsigned int i=0, k=0, fail=0;

    GEL_TextOut("\tPRCM for C674x is in Progress, Please wait.....  \n",,1,1,1);

    /*Cortex A8 must be in Supervisor Mode to Access the following two registers*/
    WR_MEM_32(DSPBOOTADDR,             0x00800000); /*DSPBOOT ADDRESS*/

    GEL_TextOut("\t CP0...Done \n");

    /*Enable Clock to MMU CFG*/
    WR_MEM_32(CM_MMUCFG_CLKSTCTRL,         2);
    WR_MEM_32(CM_ALWON_MMUCFG_CLKCTRL,         2);
    while(((RD_MEM_32(CM_ALWON_MMUCFG_CLKCTRL)&0x0))!=0x0);
    while(((RD_MEM_32(CM_MMUCFG_CLKSTCTRL)&0x100))!=0x100);

    GEL_TextOut("\t CP1...Done \n");

    /*Enable Clock to Data*/
    WR_MEM_32(CM_MMU_CLKSTCTRL,         2);
    WR_MEM_32(CM_ALWON_MMUDATA_CLKCTRL,         2);
    while(((RD_MEM_32(CM_ALWON_MMUDATA_CLKCTRL)&0x0))!=0x0);
    while(((RD_MEM_32(CM_MMU_CLKSTCTRL)&0x100))!=0x100);

    GEL_TextOut("\t CP2...Done \n");

    /*Enable Clock to C674x*/
    WR_MEM_32(CM_C674x_CLKSTCTRL,         2); /*Enable Power Domain Transition*/
    while(RD_MEM_32(PM_ACTIVE_PWRSTST)!=0x37);    /*Check Power is ON*/
    WR_MEM_32(CM_ACTIVE_C674x_CLKCTRL,     2); /*Enable C674x Clocks*/

    GEL_TextOut("\t CP3...Done \n");

    while(((RD_MEM_32(CM_C674x_CLKSTCTRL)&0x700))!=0x700); /*C674x Clocks are Active*/

    WR_MEM_32(RM_ACTIVE_RSTCTRL,     1); /*Issue C674x Warm Reset To access C674x memories */

    while(((RD_MEM_32(RM_ACTIVE_RSTST)&0x2))!=0x2); /*C674x Warm Reset has been Asserted*/

    GEL_TextOut("\t CP4...Done \n");

    for(i=0; i<8; i++) {
      WR_MEM_32((C674x_L2RAM_BASE_ADDR+4*i), 0x12); /*Write Self Branch Instruction*/
    }

    GEL_TextOut("\t CP5...Done \n");

    WR_MEM_32(RM_ACTIVE_RSTCTRL,     0); /*Bring C674x Core out of Reset*/

    while(((RD_MEM_32(RM_ACTIVE_RSTST)&0x3))!=0x3); /*C674x core core is out of Reset*/

    GEL_TextOut("\t CP6...Done \n");

    /*
    for(k=0; k<SIZE; k++)
    {
      WR_MEM_32(C674x_L2RAM_BASE_ADDR+0x100+4*k, 0x12345678+k);
    }

    GEL_TextOut("\t CP7...Done");

    for(k=0;  k<SIZE; k++)
    {
      if(RD_MEM_32(C674x_L2RAM_BASE_ADDR+0x100+4*k) != (0x12345678+k) )
      {
        fail++;
      }
    }
    if(fail!=0)
    {
      GEL_TextOut("\tC674x L2 RAM Accesses are FAILED \n");
      GEL_TextOut("\tPRCM for C674x is Failed  \n");
      GEL_TextOut("\tDebug the Failed Scenario   \n");
    }

    GEL_TextOut("\tC674x L2 RAM Accesses are PASSED \n");
    GEL_TextOut("\tPRCM for C674x is Done Successfully  \n");
    */

    GEL_TextOut("\tUser Can Connect to C674x   \n");
    GEL_TextOut("\tPRCM for C674x is DONE ******  \n");
}


GPMC_ClkEnable()
{
    unsigned int i,data_fail = 0;
    GEL_TextOut("\tEnabling Clock for GPMC is in Progress, Please wait.....  \n");
    WR_MEM_32(CM_ALWON_GPMC_CLKCTRL,    0x2); /*Enable GPMC Clock*/
    while(RD_MEM_32(CM_ALWON_GPMC_CLKCTRL)!=0x2);
    GEL_TextOut("\tGPMC Clock is Active\n");

}

hotmenu Ethernet_PinMux_Setup()
{
    GEL_TextOut("\t ***** Configuring ethernet Clk and Mux....***** \n");
    /*
    PINCNTL232 :- rmii_refClk            [40001]
    PINCNTL233 :- rmdio_mclk            [A0001]
    PINCNTL234 :- mdio_d                [E0001]
    */

    /* PIN MUX for EMAC0 */

    WR_MEM_32(PINCNTL232, 0x00040001);
    WR_MEM_32(PINCNTL233, 0x000E0001);
    WR_MEM_32(PINCNTL234, 0x000E0001);

    WR_MEM_32(PINCNTL235, 0x000C0001);
    WR_MEM_32(PINCNTL236, 0x000C0001);
    WR_MEM_32(PINCNTL237, 0x000C0001);
    WR_MEM_32(PINCNTL238, 0x000C0001);
    WR_MEM_32(PINCNTL239, 0x000C0001);
    WR_MEM_32(PINCNTL240, 0x00040001);
    WR_MEM_32(PINCNTL241, 0x00040001);
    WR_MEM_32(PINCNTL242, 0x00040001);
    WR_MEM_32(PINCNTL243, 0x00040001);
    WR_MEM_32(PINCNTL244, 0x00040001);
    WR_MEM_32(PINCNTL245, 0x00040001);
    WR_MEM_32(PINCNTL246, 0x00040001);
    WR_MEM_32(PINCNTL247, 0x00040001);
    WR_MEM_32(PINCNTL248, 0x00040001);
    WR_MEM_32(PINCNTL249, 0x00000001);
    WR_MEM_32(PINCNTL250, 0x00000001);
    WR_MEM_32(PINCNTL251, 0x00000001);
    WR_MEM_32(PINCNTL252, 0x00000001);
    WR_MEM_32(PINCNTL253, 0x00000001);
    WR_MEM_32(PINCNTL254, 0x00000001);
    WR_MEM_32(PINCNTL255, 0x00000001);
    WR_MEM_32(PINCNTL256, 0x00000001);
    WR_MEM_32(PINCNTL257, 0x00000001);
    WR_MEM_32(PINCNTL258, 0x00000001);

    /* PIN MUX for EMAC1 */
    WR_MEM_32(PINCNTL204, 0x000C0002);
    WR_MEM_32(PINCNTL205, 0x000C0002);
    WR_MEM_32(PINCNTL206, 0x000C0002);
    WR_MEM_32(PINCNTL207, 0x000C0002);
    WR_MEM_32(PINCNTL208, 0x00040002);
    WR_MEM_32(PINCNTL209, 0x00040002);
    WR_MEM_32(PINCNTL210, 0x00040002);
    WR_MEM_32(PINCNTL211, 0x00040002);
    WR_MEM_32(PINCNTL212, 0x00040002);
    WR_MEM_32(PINCNTL213, 0x00040002);
    WR_MEM_32(PINCNTL214, 0x00040002);
    WR_MEM_32(PINCNTL215, 0x00040002);
    WR_MEM_32(PINCNTL216, 0x00040002);
    WR_MEM_32(PINCNTL217, 0x00040002);
    WR_MEM_32(PINCNTL218, 0x00000002);
    WR_MEM_32(PINCNTL219, 0x00000002);
    WR_MEM_32(PINCNTL220, 0x00000002);
    WR_MEM_32(PINCNTL221, 0x00000002);
    WR_MEM_32(PINCNTL222, 0x00000002);
    WR_MEM_32(PINCNTL223, 0x00000002);
    WR_MEM_32(PINCNTL224, 0x00000002);
    WR_MEM_32(PINCNTL225, 0x00000002);
    WR_MEM_32(PINCNTL226, 0x00000002);
    WR_MEM_32(PINCNTL227, 0x00000002);

    WR_MEM_32(CM_ALWON_ETHERNET_CLKSTCTRL,    0x2); /* Enable Ethernet Clock*/
    while((RD_MEM_32(CM_ALWON_ETHERNET_CLKSTCTRL) & 0x0F) !=0x2);        /*Poll for Module is functional*/

    WR_MEM_32(CM_ALWON_ETHERNET_0_CLKCTRL,    0x2); /*Enable Ethernet Clock*/
    while((RD_MEM_32(CM_ALWON_ETHERNET_0_CLKCTRL) & 0x0F) !=0x2);        /*Poll for Module is functional*/

    WR_MEM_32(CM_ALWON_ETHERNET_1_CLKCTRL,    0x2); /*Enable Ethernet Clock*/
    while((RD_MEM_32(CM_ALWON_ETHERNET_1_CLKCTRL) & 0x0F) !=0x2);        /*Poll for Module is functional*/

    while(RD_MEM_32(CM_ALWON_ETHERNET_CLKSTCTRL)!=0x302);        /*Poll for Module is functional*/

    GEL_TextOut("\t ***** GMII pin mux and Clk initialized....***** \n");
}

hotmenu SPI_Setup()
{
    GEL_TextOut("\tPRCM for SPI-0 CS-0 is in Progress, Please wait.....  \n");

    WR_MEM_32(PINCNTL81, 0x00060001);      /* SPI0-CS[0] */
    WR_MEM_32(PINCNTL82, 0x00060001);      /* SPI0-SCLK */
    WR_MEM_32(PINCNTL83, 0x00060001);      /* SPI0-D0 */
    WR_MEM_32(PINCNTL84, 0x00060001);      /* SPI0-D1 */

    WR_MEM_32(CM_ALWON_SPI_0_CLKSTCTRL,    0x2); /*Enable UART0 Clock*/
    while(RD_MEM_32(CM_ALWON_SPI_0_CLKSTCTRL)!=0x2);        /*Poll for Module is functional*/

    GEL_TextOut("\t ***** SPI-0 CS-0 is initialized....***** \n");

}

hotmenu SD_MMC0_Setup()
{
    GEL_TextOut("\tPRCM for SD/MMC0 are in Progress, Please wait.....  \n");

    WR_MEM_32(PINCNTL1, 0x00050001);
    WR_MEM_32(PINCNTL2, 0x00060001);
    WR_MEM_32(PINCNTL3, 0x00060001);
    WR_MEM_32(PINCNTL4, 0x00060001);
    WR_MEM_32(PINCNTL5, 0x00060001);
    WR_MEM_32(PINCNTL6, 0x00060001);

    WR_MEM_32(CM_ALWON_MMC_HS_1_CLKSTCTRL,    0x2); /*Enable UART0 Clock*/
    while(RD_MEM_32(CM_ALWON_MMC_HS_1_CLKSTCTRL)!=0x2);        /*Poll for Module is functional*/

    GEL_TextOut("\t ***** MMC0/SD is initialized....***** \n");

}

UARTClkEnable()
{
    GEL_TextOut("\tPRCM for UART0, UART1, and UART2 are in Progress, Please wait.....  \n");

    WR_MEM_32(CM_ALWON_L3_SLOW_CLKSTCTRL, 0x2); /*Enable the Power Domain Transition of L3 Slow Domain Peripheral*/

    WR_MEM_32(CM_ALWON_UART_0_CLKCTRL,    0x2); /*Enable UART0 Clock*/
    while(RD_MEM_32(CM_ALWON_UART_0_CLKCTRL)!=0x2);

    WR_MEM_32(CM_ALWON_UART_1_CLKCTRL,    0x2); /*Enable UART1 Clock*/
    while(RD_MEM_32(CM_ALWON_UART_1_CLKCTRL)!=0x2);

    WR_MEM_32(CM_ALWON_UART_2_CLKCTRL,    0x2); /*Enable UART2 Clock*/
    while(RD_MEM_32(CM_ALWON_UART_2_CLKCTRL)!=0x2);

    while(RD_MEM_32(CM_ALWON_L3_SLOW_CLKSTCTRL) & 0x2100 !=0x2100);

    GEL_TextOut("\tPRCM for UART0, UART1, and UART2 are Done Successfully.....  \n");
}

Unlock_PLL_Control_MMR()
{
    WR_MEM_32(control_pllss_mmr_lock,control_pllss_mmr_lock_unlock_val);
    WR_MEM_32(control_mmr_lock0,control_mmr_lock0_unlock_val);
    WR_MEM_32(control_mmr_lock1,control_mmr_lock1_unlock_val);
    WR_MEM_32(control_mmr_lock2,control_mmr_lock2_unlock_val);
    WR_MEM_32(control_mmr_lock3,control_mmr_lock3_unlock_val);
    WR_MEM_32(control_mmr_lock4,control_mmr_lock4_unlock_val);
    GEL_TextOut("\n PLL and Control MMR unlock done ... \n");
}

mmr_unlock()
{
    *(unsigned int *)0x481C504c |= 0x06000000;
    *(unsigned int *)0x481C5040 = 0x1EDA4C3D;
    *(unsigned int *)0x48140060 = 0x2FF1AC2B;
    *(unsigned int *)0x48140064 = 0xF757FDC0;
    *(unsigned int *) 0x48140068 = 0xE2BC3A6D;
    *(unsigned int *)0x4814006c = 0x1EBF131D;
    *(unsigned int *)0x48140070 = 0x6F361E05;
    GEL_TextOut("\tInitialized Successfully.....  \n");
}

emac_clkenable()
{
    GEL_TextOut("CONFIGURE PRCM CLOCKS of EMAC in progress \n\r");
    *((unsigned int*)(0x48181404)) = 0x2;
    *((unsigned int*)(0x481815d4)) = 0x2;
    while(RD_MEM_32(0x48181404)!=0x0302);
    while((RD_MEM_32(0x481815d4)&0x2)!=0x2);
    GEL_TextOut("PRCM CLOCKS of EMAC  is complete \n\r");
}

Clockout_Enable()
{
    //*(unsigned int *)0x481402e4 =0 ;             // clkout0,1 selection
    *(unsigned int *)0x481C52e4 =0;
    *(unsigned int *)0x481409f8 =0x10 ;   // clkout1
    *(unsigned int *)0x48140c08 =0x4 ;     //clkout0
    *(unsigned int *)0x48180100 = ( (CLKOUT2EN << 7) | (CLKOUT2DIV << 3) | (CLKOUT2SRC << 0) );
    GEL_TextOut("\tDM8148 clkout done.... \n");
}

DSSClkEnable()
{
    *(unsigned int *)0x48180E10 =0;
    GEL_TextOut("\tPower Enabled.....  \n");
    /* Enabling DSS Clocks */
    *(unsigned int *)0x48180800=2 ;
    wait_delay(200);
    *(unsigned int *)0x48180820=2 ;
    wait_delay(200);
    *(unsigned int *)0x48180824=2 ;
    wait_delay(200);

    GEL_TextOut("\tPRCM for DSS in Progress, Please wait.....  \n");
    while ( (*(unsigned int *)0x48180800 & 0x100) != 0x100)
    {
    }

    /*Deasserting resets */

    *(unsigned int *)0x48180E10 =0;
    GEL_TextOut("\tPRCM for DSS Done Successfully.....  \n");
}

MLBClkEnable()
{
    GEL_TextOut("\tPRCM for MLB is in Progress, Please wait.....  \n");

    WR_MEM_32(CM_ALWON_L3_SLOW_CLKSTCTRL, 0x2); /*Enable the Power Domain Transition of L3 Slow Domain Peripheral*/

    WR_MEM_32(CM_ALWON_TIMER_2_CLKCTRL, 0x2); /*Enable MLB Clk domain */
    while(RD_MEM_32(CM_ALWON_TIMER_2_CLKCTRL) != 0x2);
    //while(((RD_MEM_32(CM_ALWON_MLB_CLKCTRL)) & (0x3 << 16)) != 0);
    GEL_TextOut("\t1st while loop done...\n");

    /*Ensure the Clk domains are fully functional */

    /* SHB Clk */
    while(RD_MEM_32(CM_ALWON_L3_SLOW_CLKSTCTRL) & 0x100 != 0x100);
    GEL_TextOut("\t 2nd while loop done...\n");

    /* SPB and SYS Clk Domain */
    while(RD_MEM_32(CM_ALWON_SYSCLK5_CLKSTCTRL) & 0x100 != 0x100);
    GEL_TextOut("\t 3rd while loop done ... \n");
    // mlb data pin mux
    WR_MEM_32(PINCNTL60, 0x00040001);
/* 0000 0000 0000 0100 0000 0000 0000 0001*/
    // mlb sig pin mux
    WR_MEM_32(PINCNTL59, 0x00040001);

    GEL_TextOut("\tPRCM for MLB has been done successfully.\n");
}

DCANClkEnable()
{
    GEL_TextOut("\tPRCM for DCAN is in Progress, Please wait.....  \n");

    WR_MEM_32(CM_ALWON_L3_SLOW_CLKSTCTRL, 0x2); /*Enable the Power Domain Transition of L3 Slow Domain Peripheral*/

    WR_MEM_32(CM_ALWON_DCAN_0_1_CLKCTRL, 0x2); /*Enable DCAN Clk domain */
    while(RD_MEM_32(CM_ALWON_DCAN_0_1_CLKCTRL) != 0x2);
    // DCAN0 RX pin mux
    WR_MEM_32(PINCNTL69, 0x00040001);
    // DCAN0 TX pin mux
    //    WR_MEM_32(PINCNTL68, 0x00000001);
    // DCAN1 RX pin mux, func4
    //    WR_MEM_32(PINCNTL73, 0x00040008);
    // DCAN1 TX pin mux, func4
    WR_MEM_32(PINCNTL72, 0x00000008);
    GEL_TextOut("\t1st while loop done...\n");

    GEL_TextOut("\tPRCM for DCAN has been done successfully.\n");
}


/*******************************************************************************************************
                   EMIF/DDR FUNCTIONS
*******************************************************************************************************/

cmd_DDR2_EMIF0_EMIF1_Config(UWORD32 ddr2_phy_rd_dqs_cs0_arg,UWORD32 ddr2_phy_wr_dqs_cs0_arg,UWORD32 ddr2_phy_fifo_we_cs0_arg,UWORD32 ddr2_phy_wr_data_cs0_arg,UWORD32 ddr2_emif_read_latency_arg,UWORD32 ddr2_emif_tim1_arg,UWORD32 ddr2_emif_tim2_arg,UWORD32 ddr2_emif_tim3_arg,UWORD32 ddr2_emif_ref_ctrl_arg,UWORD32 ddr2_emif_sdram_config_arg)
{

    GEL_TextOut("\EMIF PRCM is in progress ....... \n");
    Emif_PRCM_Clk_Enable();
    GEL_TextOut("\EMIF PRCM Done \n");
    Cmd_Macro_Config(DDR_PHY0,PHY_INVERT_CLKOUT_DEFINE,DDR2_PHY_CTRL_SLAVE_RATIO_CS0_DEFINE,PHY_CMD0_DLL_LOCK_DIFF_DEFINE);
    Data_Macro_Config(DATA_MACRO_0,DDR_PHY0,ddr2_phy_rd_dqs_cs0_arg,ddr2_phy_wr_dqs_cs0_arg,ddr2_phy_fifo_we_cs0_arg,ddr2_phy_wr_data_cs0_arg);
    Data_Macro_Config(DATA_MACRO_1,DDR_PHY0,ddr2_phy_rd_dqs_cs0_arg,ddr2_phy_wr_dqs_cs0_arg,ddr2_phy_fifo_we_cs0_arg,ddr2_phy_wr_data_cs0_arg);
    Data_Macro_Config(DATA_MACRO_2,DDR_PHY0,ddr2_phy_rd_dqs_cs0_arg,ddr2_phy_wr_dqs_cs0_arg,ddr2_phy_fifo_we_cs0_arg,ddr2_phy_wr_data_cs0_arg);
    Data_Macro_Config(DATA_MACRO_3,DDR_PHY0,ddr2_phy_rd_dqs_cs0_arg,ddr2_phy_wr_dqs_cs0_arg,ddr2_phy_fifo_we_cs0_arg,ddr2_phy_wr_data_cs0_arg);

    Cmd_Macro_Config(DDR_PHY1,PHY_INVERT_CLKOUT_DEFINE,DDR2_PHY_CTRL_SLAVE_RATIO_CS0_DEFINE,PHY_CMD0_DLL_LOCK_DIFF_DEFINE);
    Data_Macro_Config(DATA_MACRO_0,DDR_PHY1,ddr2_phy_rd_dqs_cs0_arg,ddr2_phy_wr_dqs_cs0_arg,ddr2_phy_fifo_we_cs0_arg,ddr2_phy_wr_data_cs0_arg);
    Data_Macro_Config(DATA_MACRO_1,DDR_PHY1,ddr2_phy_rd_dqs_cs0_arg,ddr2_phy_wr_dqs_cs0_arg,ddr2_phy_fifo_we_cs0_arg,ddr2_phy_wr_data_cs0_arg);
    Data_Macro_Config(DATA_MACRO_2,DDR_PHY1,ddr2_phy_rd_dqs_cs0_arg,ddr2_phy_wr_dqs_cs0_arg,ddr2_phy_fifo_we_cs0_arg,ddr2_phy_wr_data_cs0_arg);
    Data_Macro_Config(DATA_MACRO_3,DDR_PHY1,ddr2_phy_rd_dqs_cs0_arg,ddr2_phy_wr_dqs_cs0_arg,ddr2_phy_fifo_we_cs0_arg,ddr2_phy_wr_data_cs0_arg);
    GEL_TextOut("\DDR PHY Configuration Done \n");
    WR_MEM_32(DDR0_IO_CTRL,0x00030303);
    WR_MEM_32(DDR1_IO_CTRL,0x00030303);

    Vtp_Enable();

    GEL_TextOut("\VTP Done \n");

    /*Program the DMM to Access EMIF0 and EMIF1*/
    WR_MEM_32(DMM_LISA_MAP__0, 0x80600100);
    WR_MEM_32(DMM_LISA_MAP__1, 0x80600100);
    WR_MEM_32(DMM_LISA_MAP__2, 0xC0600200);
    WR_MEM_32(DMM_LISA_MAP__3, 0xC0600200);

    GEL_TextOut("\tBusy reading back DMM registers Please wait ...\n");
    while(RD_MEM_32(DMM_LISA_MAP__0)!=0x80600100);
    while(RD_MEM_32(DMM_LISA_MAP__1)!=0x80600100);
    while(RD_MEM_32(DMM_LISA_MAP__2)!=0xC0600200);
    while(RD_MEM_32(DMM_LISA_MAP__3)!=0xC0600200);
    GEL_TextOut("\tDMM register read successfully  \n");

    WR_MEM_32(DMM_PAT_BASE_ADDR, 0x80000000);

    Emif0_MMR_Config(ddr2_emif_read_latency_arg,ddr2_emif_tim1_arg,ddr2_emif_tim2_arg,ddr2_emif_tim3_arg,ddr2_emif_ref_ctrl_arg,ddr2_emif_sdram_config_arg);
    Emif1_MMR_Config(ddr2_emif_read_latency_arg,ddr2_emif_tim1_arg,ddr2_emif_tim2_arg,ddr2_emif_tim3_arg,ddr2_emif_ref_ctrl_arg,ddr2_emif_sdram_config_arg);
}

cmd_DDR3_EMIF0_EMIF1_Config(UWORD32 ddr3_phy_rd_dqs_cs0_arg,UWORD32 ddr3_phy_wr_dqs_cs0_arg,UWORD32 ddr3_phy_fifo_we_cs0_arg,UWORD32 ddr3_phy_wr_data_cs0_arg,UWORD32 ddr3_emif_read_latency_arg,UWORD32 ddr3_emif_tim1_arg,UWORD32 ddr3_emif_tim2_arg,UWORD32 ddr3_emif_tim3_arg,UWORD32 ddr3_emif_ref_ctrl_arg,UWORD32 ddr3_emif_sdram_config_arg)
{

    Emif_PRCM_Clk_Enable();

    Cmd_Macro_Config(DDR_PHY0,DDR3_PHY_INVERT_CLKOUT_OFF,DDR3_PHY_CTRL_SLAVE_RATIO_CS0_DEFINE,PHY_CMD0_DLL_LOCK_DIFF_DEFINE);
    Data_Macro_Config(DATA_MACRO_0,DDR_PHY0,ddr3_phy_rd_dqs_cs0_arg,ddr3_phy_wr_dqs_cs0_arg,ddr3_phy_fifo_we_cs0_arg,ddr3_phy_wr_data_cs0_arg);
    Data_Macro_Config(DATA_MACRO_1,DDR_PHY0,ddr3_phy_rd_dqs_cs0_arg,ddr3_phy_wr_dqs_cs0_arg,ddr3_phy_fifo_we_cs0_arg,ddr3_phy_wr_data_cs0_arg);
    Data_Macro_Config(DATA_MACRO_2,DDR_PHY0,ddr3_phy_rd_dqs_cs0_arg,ddr3_phy_wr_dqs_cs0_arg,ddr3_phy_fifo_we_cs0_arg,ddr3_phy_wr_data_cs0_arg);
    Data_Macro_Config(DATA_MACRO_3,DDR_PHY0,ddr3_phy_rd_dqs_cs0_arg,ddr3_phy_wr_dqs_cs0_arg,ddr3_phy_fifo_we_cs0_arg,ddr3_phy_wr_data_cs0_arg);

    Cmd_Macro_Config(DDR_PHY1,DDR3_PHY_INVERT_CLKOUT_OFF,DDR3_PHY_CTRL_SLAVE_RATIO_CS0_DEFINE,PHY_CMD0_DLL_LOCK_DIFF_DEFINE);
    Data_Macro_Config(DATA_MACRO_0,DDR_PHY1,ddr3_phy_rd_dqs_cs0_arg,ddr3_phy_wr_dqs_cs0_arg,ddr3_phy_fifo_we_cs0_arg,ddr3_phy_wr_data_cs0_arg);
    Data_Macro_Config(DATA_MACRO_1,DDR_PHY1,ddr3_phy_rd_dqs_cs0_arg,ddr3_phy_wr_dqs_cs0_arg,ddr3_phy_fifo_we_cs0_arg,ddr3_phy_wr_data_cs0_arg);
    Data_Macro_Config(DATA_MACRO_2,DDR_PHY1,ddr3_phy_rd_dqs_cs0_arg,ddr3_phy_wr_dqs_cs0_arg,ddr3_phy_fifo_we_cs0_arg,ddr3_phy_wr_data_cs0_arg);
    Data_Macro_Config(DATA_MACRO_3,DDR_PHY1,ddr3_phy_rd_dqs_cs0_arg,ddr3_phy_wr_dqs_cs0_arg,ddr3_phy_fifo_we_cs0_arg,ddr3_phy_wr_data_cs0_arg);

    WR_MEM_32(DDR0_IO_CTRL,0x00030303);
    WR_MEM_32(DDR1_IO_CTRL,0x00030303);

    Vtp_Enable();

    /*Program the DMM to Access EMIF0 and EMIF1*/
    WR_MEM_32(DMM_LISA_MAP__0, 0x80600100);
    WR_MEM_32(DMM_LISA_MAP__1, 0x80600100);
    WR_MEM_32(DMM_LISA_MAP__2, 0xC0600200);
    WR_MEM_32(DMM_LISA_MAP__3, 0xC0600200);

    GEL_TextOut("\tBusy reading back DMM registers Please wait ...\n");
    while(RD_MEM_32(DMM_LISA_MAP__0)!=0x80600100);
    while(RD_MEM_32(DMM_LISA_MAP__1)!=0x80600100);
    while(RD_MEM_32(DMM_LISA_MAP__2)!=0xC0600200);
    while(RD_MEM_32(DMM_LISA_MAP__3)!=0xC0600200);
    GEL_TextOut("\tDMM register read successfully  \n");

    WR_MEM_32(DMM_PAT_BASE_ADDR, 0x80000000);

    Emif0_MMR_Config(ddr3_emif_read_latency_arg,ddr3_emif_tim1_arg,ddr3_emif_tim2_arg,ddr3_emif_tim3_arg,ddr3_emif_ref_ctrl_arg,ddr3_emif_sdram_config_arg);
    Emif1_MMR_Config(ddr3_emif_read_latency_arg,ddr3_emif_tim1_arg,ddr3_emif_tim2_arg,ddr3_emif_tim3_arg,ddr3_emif_ref_ctrl_arg,ddr3_emif_sdram_config_arg);
}


Data_Macro_Config(UWORD32 dataMacroNum,UWORD32 ddr_phy_num,UWORD32 rd_dqs_cs0,UWORD32 wr_dqs_cs0,UWORD32 fifo_we_cs0,UWORD32 wr_data_cs0)
{
UWORD32 BaseAddrOffset;
    if(dataMacroNum == DATA_MACRO_0)
        BaseAddrOffset = 0x00;
    else if(dataMacroNum == DATA_MACRO_1)
        BaseAddrOffset = 0xA4;
    else if(dataMacroNum == DATA_MACRO_2)
        BaseAddrOffset = 0x148;
    else if(dataMacroNum == DATA_MACRO_3)
        BaseAddrOffset = 0x1EC;
    if(ddr_phy_num == DDR_PHY1)
        BaseAddrOffset = BaseAddrOffset + 0x400;//- phy1 is at offset of 0x400 from phy0

    WR_MEM_32((DATA0_REG_PHY0_RD_DQS_SLAVE_RATIO_0 + BaseAddrOffset), (rd_dqs_cs0 << 10 | rd_dqs_cs0));
    WR_MEM_32((DATA0_REG_PHY0_WR_DQS_SLAVE_RATIO_0 + BaseAddrOffset), (wr_dqs_cs0 << 10 | wr_dqs_cs0));
    WR_MEM_32((DATA0_REG_PHY0_WRLVL_INIT_RATIO_0 + BaseAddrOffset),   (PHY_WRLVL_INIT_CS1_DEFINE << 10  | PHY_WRLVL_INIT_CS0_DEFINE));
    WR_MEM_32((DATA0_REG_PHY0_GATELVL_INIT_RATIO_0 + BaseAddrOffset), (PHY_GATELVL_INIT_CS1_DEFINE << 10 | PHY_GATELVL_INIT_CS0_DEFINE));
    WR_MEM_32((DATA0_REG_PHY0_FIFO_WE_SLAVE_RATIO_0 + BaseAddrOffset),(fifo_we_cs0 << 10  | fifo_we_cs0));
    WR_MEM_32((DATA0_REG_PHY0_WR_DATA_SLAVE_RATIO_0 + BaseAddrOffset),(wr_data_cs0 << 10 | wr_data_cs0));
    //-WR_MEM_32((DATA0_REG_PHY0_USE_RANK0_DELAYS + BaseAddrOffset),     PHY_REG_USE_RANK0_DELAY_DEFINE);//- default is 0;
    WR_MEM_32((DATA0_REG_PHY0_DLL_LOCK_DIFF_0 + BaseAddrOffset),      PHY_DLL_LOCK_DIFF_DEFINE);
}

Cmd_Macro_Config(UWORD32 ddr_phy_num,UWORD32 invert_clk_out,UWORD32 ctrl_slave_ratio_cs0,UWORD32 cmd_dll_lock_diff)
{
    if(ddr_phy_num == DDR_PHY0)
    {
    WR_MEM_32(CMD0_REG_PHY0_INVERT_CLKOUT_0, invert_clk_out);
    WR_MEM_32(CMD1_REG_PHY0_INVERT_CLKOUT_0, invert_clk_out);
    WR_MEM_32(CMD2_REG_PHY0_INVERT_CLKOUT_0, invert_clk_out);

    WR_MEM_32(CMD0_REG_PHY0_CTRL_SLAVE_RATIO_0,(ctrl_slave_ratio_cs0 << 10 | ctrl_slave_ratio_cs0));
    WR_MEM_32(CMD1_REG_PHY0_CTRL_SLAVE_RATIO_0,(ctrl_slave_ratio_cs0 << 10 | ctrl_slave_ratio_cs0));
    WR_MEM_32(CMD2_REG_PHY0_CTRL_SLAVE_RATIO_0,(ctrl_slave_ratio_cs0 << 10 | ctrl_slave_ratio_cs0));

    WR_MEM_32(CMD0_REG_PHY0_DLL_LOCK_DIFF_0,cmd_dll_lock_diff);
    WR_MEM_32(CMD1_REG_PHY0_DLL_LOCK_DIFF_0,cmd_dll_lock_diff);
    WR_MEM_32(CMD2_REG_PHY0_DLL_LOCK_DIFF_0,cmd_dll_lock_diff);
    }
    else if(ddr_phy_num == DDR_PHY1)
    {
        WR_MEM_32(CMD0_REG_PHY1_INVERT_CLKOUT_0, invert_clk_out);
        WR_MEM_32(CMD1_REG_PHY1_INVERT_CLKOUT_0, invert_clk_out);
        WR_MEM_32(CMD2_REG_PHY1_INVERT_CLKOUT_0, invert_clk_out);

        WR_MEM_32(CMD0_REG_PHY1_CTRL_SLAVE_RATIO_0,(ctrl_slave_ratio_cs0 << 10 | ctrl_slave_ratio_cs0));
        WR_MEM_32(CMD1_REG_PHY1_CTRL_SLAVE_RATIO_0,(ctrl_slave_ratio_cs0 << 10 | ctrl_slave_ratio_cs0));
        WR_MEM_32(CMD2_REG_PHY1_CTRL_SLAVE_RATIO_0,(ctrl_slave_ratio_cs0 << 10 | ctrl_slave_ratio_cs0));

        WR_MEM_32(CMD0_REG_PHY1_DLL_LOCK_DIFF_0,cmd_dll_lock_diff);
        WR_MEM_32(CMD1_REG_PHY1_DLL_LOCK_DIFF_0,cmd_dll_lock_diff);
        WR_MEM_32(CMD2_REG_PHY1_DLL_LOCK_DIFF_0,cmd_dll_lock_diff);
    }
}


Emif0_MMR_Config(UWORD32 read_latency,UWORD32 tim1,UWORD32 tim2,UWORD32 tim3,UWORD32 ref_ctrl,UWORD32 sdram_config)
{
    /*Program EMIF0 CFG Registers*/
    WR_MEM_32(EMIF4_0_DDR_PHY_CTRL_1, read_latency);
    WR_MEM_32(EMIF4_0_DDR_PHY_CTRL_1_SHADOW, read_latency);

    WR_MEM_32(EMIF4_0_SDRAM_TIM_1, tim1);
    WR_MEM_32(EMIF4_0_SDRAM_TIM_1_SHADOW, tim1);

    WR_MEM_32(EMIF4_0_SDRAM_TIM_2, tim2);
    WR_MEM_32(EMIF4_0_SDRAM_TIM_2_SHADOW, tim2);

    WR_MEM_32(EMIF4_0_SDRAM_TIM_3, tim3);
    WR_MEM_32(EMIF4_0_SDRAM_TIM_3_SHADOW, tim3);

    WR_MEM_32(EMIF4_0_SDRAM_CONFIG, sdram_config);

    WR_MEM_32(EMIF4_0_SDRAM_REF_CTRL, 0x10000000|DDR3_EMIF_REF_CTRL_DEFINE1);
    WR_MEM_32(EMIF4_0_SDRAM_REF_CTRL_SHADOW, DDR3_EMIF_REF_CTRL_DEFINE1);

    WR_MEM_32(EMIF4_0_SDRAM_ZQCR,DDR3_EMIF_SDRAM_ZQCR_DEFINE);

    WR_MEM_32(EMIF4_0_SDRAM_REF_CTRL, DDR3_EMIF_REF_CTRL_DEFINE1);
    WR_MEM_32(EMIF4_0_SDRAM_REF_CTRL_SHADOW, DDR3_EMIF_REF_CTRL_DEFINE1);

    WR_MEM_32(EMIF4_0_SDRAM_REF_CTRL, ref_ctrl);
    WR_MEM_32(EMIF4_0_SDRAM_REF_CTRL_SHADOW, ref_ctrl);
}

Emif1_MMR_Config(UWORD32 read_latency,UWORD32 tim1,UWORD32 tim2,UWORD32 tim3,UWORD32 ref_ctrl,UWORD32 sdram_config)
{
    /*Program EMIF0 CFG Registers*/
    WR_MEM_32(EMIF4_1_DDR_PHY_CTRL_1, read_latency);
    WR_MEM_32(EMIF4_1_DDR_PHY_CTRL_1_SHADOW, read_latency);

    WR_MEM_32(EMIF4_1_SDRAM_TIM_1, tim1);
    WR_MEM_32(EMIF4_1_SDRAM_TIM_1_SHADOW, tim1);

    WR_MEM_32(EMIF4_1_SDRAM_TIM_2, tim2);
    WR_MEM_32(EMIF4_1_SDRAM_TIM_2_SHADOW, tim2);

    WR_MEM_32(EMIF4_1_SDRAM_TIM_3, tim3);
    WR_MEM_32(EMIF4_1_SDRAM_TIM_3_SHADOW, tim3);


    WR_MEM_32(EMIF4_1_SDRAM_CONFIG, sdram_config);

    WR_MEM_32(EMIF4_1_SDRAM_REF_CTRL, 0x10000000|DDR3_EMIF_REF_CTRL_DEFINE1);
    WR_MEM_32(EMIF4_1_SDRAM_REF_CTRL_SHADOW, DDR3_EMIF_REF_CTRL_DEFINE1);

    WR_MEM_32(EMIF4_1_SDRAM_ZQCR,DDR3_EMIF_SDRAM_ZQCR_DEFINE);

    WR_MEM_32(EMIF4_1_SDRAM_REF_CTRL, DDR3_EMIF_REF_CTRL_DEFINE1);
    WR_MEM_32(EMIF4_1_SDRAM_REF_CTRL_SHADOW, DDR3_EMIF_REF_CTRL_DEFINE1);

    WR_MEM_32(EMIF4_1_SDRAM_REF_CTRL, ref_ctrl);
    WR_MEM_32(EMIF4_1_SDRAM_REF_CTRL_SHADOW, ref_ctrl);
}


Emif_PRCM_Clk_Enable()
{
    WR_MEM_32(CM_DEFAULT_FW_CLKCTRL, 0x2);           /*Enable the EMIF FireWall Clocks*/
    WR_MEM_32(CM_DEFAULT_L3_FAST_CLKSTCTRL, 0x2); /*Enable the Power Domain Transition of L3 Fast Domain Peripheral*/
    WR_MEM_32(CM_DEFAULT_EMIF_0_CLKCTRL,    0x2); /*Enable EMIF0 Clock*/
    WR_MEM_32(CM_DEFAULT_EMIF_1_CLKCTRL,    0x2); /*Enable EMIF1 Clock*/
    WR_MEM_32(CM_DEFAULT_DMM_CLKCTRL,       0x2); /*Enable EMIF1 Clock*/
    while((RD_MEM_32(CM_DEFAULT_L3_FAST_CLKSTCTRL) & 0x300)!=0x300);    /*Poll for L3_FAST_GCLK  & DDR_GCLK  are active*/
    while(RD_MEM_32(CM_DEFAULT_EMIF_0_CLKCTRL)!=0x2);        /*Poll for Module is functional*/
    while(RD_MEM_32(CM_DEFAULT_EMIF_1_CLKCTRL)!=0x2);        /*Poll for Module is functional*/
    while(RD_MEM_32(CM_DEFAULT_DMM_CLKCTRL)!=0x2);            /*Poll for Module is functional*/
}

Vtp_Enable()
{
    // Write 1 to ENABLE bit
    WR_MEM_32(VTP0_CTRL_REG, RD_MEM_32(VTP0_CTRL_REG) | 0x00000040 );
    WR_MEM_32(VTP1_CTRL_REG, RD_MEM_32(VTP1_CTRL_REG) | 0x00000040 );

    // Write 0 to CLRZ bit
    WR_MEM_32(VTP0_CTRL_REG, RD_MEM_32(VTP0_CTRL_REG) & 0xfffffffe );
    WR_MEM_32(VTP1_CTRL_REG, RD_MEM_32(VTP1_CTRL_REG) & 0xfffffffe );

    // Write 1 to CLRZ bit
    WR_MEM_32(VTP0_CTRL_REG, RD_MEM_32(VTP0_CTRL_REG) | 0x00000001 );
    WR_MEM_32(VTP1_CTRL_REG, RD_MEM_32(VTP1_CTRL_REG) | 0x00000001 );

    // Read VTP control registers & check READY bits
    while( (RD_MEM_32(VTP0_CTRL_REG) & 0x00000020) != 0x20);
    while( (RD_MEM_32(VTP1_CTRL_REG) & 0x00000020) != 0x20);
}



/********************************************************************************
        DDR Initialization and Configurations
*********************************************************************************/

menuitem "DM8148 DDR Configuration"


    hotmenu DDR2_EMIF0_EMIF1_333MHz_Config()
    {
        GEL_TextOut("\t ****  Configuring DDR PLL to 333 MHz......... \n");
        cmdDDRPLL(CLKIN,19,666, 2);
        GEL_TextOut("\t ****  DM8148 DDR2 EVM EMIF0 and EMIF1 configuration in progress......... \n");
        cmd_DDR2_EMIF0_EMIF1_Config(DDR2_PHY_RD_DQS_CS0_DEFINE,DDR2_PHY_WR_DQS_CS0_DEFINE,DDR2_PHY_FIFO_WE_CS0_DEFINE,DDR2_PHY_WR_DATA_CS0_DEFINE,DDR2_EMIF_READ_LATENCY_DEFINE,DDR2_EMIF_TIM1_DEFINE,DDR2_EMIF_TIM2_DEFINE,DDR2_EMIF_TIM3_DEFINE,DDR2_EMIF_REF_CTRL_DEFINE,DDR2_EMIF_SDRAM_CONFIG_DEFINE);
        GEL_TextOut("\t ****  DM8148 DDR2 EVM EMIF0 and EMIF1 configuration is DONE **** \n");
    }

    hotmenu DDR2_EMIF0_EMIF1_400MHz_Config()
    {
        GEL_TextOut("\t ****  Configuring DDR PLL to 400 MHz......... \n");
        cmdDDRPLL(CLKIN,19,800, 2);
        GEL_TextOut("\t ****  DM8148 DDR2 EVM EMIF0 and EMIF1 configuration in progress......... \n");
        cmd_DDR2_EMIF0_EMIF1_Config(DDR2_PHY_RD_DQS_CS0_DEFINE,DDR2_PHY_WR_DQS_CS0_DEFINE,DDR2_PHY_FIFO_WE_CS0_DEFINE,DDR2_PHY_WR_DATA_CS0_DEFINE,DDR2_EMIF_READ_LATENCY_DEFINE,DDR2_EMIF_TIM1_DEFINE,DDR2_EMIF_TIM2_DEFINE,DDR2_EMIF_TIM3_DEFINE,DDR2_EMIF_REF_CTRL_DEFINE,DDR2_EMIF_SDRAM_CONFIG_DEFINE);
        GEL_TextOut("\t ****  DM8148 DDR2 EVM EMIF0 and EMIF1 configuration is DONE **** \n");
    }

    hotmenu DDR3_EMIF0_EMIF1_300MHz_Config()
    {
        GEL_TextOut("\t ****  Configuring DDR PLL to 300 MHz......... \n");
        cmdDDRPLL(CLKIN,19,600, 2);
        GEL_TextOut("\t ****  DM8148 DDR3 EVM EMIF0 and EMIF1 configuration in progress......... \n");
        cmd_DDR3_EMIF0_EMIF1_Config(DDR3_PHY_RD_DQS_CS0_DEFINE,DDR3_PHY_WR_DQS_CS0_DEFINE,DDR3_PHY_FIFO_WE_CS0_DEFINE,DDR3_PHY_WR_DATA_CS0_DEFINE,DDR3_EMIF_READ_LATENCY_DEFINE_300,DDR3_EMIF_TIM1_DEFINE_300,DDR3_EMIF_TIM2_DEFINE_300,DDR3_EMIF_TIM3_DEFINE_300,DDR3_EMIF_REF_CTRL_DEFINE2_300,DDR3_EMIF_SDRAM_CONFIG_DEFINE_300);
        GEL_TextOut("\t ****  DM8148 DDR3 EVM EMIF0 and EMIF1 configuration is DONE **** \n");
    }

    hotmenu DDR3_EMIF0_EMIF1_333MHz_Config()
    {
        GEL_TextOut("\t ****  Configuring DDR PLL to 333 MHz......... \n");
        cmdDDRPLL(CLKIN,19,666, 2);
        GEL_TextOut("\t ****  DM8148 DDR3 EVM EMIF0 and EMIF1 configuration in progress......... \n");
        cmd_DDR3_EMIF0_EMIF1_Config(DDR3_PHY_RD_DQS_CS0_DEFINE,DDR3_PHY_WR_DQS_CS0_DEFINE,DDR3_PHY_FIFO_WE_CS0_DEFINE,DDR3_PHY_WR_DATA_CS0_DEFINE,DDR3_EMIF_READ_LATENCY_DEFINE_333,DDR3_EMIF_TIM1_DEFINE_333,DDR3_EMIF_TIM2_DEFINE_333,DDR3_EMIF_TIM3_DEFINE_333,DDR3_EMIF_REF_CTRL_DEFINE2_333,DDR3_EMIF_SDRAM_CONFIG_DEFINE_333);
        GEL_TextOut("\t ****  DM8148 DDR3 EVM EMIF0 and EMIF1 configuration is DONE **** \n");
    }
    hotmenu DDR3_EMIF0_EMIF1_400MHz_Config()
    {
        GEL_TextOut("\t ****  Configuring DDR PLL to 400 MHz......... \n");
        cmdDDRPLL(CLKIN,19,800, 2);
        GEL_TextOut("\t ****  DM8148 DDR3 EVM EMIF0 and EMIF1 configuration in progress......... \n");
        cmd_DDR3_EMIF0_EMIF1_Config(DDR3_PHY_RD_DQS_CS0_DEFINE,DDR3_PHY_WR_DQS_CS0_DEFINE,DDR3_PHY_FIFO_WE_CS0_DEFINE,DDR3_PHY_WR_DATA_CS0_DEFINE,DDR3_EMIF_READ_LATENCY_DEFINE_400,DDR3_EMIF_TIM1_DEFINE_400,DDR3_EMIF_TIM2_DEFINE_400,DDR3_EMIF_TIM3_DEFINE_400,DDR3_EMIF_REF_CTRL_DEFINE2_400,DDR3_EMIF_SDRAM_CONFIG_DEFINE_400);
        GEL_TextOut("\t ****  DM8148 DDR3 EVM EMIF0 and EMIF1 configuration is DONE **** \n");
    }
    hotmenu DDR3_EMIF0_EMIF1_450MHz_Config()
    {
        GEL_TextOut("\t ****  Configuring DDR PLL to 450 MHz......... \n");
        cmdDDRPLL(CLKIN,19,900, 2);
        GEL_TextOut("\t ****  DM8148 DDR3 EVM EMIF0 and EMIF1 configuration in progress......... \n");
        cmd_DDR3_EMIF0_EMIF1_Config(DDR3_PHY_RD_DQS_CS0_DEFINE,DDR3_PHY_WR_DQS_CS0_DEFINE,DDR3_PHY_FIFO_WE_CS0_DEFINE,DDR3_PHY_WR_DATA_CS0_DEFINE,DDR3_EMIF_READ_LATENCY_DEFINE_450,DDR3_EMIF_TIM1_DEFINE_450,DDR3_EMIF_TIM2_DEFINE_450,DDR3_EMIF_TIM3_DEFINE_450,DDR3_EMIF_REF_CTRL_DEFINE2_450,DDR3_EMIF_SDRAM_CONFIG_DEFINE_450);
        GEL_TextOut("\t ****  DM8148 DDR3 EVM EMIF0 and EMIF1 configuration is DONE **** \n");
    }
    hotmenu DDR3_EMIF0_EMIF1_533MHz_Config()
    {
        GEL_TextOut("\t ****  Configuring DDR PLL to 533 MHz......... \n");
        cmdDDRPLL(CLKIN,19,1066, 2);
        GEL_TextOut("\t ****  DM8148 DDR3 EVM EMIF0 and EMIF1 configuration in progress......... \n");
        cmd_DDR3_EMIF0_EMIF1_Config(DDR3_PHY_RD_DQS_CS0_DEFINE,DDR3_PHY_WR_DQS_CS0_DEFINE,DDR3_PHY_FIFO_WE_CS0_DEFINE,DDR3_PHY_WR_DATA_CS0_DEFINE,DDR3_EMIF_READ_LATENCY_DEFINE_533,DDR3_EMIF_TIM1_DEFINE_533,DDR3_EMIF_TIM2_DEFINE_533,DDR3_EMIF_TIM3_DEFINE_533,DDR3_EMIF_REF_CTRL_DEFINE2_533,DDR3_EMIF_SDRAM_CONFIG_DEFINE_533);
        GEL_TextOut("\t ****  DM8148 DDR3 EVM EMIF0 and EMIF1 configuration is DONE **** \n");
    }


OnTargetConnect()
{
    GEL_TextOut("    Initializing EVM814X....\n");
    GEL_Reset();

    // Setup all PLLs
    Setup_PLL();

    // Enable all clock/power domains
    C674xClkEnable_API();
    ControlModule_ClkEnable();
    PrcmAlwayOnClkEnable();

    // Setup the external memory frequencies
    DDR3_EMIF0_EMIF1_533MHz_Config();

    DucatiClkEnable();

    EMAC_init();

    GEL_TextOut("    EVM814X Intialization done.\n");
}

/*************************************************************************************************/

EMAC_ClkEnable()
{
    GEL_TextOut("    CONFIGURE PRCM CLOCKS of EMAC in progress \n");

    /* Enable Ethernet CLKSTCTRL register */
    WR_MEM_32(CM_ALWON_ETHERNET_CLKSTCTRL, 0x2);
    while((RD_MEM_32(CM_ALWON_ETHERNET_CLKSTCTRL) & 0x3)!=0x2);

    /* Enable Ethernet 0 CLKCTRL register */
    WR_MEM_32(CM_ALWON_ETHERNET_0_CLKCTRL, 0x2);
    while((RD_MEM_32(CM_ALWON_ETHERNET_0_CLKCTRL) & 0x3)!=0x2);
    
    /* Enable Ethernet 1 CLKCTRL register */
    WR_MEM_32(CM_ALWON_ETHERNET_1_CLKCTRL, 0x2);
    while((RD_MEM_32(CM_ALWON_ETHERNET_1_CLKCTRL) & 0x3)!=0x2);

    /* Wait for IDLEST and STBYST fields to match the desired values */
/*     while((RD_MEM_32(CM_ALWON_ETHERNET_0_CLKCTRL) & 0x00030000u) != 0x00000000);
    while((RD_MEM_32(CM_ALWON_ETHERNET_0_CLKCTRL) & 0x00040000u) != 0x00000000);
    while((RD_MEM_32(CM_ALWON_ETHERNET_1_CLKCTRL) & 0x00030000u) != 0x00000000);
    while((RD_MEM_32(CM_ALWON_ETHERNET_1_CLKCTRL) & 0x00040000u) != 0x00000000);
*/
    while(RD_MEM_32(CM_ALWON_ETHERNET_CLKSTCTRL) != 0x302);

    GEL_TextOut("    PRCM CLOCKS of EMAC is complete \n");
}

EMAC_pinSetup()
{
    /* Other pins */
    /* EMAC_RMREFCLK - checked */
    WR_MEM_32(PINCNTL232, ( RD_MEM_32(PINCNTL232) &    0xfffcff00)    | 0x00000001);
    /* MD Clock - checked */
    WR_MEM_32(PINCNTL233, ( RD_MEM_32(PINCNTL233) &    0xfffcff00)    | 0x00020001);  /* Rx disabled, PU enabled */
    /* MDIO - checked */
    WR_MEM_32(PINCNTL234, ( RD_MEM_32(PINCNTL234) &    0xfffcff00)    | 0x00020001);  /* Rx enabled, PU enabled */

    /* RGMII0 pins */
    /* EMAC[0]_RGTXC - checked */
    WR_MEM_32(PINCNTL239, (RD_MEM_32(PINCNTL239) & 0xfffcff00) | 0x00000001);  /* Rx disabled, PD enabled */
    /* EMAC[0]_RGTXCTL - checked */
    WR_MEM_32(PINCNTL238, (RD_MEM_32(PINCNTL238) & 0xfffcff00) | 0x00000001);  /* Rx disabled, PD enabled */
    /* EMAC[0]_RGTXD[0] - checked */
    WR_MEM_32(PINCNTL240, (RD_MEM_32(PINCNTL240) & 0xfffcff00) | 0x00000001);  /* Rx disabled, PD enabled */
    /* EMAC[0]_RGTXD[1] - checked */
    WR_MEM_32(PINCNTL247, (RD_MEM_32(PINCNTL247) & 0xfffcff00) | 0x00000001);  /* Rx disabled, PD enabled */
    /* EMAC[0]_RGTXD[2] - checked */
    WR_MEM_32(PINCNTL246, (RD_MEM_32(PINCNTL246) & 0xfffcff00) | 0x00000001);  /* Rx disabled, PD enabled */
    /* EMAC[0]_RGTXD[3] - checked */
    WR_MEM_32(PINCNTL245, (RD_MEM_32(PINCNTL245) & 0xfffcff00) | 0x00000001);  /* Rx disabled, PD enabled */

    /* EMAC[0]_RGRXC - checked */
    WR_MEM_32(PINCNTL235, (RD_MEM_32(PINCNTL235) & 0xfffcff00) | 0x00000001);  /* Rx enabled, PD enabled */
    /* EMAC[0]_RGRXCTL - checked */
    WR_MEM_32(PINCNTL236, (RD_MEM_32(PINCNTL236) & 0xfffcff00) | 0x00000001);  /* Rx enabled, PD enabled */
    /* EMAC[0]_RGRXD[0] - checked */
    WR_MEM_32(PINCNTL241, (RD_MEM_32(PINCNTL241) & 0xfffcff00) | 0x00000001);  /* Rx enabled, PD enabled */
    /* EMAC[0]_RGRXD[1] - checked */
    WR_MEM_32(PINCNTL242, (RD_MEM_32(PINCNTL242) & 0xfffcff00) | 0x00000001);  /* Rx enabled, PD enabled */
    /* EMAC[0]_RGRXD[2] - checked */
    WR_MEM_32(PINCNTL237, (RD_MEM_32(PINCNTL237) & 0xfffcff00) | 0x00000001);  /* Rx enabled, PD enabled */
    /* EMAC[0]_RGRXD[3] - checked */
    WR_MEM_32(PINCNTL244, (RD_MEM_32(PINCNTL244) & 0xfffcff00) | 0x00000001);  /* Rx enabled, PD enabled */

    /* RGMII1 pins */
    /* EMAC[1]_RGTXC - checked */
    WR_MEM_32(PINCNTL255, (RD_MEM_32(PINCNTL255) & 0xfffcff00) | 0x00000001);  /* Rx disabled, PD enabled */
    /* EMAC[1]_RGTXCTL - checked */
    WR_MEM_32(PINCNTL252, (RD_MEM_32(PINCNTL252) & 0xfffcff00) | 0x00000001);  /* Rx disabled, PD enabled */
    /* EMAC[1]_RGTXD[0] - checked */
    WR_MEM_32(PINCNTL253, (RD_MEM_32(PINCNTL253) & 0xfffcff00) | 0x00000001);  /* Rx disabled, PD enabled */
    /* EMAC[1]_RGTXD[1] - checked */
    WR_MEM_32(PINCNTL251, (RD_MEM_32(PINCNTL251) & 0xfffcff00) | 0x00000001);  /* Rx disabled, PD enabled */
    /* EMAC[1]_RGTXD[2] - checked */
    WR_MEM_32(PINCNTL254, (RD_MEM_32(PINCNTL254) & 0xfffcff00) | 0x00000001);  /* Rx disabled, PD enabled */
    /* EMAC[1]_RGTXD[3] - checked */
    WR_MEM_32(PINCNTL257, (RD_MEM_32(PINCNTL257) & 0xfffcff00) | 0x00000001);  /* Rx disabled, PD enabled */

    /* EMAC[1]_RGRXC - checked*/
    WR_MEM_32(PINCNTL249, (RD_MEM_32(PINCNTL249) & 0xfffcff00) | 0x00000001);  /* Rx enabled, PD enabled */
    /* EMAC[1]_RGRXCTL - checked */
    WR_MEM_32(PINCNTL243, (RD_MEM_32(PINCNTL243) & 0xfffcff00) | 0x00000001);  /* Rx enabled, PD enabled */
    /* EMAC[1]_RGRXD[0] - checked */
    WR_MEM_32(PINCNTL256, (RD_MEM_32(PINCNTL256) & 0xfffcff00) | 0x00000001);  /* Rx enabled, PD enabled */
    /* EMAC[1]_RGRXD[1] - checked */
    WR_MEM_32(PINCNTL248, (RD_MEM_32(PINCNTL248) & 0xfffcff00) | 0x00000001);  /* Rx enabled, PD enabled */
    /* EMAC[1]_RGRXD[2] - checked */
    WR_MEM_32(PINCNTL258, (RD_MEM_32(PINCNTL258) & 0xfffcff00) | 0x00000001);  /* Rx enabled, PD enabled */
    /* EMAC[1]_RGRXD[3] - checked */
    WR_MEM_32(PINCNTL250, (RD_MEM_32(PINCNTL250) & 0xfffcff00) | 0x00000001);  /* Rx enabled, PD enabled */
}

EMAC_init()
{
    GEL_TextOut("\t ***** Configuring RGMII Clk and Mux....***** \n");

    /* PINCNTL configuration */
    EMAC_pinSetup();

    /* Setup clock config and enable module clocks */
    EMAC_ClkEnable();

    /* Set RGMII mode in GMII_SEL in Control Module */
    WR_MEM_32(GMII_SEL, 0x0000030A);

    GEL_TextOut("\t ***** Configuring RGMII Clk and Mux complete....***** \n");
}

