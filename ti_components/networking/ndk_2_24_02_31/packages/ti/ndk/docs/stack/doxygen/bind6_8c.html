<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>NDK Stack Documentation: src/stack/bind6/bind6.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="tilogo.gif"></a></td>
  <td bgcolor="red"><img src="titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>src/stack/bind6/bind6.c File Reference</h1>The file implements the BIND6 Module. The BIND6 Module is responsible for keeping track of all LOCAL IPv6 Addresses which have been assigned to the interfaces. <a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bind6_8c.html#81a8cf859410daae4157316cb2c47022">Bind6Msg</a> (uint Msg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">HANDLE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bind6_8c.html#21beb57f44cd499ca4c06461dd24cf79">Bind6FindByHost</a> (NETIF_DEVICE *ptr_device, IP6N IP)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">HANDLE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bind6_8c.html#4b98f552a4e1b7b6c3fb83cac3406ca5">Bind6FindByNet</a> (NETIF_DEVICE *ptr_device, IP6N IPNet)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bind6_8c.html#6f10d848df8269aef6437d69dafc38de">Bind6Free</a> (HANDLE hbind6Obj)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">HANDLE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bind6_8c.html#188a9101bf0177a1e7b9e94cd1cd17f7">Bind6New</a> (NETIF_DEVICE *ptr_device, IP6N IPHost, IP6N IPMask, UINT32 ValidLifetime, UINT32 PreferredLifetime, UINT8 IsAnycast)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bind6_8c.html#f57796f417f746cebde72a4122537c0d">Bind6DADCheck</a> (NETIF_DEVICE *ptr_device, IP6N TargetAddress)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NETIF_DEVICE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bind6_8c.html#c757cf22eb3b6bfdee8b7ba8ba5ee31b">Bind6GetInterfaceHandle</a> (HANDLE hbind6Obj)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">HANDLE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bind6_8c.html#d2c7654da91100874d1a36d01fba6004">Bind6FindByIF</a> (NETIF_DEVICE *ptr_device)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bind6_8c.html#5bc115b3a9964b5e0f5b8ada2a1bc13d">Bind6GetLinkLocalAddress</a> (NETIF_DEVICE *ptr_device, IP6N *IPAddress)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bind6_8c.html#d017bc6efb38b6ebc7fcc08921ee0944">Bind6GetGlobalAddress</a> (NETIF_DEVICE *ptr_device, IP6N IPNetworkAddr, IP6N *IPAddress)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">IP6N&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bind6_8c.html#8b6b77365cf0c6ab46397c8d5bd19f64">Bind6IF2IPHost</a> (NETIF_DEVICE *ptr_device)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">UINT32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bind6_8c.html#996a6f5dea7272ee6f672b61e9319f48">Bind6GetLifetime</a> (HANDLE hbind6Obj)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bind6_8c.html#937231b28b0bb83877c47f3f5ef9938e">Bind6SetLifetime</a> (HANDLE hbind6Obj, UINT32 Lifetime)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_b_i_n_d6___e_n_t_r_y.html">BIND6_ENTRY</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bind6_8c.html#f6c092a5b8d262c612c3cd1539dab65a">Bind6GetTable</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bind6_8c.html#1f6449f36fedbf55e1de85b70895daf1">Bind6CleanTable</a> (<a class="el" href="struct_b_i_n_d6___e_n_t_r_y.html">BIND6_ENTRY</a> *ptr_list)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The file implements the BIND6 Module. The BIND6 Module is responsible for keeping track of all LOCAL IPv6 Addresses which have been assigned to the interfaces. 
<p>
<dl class="user" compact><dt><b></b></dt><dd>NOTE: (C) Copyright 2008, Texas Instruments, Inc.</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd></dd></dl>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="1f6449f36fedbf55e1de85b70895daf1"></a><!-- doxytag: member="bind6.c::Bind6CleanTable" ref="1f6449f36fedbf55e1de85b70895daf1" args="(BIND6_ENTRY *ptr_list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bind6CleanTable           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_b_i_n_d6___e_n_t_r_y.html">BIND6_ENTRY</a> *&nbsp;</td>
          <td class="paramname"> <em>ptr_list</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function is called to clean the memory allocated by a previous call to Route6GetTable. The function cleans the replicated copy of the routing table. This function is available to system developers and can be called from outside kernel mode. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="bind6_8c.html#f6c092a5b8d262c612c3cd1539dab65a">Bind6GetTable</a></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr_list</em>&nbsp;</td><td>This is the head of the duplicate list which will be cleaned up.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Not</em>&nbsp;</td><td>Applicable </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f57796f417f746cebde72a4122537c0d"></a><!-- doxytag: member="bind6.c::Bind6DADCheck" ref="f57796f417f746cebde72a4122537c0d" args="(NETIF_DEVICE *ptr_device, IP6N TargetAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bind6DADCheck           </td>
          <td>(</td>
          <td class="paramtype">NETIF_DEVICE *&nbsp;</td>
          <td class="paramname"> <em>ptr_device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IP6N&nbsp;</td>
          <td class="paramname"> <em>TargetAddress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function is called by the ICMP6 Module to check if the received address passes or fails the DAD Check.<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr_device</em>&nbsp;</td><td>The pointer to the network interface device on which the DAD needs to be stopped.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>TargetAddress</em>&nbsp;</td><td>The IP Address matching the Target Address in the NS/NA request.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Success</em>&nbsp;</td><td>(No DAD Detected) - 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Error</em>&nbsp;</td><td>(DAD Detected) - &lt;0 </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="21beb57f44cd499ca4c06461dd24cf79"></a><!-- doxytag: member="bind6.c::Bind6FindByHost" ref="21beb57f44cd499ca4c06461dd24cf79" args="(NETIF_DEVICE *ptr_device, IP6N IP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HANDLE Bind6FindByHost           </td>
          <td>(</td>
          <td class="paramtype">NETIF_DEVICE *&nbsp;</td>
          <td class="paramname"> <em>ptr_device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IP6N&nbsp;</td>
          <td class="paramname"> <em>IP</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 Find a binding by searching IF handle with IP Host addr This is an external NDK Stack API and is available to other modules. In this we search only addresses which have passed the DAD Procedure since these are VALID.<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr_device</em>&nbsp;</td><td>Pointer to the NIMU Network Interface object which has to be searched for the IPv6 address.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>IP</em>&nbsp;</td><td>IPv6 Address to be searched for.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Match</em>&nbsp;</td><td>- Handle to the <a class="el" href="struct_b_i_n_d6___e_n_t_r_y.html">BIND6_ENTRY</a> Object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>No</em>&nbsp;</td><td>Match - 0 </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d2c7654da91100874d1a36d01fba6004"></a><!-- doxytag: member="bind6.c::Bind6FindByIF" ref="d2c7654da91100874d1a36d01fba6004" args="(NETIF_DEVICE *ptr_device)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HANDLE Bind6FindByIF           </td>
          <td>(</td>
          <td class="paramtype">NETIF_DEVICE *&nbsp;</td>
          <td class="paramname"> <em>ptr_device</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function searches the <a class="el" href="struct_b_i_n_d6___e_n_t_r_y.html">BIND6_ENTRY</a> objects in the system for a specific interface.<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr_device</em>&nbsp;</td><td>The Network interface object whose <a class="el" href="struct_b_i_n_d6___e_n_t_r_y.html">BIND6_ENTRY</a> Object we are interested in.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Handle</em>&nbsp;</td><td>to the <a class="el" href="struct_b_i_n_d6___e_n_t_r_y.html">BIND6_ENTRY</a> object </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4b98f552a4e1b7b6c3fb83cac3406ca5"></a><!-- doxytag: member="bind6.c::Bind6FindByNet" ref="4b98f552a4e1b7b6c3fb83cac3406ca5" args="(NETIF_DEVICE *ptr_device, IP6N IPNet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HANDLE Bind6FindByNet           </td>
          <td>(</td>
          <td class="paramtype">NETIF_DEVICE *&nbsp;</td>
          <td class="paramname"> <em>ptr_device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IP6N&nbsp;</td>
          <td class="paramname"> <em>IPNet</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 Find a binding by searching IF handle with IP Net addr This is an external NDK Stack API and is available to other modules. In this we search only addresses which have passed the DAD Procedure since these are VALID.<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr_device</em>&nbsp;</td><td>Pointer to the NIMU Network Interface object which has to be searched for the IPv6 address.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>IPNet</em>&nbsp;</td><td>IPv6 Network Address we are searching for.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Match</em>&nbsp;</td><td>- Handle to the <a class="el" href="struct_b_i_n_d6___e_n_t_r_y.html">BIND6_ENTRY</a> Object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>No</em>&nbsp;</td><td>Match - 0 </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6f10d848df8269aef6437d69dafc38de"></a><!-- doxytag: member="bind6.c::Bind6Free" ref="6f10d848df8269aef6437d69dafc38de" args="(HANDLE hbind6Obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bind6Free           </td>
          <td>(</td>
          <td class="paramtype">HANDLE&nbsp;</td>
          <td class="paramname"> <em>hbind6Obj</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function is used to close an IPv6 binding.<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hbind6Obj</em>&nbsp;</td><td>The <a class="el" href="struct_b_i_n_d6___e_n_t_r_y.html">BIND6_ENTRY</a> Object which is to be freed up.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Not</em>&nbsp;</td><td>Applicable. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d017bc6efb38b6ebc7fcc08921ee0944"></a><!-- doxytag: member="bind6.c::Bind6GetGlobalAddress" ref="d017bc6efb38b6ebc7fcc08921ee0944" args="(NETIF_DEVICE *ptr_device, IP6N IPNetworkAddr, IP6N *IPAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bind6GetGlobalAddress           </td>
          <td>(</td>
          <td class="paramtype">NETIF_DEVICE *&nbsp;</td>
          <td class="paramname"> <em>ptr_device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IP6N&nbsp;</td>
          <td class="paramname"> <em>IPNetworkAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IP6N *&nbsp;</td>
          <td class="paramname"> <em>IPAddress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function searches the BIND6 object and returns a GLOBAL Address for the device. An Error Condition conveys the fact either IPv6 has not been initialized on this interface or there is no GLOBAL Address configured on the interface<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr_device</em>&nbsp;</td><td>The Network interface object whose LINK LOCAL Address is required. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>IPNetworkAddr</em>&nbsp;</td><td>The Network Mask of the IP Address that needs to be retuned. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>IPAddress</em>&nbsp;</td><td>The GLOBAL IP Address is returned</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Success</em>&nbsp;</td><td>- 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Error</em>&nbsp;</td><td>- -1 </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c757cf22eb3b6bfdee8b7ba8ba5ee31b"></a><!-- doxytag: member="bind6.c::Bind6GetInterfaceHandle" ref="c757cf22eb3b6bfdee8b7ba8ba5ee31b" args="(HANDLE hbind6Obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NETIF_DEVICE* Bind6GetInterfaceHandle           </td>
          <td>(</td>
          <td class="paramtype">HANDLE&nbsp;</td>
          <td class="paramname"> <em>hbind6Obj</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function returns the interface handle given the <a class="el" href="struct_b_i_n_d6___e_n_t_r_y.html">BIND6_ENTRY</a> object.<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hbind6Obj</em>&nbsp;</td><td>The <a class="el" href="struct_b_i_n_d6___e_n_t_r_y.html">BIND6_ENTRY</a> Object whose interface handle we need.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Success</em>&nbsp;</td><td>- Handle of the interface </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Error</em>&nbsp;</td><td>- 0 </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="996a6f5dea7272ee6f672b61e9319f48"></a><!-- doxytag: member="bind6.c::Bind6GetLifetime" ref="996a6f5dea7272ee6f672b61e9319f48" args="(HANDLE hbind6Obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 Bind6GetLifetime           </td>
          <td>(</td>
          <td class="paramtype">HANDLE&nbsp;</td>
          <td class="paramname"> <em>hbind6Obj</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function returns the Lifetime matching the <a class="el" href="struct_b_i_n_d6___e_n_t_r_y.html">BIND6_ENTRY</a> object.<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hbind6Obj</em>&nbsp;</td><td>Handle to the <a class="el" href="struct_b_i_n_d6___e_n_t_r_y.html">BIND6_ENTRY</a> object whose lifetime we need to get</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Lifetime</em>&nbsp;</td><td>value associated with the <a class="el" href="struct_b_i_n_d6___e_n_t_r_y.html">BIND6_ENTRY</a> object. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5bc115b3a9964b5e0f5b8ada2a1bc13d"></a><!-- doxytag: member="bind6.c::Bind6GetLinkLocalAddress" ref="5bc115b3a9964b5e0f5b8ada2a1bc13d" args="(NETIF_DEVICE *ptr_device, IP6N *IPAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bind6GetLinkLocalAddress           </td>
          <td>(</td>
          <td class="paramtype">NETIF_DEVICE *&nbsp;</td>
          <td class="paramname"> <em>ptr_device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IP6N *&nbsp;</td>
          <td class="paramname"> <em>IPAddress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function searches the BIND6 object and returns a LINK LOCAL Address for the device. An Error Condition conveys the fact that there IPv6 has not been initialized on this interface.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr_device</em>&nbsp;</td><td>The Network interface object whose LINK LOCAL Address is required. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>IPAddress</em>&nbsp;</td><td>The Link Local IP Address is returned</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Success</em>&nbsp;</td><td>- 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Error</em>&nbsp;</td><td>- -1 </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f6c092a5b8d262c612c3cd1539dab65a"></a><!-- doxytag: member="bind6.c::Bind6GetTable" ref="f6c092a5b8d262c612c3cd1539dab65a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_b_i_n_d6___e_n_t_r_y.html">BIND6_ENTRY</a>* Bind6GetTable           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function replicates the BIND6 Table and creates a duplicate copy which is then returned back to the callee. The replicated BIND table list needs to be cleaned by the callee. This function is available to system developers and can be called from outside kernel mode. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="bind6_8c.html#1f6449f36fedbf55e1de85b70895daf1">Bind6CleanTable</a></dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Head</em>&nbsp;</td><td>of the copy of the BIND6 </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8b6b77365cf0c6ab46397c8d5bd19f64"></a><!-- doxytag: member="bind6.c::Bind6IF2IPHost" ref="8b6b77365cf0c6ab46397c8d5bd19f64" args="(NETIF_DEVICE *ptr_device)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IP6N Bind6IF2IPHost           </td>
          <td>(</td>
          <td class="paramtype">NETIF_DEVICE *&nbsp;</td>
          <td class="paramname"> <em>ptr_device</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function returns the IPv6 address matching the <a class="el" href="struct_b_i_n_d6___e_n_t_r_y.html">BIND6_ENTRY</a> object.<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr_device</em>&nbsp;</td><td>The Network interface object whose IPv6 Address we are interested in.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Success</em>&nbsp;</td><td>- The IPv6 Address matching the interface </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Error</em>&nbsp;</td><td>- IPV6_UNSPECIFIED_ADDRESS (::) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="81a8cf859410daae4157316cb2c47022"></a><!-- doxytag: member="bind6.c::Bind6Msg" ref="81a8cf859410daae4157316cb2c47022" args="(uint Msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bind6Msg           </td>
          <td>(</td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>Msg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 Sevices intialization and resource messages for the BIND6 Module<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Msg</em>&nbsp;</td><td>The message event which needs to be handled.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Not</em>&nbsp;</td><td>Applicable. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="188a9101bf0177a1e7b9e94cd1cd17f7"></a><!-- doxytag: member="bind6.c::Bind6New" ref="188a9101bf0177a1e7b9e94cd1cd17f7" args="(NETIF_DEVICE *ptr_device, IP6N IPHost, IP6N IPMask, UINT32 ValidLifetime, UINT32 PreferredLifetime, UINT8 IsAnycast)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HANDLE Bind6New           </td>
          <td>(</td>
          <td class="paramtype">NETIF_DEVICE *&nbsp;</td>
          <td class="paramname"> <em>ptr_device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IP6N&nbsp;</td>
          <td class="paramname"> <em>IPHost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IP6N&nbsp;</td>
          <td class="paramname"> <em>IPMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&nbsp;</td>
          <td class="paramname"> <em>ValidLifetime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&nbsp;</td>
          <td class="paramname"> <em>PreferredLifetime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT8&nbsp;</td>
          <td class="paramname"> <em>IsAnycast</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 This function is used to create a new <a class="el" href="struct_b_i_n_d6___e_n_t_r_y.html">BIND6_ENTRY</a> Object with the specified properties.<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr_device</em>&nbsp;</td><td>Pointer to the NIMU Network Interface object on which the <a class="el" href="struct_b_i_n_d6___e_n_t_r_y.html">BIND6_ENTRY</a> object is to be created. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>IPHost</em>&nbsp;</td><td>IPv6 Address </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>IPMask</em>&nbsp;</td><td>IPv6 Mask </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ValidLifetime</em>&nbsp;</td><td>Valid Lifetime for which the address remains VALID </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>PreferredLifetime</em>&nbsp;</td><td>Preferred Lifetime for which the address remains VALID </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>IsAnycast</em>&nbsp;</td><td>Flag set to 1 if the address is an ANYCAST Address; else set to 0.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Success</em>&nbsp;</td><td>- Handle to the new <a class="el" href="struct_b_i_n_d6___e_n_t_r_y.html">BIND6_ENTRY</a> Object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Error</em>&nbsp;</td><td>- 0 </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="937231b28b0bb83877c47f3f5ef9938e"></a><!-- doxytag: member="bind6.c::Bind6SetLifetime" ref="937231b28b0bb83877c47f3f5ef9938e" args="(HANDLE hbind6Obj, UINT32 Lifetime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bind6SetLifetime           </td>
          <td>(</td>
          <td class="paramtype">HANDLE&nbsp;</td>
          <td class="paramname"> <em>hbind6Obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&nbsp;</td>
          <td class="paramname"> <em>Lifetime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function sets the Lifetime matching the <a class="el" href="struct_b_i_n_d6___e_n_t_r_y.html">BIND6_ENTRY</a> object.<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hbind6Obj</em>&nbsp;</td><td>Handle to the <a class="el" href="struct_b_i_n_d6___e_n_t_r_y.html">BIND6_ENTRY</a> object whose lifetime we need to get </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Lifetime</em>&nbsp;</td><td>New Lifetime value to be associated.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Not</em>&nbsp;</td><td>Applicable. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr size="1"><small>
Copyright  2009, Texas Instruments Incorporated</small>
</body>
</html>
