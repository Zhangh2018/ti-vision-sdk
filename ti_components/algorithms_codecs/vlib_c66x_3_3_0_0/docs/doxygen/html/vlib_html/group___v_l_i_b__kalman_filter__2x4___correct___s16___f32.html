<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>VLIB: VLIB_kalmanFilter_2x4_Correct_S16_F32</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="tilogo.gif"></a></td>
  <td bgcolor="red"><img src="titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>VLIB_kalmanFilter_2x4_Correct_S16_F32</h1><hr><a name="_details"></a><h2>Detailed Description</h2>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l_i_b__kalman_filter__2x4___correct___s16___f32.html#gbb48f78fb01f521208b353bbaae76530">VLIB_kalmanFilter_2x4_Correct_S16_F32</a> (<a class="el" href="structvlib__kalman_filter__2x4___s16___f32.html">VLIB_kalmanFilter_2x4_S16_F32</a> *KF, const int16_t *restrict Z, VLIB_F32 *restrict Residual)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="gbb48f78fb01f521208b353bbaae76530"></a><!-- doxytag: member="c66/VLIB_kalmanFilter_2x4_Correct_S16_F32.h::VLIB_kalmanFilter_2x4_Correct_S16_F32" ref="gbb48f78fb01f521208b353bbaae76530" args="(VLIB_kalmanFilter_2x4_S16_F32 *KF, const int16_t *restrict Z, VLIB_F32 *restrict Residual)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VLIB_kalmanFilter_2x4_Correct_S16_F32           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvlib__kalman_filter__2x4___s16___f32.html">VLIB_kalmanFilter_2x4_S16_F32</a> *&nbsp;</td>
          <td class="paramname"> <em>KF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16_t *restrict&nbsp;</td>
          <td class="paramname"> <em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VLIB_F32 *restrict&nbsp;</td>
          <td class="paramname"> <em>Residual</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Description:</b></dt><dd>The Kalman filter is implemented as two separate functions, one for the time update (or prediction) and the other for the measurement update (or correction). This implementation assumes a pre-determined fixed dimension for the observation and state vectors. The observation vector should be of dimension 2x1,and the state vector should have dimension 4x1. The state of the Kalman filter is defined using the following structure. The expected bit precision for each matrix is noted in the comments. The variable sD and mD represent the dimensionality of the state and measurement vectors and have values of 4 and 2 respectively <div class="fragment"><pre class="fragment">
   typedef struct VLIB_kalmanFilter_2x4_S16_F32 {
    VLIB_F32 transition[sD_2x4*sD_2x4];          //  state transition matrix
    VLIB_F32 errorCov[sD_2x4*sD_2x4];            // priori error covariance matrix
    VLIB_F32 predictedErrorCov[sD_2x4*sD_2x4];   //  predicted error covariance matrix
    int16_t state[sD_2x4];                      // state of the process
    VLIB_F32 predictedState[sD_2x4];             // predicted state of the process, X1
    VLIB_F32 measurement[mD_2x4*sD_2x4];         // measurement matrix (relating state to measurement)
    VLIB_F32 processNoiseCov[sD_2x4*sD_2x4];     // process noise covariance matrix
    VLIB_F32 measurementNoiseCov[mD_2x4*mD_2x4]; // measurement noise covariance matrix
    VLIB_F32 kalmanGain[sD_2x4*mD_2x4];          // Kalman gain, K
    VLIB_F32 temp1[sD_2x4*sD_2x4];
    VLIB_F32 temp2[sD_2x4*sD_2x4];
    VLIB_F32 temp3[sD_2x4*sD_2x4];
     } VLIB_kalmanFilter_2x4_S16_F32;
</pre></div> In VLIB_kalmanFilter_2x4_Correct_S16_F32, input and intermediate variables are int16_t type output is VLIB_F32 type </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>*KF</em>&nbsp;</td><td>Pointer to struct VLIB_kalmanFilter_4x6_S16_F32 </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>*Z</em>&nbsp;</td><td>Pointer to array (dimension 2x1) containing measurement </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>*Residual</em>&nbsp;</td><td>Pointer to array to store the residual error</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Implementation Notes:</b></dt><dd><ul>
<li>This code is compatible with C66x floating-point processors </li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Benchmarks:</b></dt><dd>See VLIB_Test_Report.html for cycle and memory information. </dd></dl>

</div>
</div><p>
<hr size="1"><small>
Copyright  2015, Texas Instruments Incorporated</small>
</body>
</html>
