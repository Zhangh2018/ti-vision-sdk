/*****************************************************************/
/*                                                               */
/*      Initialization of IPU for ADAS-Low.                      */
/*                                                               */
/*****************************************************************/

/******************************************************************
*   Version: 0.1
*   Date: 18th - November - 2013
*   Discription: This gel file contains
*         1. DDR3 initialization with pll configuration(532MHz).
*         2. DSP cores enable.
*   History: 1. Initial gel file.
******************************************************************/

/*******************************************************************/
/* This GEL file is loaded on the command line of Code Composer    */
/* The StartUp() function is called every time you start           */
/* Code Composer.  You can customize this function to              */
/* initialize wait states or to perform other initialization.      */
/*                                                                 */
/*******************************************************************/

#define WR_MEM_32(addr, data)   *(unsigned int*)(addr) =(unsigned int)(data)
#define RD_MEM_32(addr)         *(unsigned int*)(addr)
#define uint32_t                unsigned int

#define DEBUG_PRINT     (0)

#define DSS_CM_CORE         (0x4a009100)
#define CAM_CM_CORE         (0x4a009000)
#define ISS_CM_CORE         (0x4a005760)
#define L4PER_CM_CORE       (0x4a009700)

/* CLK CTRL OFFSETS */
#define DSS_CM_CORE__CM_DSS_CLKSTCTRL                             0x00ul

/* CLKSTCTRL modes */
#define SW_SLEEP        (0x1)
#define SW_WKUP         (0x2)
#define HW_AUTO         (0x3)

/* CLKCTRL modes */
#define MODE_DISABLED   (0x0)
#define MODE_AUTO       (0x1)
#define MODE_ENABLED    (0x2)

#define CLKSTCTRL_TIMEOUOT  (300)
#define CLKCTRL_TIMEOUOT  (300)

#define L4PER_CM_CORE__CM_L4PER_UART1_CLKCTRL                       0x140ul
#define L4PER_CM_CORE__CM_L4PER_UART2_CLKCTRL                       0x148ul
#define DSS_CM_CORE__CM_DSS_DSS_CLKCTRL                             0x020ul
#define CAM_CM_CORE__CM_CAM_CLKSTCTRL                               0x00ul
#define CAM_CM_CORE__CM_CAM_VIP1_CLKCTRL                            0x020ul

#define ISS_CM_CORE__CM_ISS_CLKSTCTRL                               (0x0ul)
#define ISS_CM_CORE__CM_ISS_CLKCTRL                                 (0x4ul)

#define L4_CFG_TARG                  0x4A000000
#define CTRL_MODULE_CORE             (L4_CFG_TARG + 0x2000)

#define CTRL_CORE_CONTROL_IO_2      (CTRL_MODULE_CORE  + 0x558)

/******************************************************************
*   DDR3 initialization starts here...
******************************************************************/

menuitem "DDR Memory config"

/*******************************************************************************************
*
*   ADAS_LOW_DDR3_532MHz_Config(): Initialization of DDR3 in 532NHz mode for ADAS-Low.
*
*******************************************************************************************/
#define CM_CLKMODE_DPLL(DPLL_BASE_ADDRESS)      RD_MEM_32(DPLL_BASE_ADDRESS)
#define CM_IDLEST_DPLL(DPLL_BASE_ADDRESS)       RD_MEM_32(DPLL_BASE_ADDRESS + 0x04)
#define CM_AUTOIDLE_DPLL(DPLL_BASE_ADDRESS)     RD_MEM_32(DPLL_BASE_ADDRESS + 0x08)
#define CM_CLKSEL_DPLL(DPLL_BASE_ADDRESS)       RD_MEM_32(DPLL_BASE_ADDRESS + 0x0C)
#define CM_DIV_M2_DPLL(DPLL_BASE_ADDRESS)       RD_MEM_32(DPLL_BASE_ADDRESS + 0x10)
#define CM_DIV_M3_DPLL(DPLL_BASE_ADDRESS)       RD_MEM_32(DPLL_BASE_ADDRESS + 0x14)
#define CM_DIV_H11_DPLL(DPLL_BASE_ADDRESS)      RD_MEM_32(DPLL_BASE_ADDRESS + 0x18)
#define CM_DIV_H12_DPLL(DPLL_BASE_ADDRESS)      RD_MEM_32(DPLL_BASE_ADDRESS + 0x1C)
#define CM_DIV_H13_DPLL(DPLL_BASE_ADDRESS)      RD_MEM_32(DPLL_BASE_ADDRESS + 0x20)
#define CM_DIV_H14_DPLL(DPLL_BASE_ADDRESS)      RD_MEM_32(DPLL_BASE_ADDRESS + 0x24)
#define CM_DIV_H21_DPLL(DPLL_BASE_ADDRESS)      RD_MEM_32(DPLL_BASE_ADDRESS + 0x30)
#define CM_DIV_H22_DPLL(DPLL_BASE_ADDRESS)      RD_MEM_32(DPLL_BASE_ADDRESS + 0x34)
#define CM_DIV_H23_DPLL(DPLL_BASE_ADDRESS)      RD_MEM_32(DPLL_BASE_ADDRESS + 0x38)
#define CM_DIV_H24_DPLL(DPLL_BASE_ADDRESS)      RD_MEM_32(DPLL_BASE_ADDRESS + 0x3C)

/******************************************************************
*   dpll setting for 532MHz
******************************************************************/
hotmenu OnTargetConnect()
{
    ADAS_LOW_DDR3_532MHz_Config();
    dssinit();
    vipinit();
    issinit();
    uartinit();
}

hotmenu uartinit()
{
     prcm_set_module_mode(L4PER_CM_CORE,L4PER_CM_CORE__CM_L4PER_UART1_CLKCTRL,MODE_ENABLED,0x00000000,0x00000000);
     prcm_set_module_mode(L4PER_CM_CORE,L4PER_CM_CORE__CM_L4PER_UART2_CLKCTRL,MODE_ENABLED,0x00000000,0x00000000);
}

hotmenu vipinit()
{
    prcm_set_clkdomain_state(CAM_CM_CORE, CAM_CM_CORE__CM_CAM_CLKSTCTRL, SW_WKUP );
    prcm_set_module_mode(CAM_CM_CORE, CAM_CM_CORE__CM_CAM_VIP1_CLKCTRL, MODE_AUTO, 0x00000000,0x00000000);
}
hotmenu dssinit()
{
    uint32_t reg_val,regAddr;
    uint32_t regVal;

    GEL_TextOut("--->>> Starting DSS Init ... <<<---\n");
    WR_MEM_32(0x55080004, 0x1E); //CACHE Enabled

    WR_MEM_32(0x550809A0, 0x55020000);

    #define IPU_MMU_CFG 0x40000000

    /*Small Page*/
    regAddr = IPU_MMU_CFG;
    regAddr += 0x920;
    WR_MEM_32(regAddr,         0x00000000); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x40000000); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x00004000); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x00008000); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x20000000); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x0000c000); regAddr += 0x4;

    regAddr = IPU_MMU_CFG;
    regAddr += 0x9A0;
    WR_MEM_32(regAddr,         0x55020000); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x55080000); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x55024000); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x55028000); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x55020000); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x5502c000); regAddr += 0x4;

    regAddr = IPU_MMU_CFG;
    regAddr += 0xA20;
    WR_MEM_32(regAddr,         0x0001000B); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x0000000B); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x00010007); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x00000007); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x00000007); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x00000007); regAddr += 0x4;

    /* Policy Register */
    regAddr = IPU_MMU_CFG;
    regAddr += 0x840;
    WR_MEM_32(regAddr,         0x00000000); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x00000000); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x00000000); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x00000000); regAddr += 0x4;

    regAddr = IPU_MMU_CFG;
    regAddr += 0x800;
    WR_MEM_32(regAddr,         0x40000000); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x80000000); regAddr += 0x4;
    WR_MEM_32(regAddr,         0xA0000000); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x60000000); regAddr += 0x4;

    /* Physical Address */
    regAddr = IPU_MMU_CFG;
    regAddr += 0x820;
    WR_MEM_32(regAddr,         0x40000000); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x80000000); regAddr += 0x4;
    WR_MEM_32(regAddr,         0xA0000000); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x40000000); regAddr += 0x4;

    /* Policy Register */
    regAddr = IPU_MMU_CFG;
    regAddr += 0x840;
    WR_MEM_32(regAddr,         0x00000007); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x000B0007); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x00020007); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x00000007); regAddr += 0x4;

    /*Small Page*/
    regAddr = IPU_MMU_CFG;
    regAddr += 0x920;
    WR_MEM_32(regAddr,         0x00000000); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x40000000); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x00004000); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x00008000); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x0000c000); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x20000000); regAddr += 0x4;

    regAddr = IPU_MMU_CFG;
    regAddr += 0x9A0;
    WR_MEM_32(regAddr,         0x55020000); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x55080000); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x55024000); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x55028000); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x5502c000); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x55020000); regAddr += 0x4;

    regAddr = IPU_MMU_CFG;
    regAddr += 0xA20;
    WR_MEM_32(regAddr,         0x0001000B); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x0000000B); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x00010007); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x00000007); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x00000007); regAddr += 0x4;
    WR_MEM_32(regAddr,         0x00000007); regAddr += 0x4;

    WR_MEM_32(0x55020000, 0x00001000);
    WR_MEM_32(0x55020004, 0x00000009);
    WR_MEM_32(0x55020008, 0xE7FEE7FE);
    WR_MEM_32(0x5502000C, 0x00000009); //HF handler

    WR_MEM_32(0x4A00913c,0x2); /* SDVENC PLL Power Control */

    /* To Enable VID Clock and DIV it by 4 */
    /* MMR_LOCK_1 reg unlock*/
    WR_MEM_32(0x4A002540, 0x2FF1AC2B);
    /* MMR_LOCK_2 reg unlock*/
    WR_MEM_32(0x4A002544, 0xF757FDC0);

    regVal = RD_MEM_32(0x4A003C64);
    regVal |= 0x00800000;
    WR_MEM_32(0x4A003C64,regVal);

    /*M2 - DIV/2*/
    regVal = RD_MEM_32(0x4A003C64);
    regVal &= ~(0x003F0000);
    regVal |= 0x00080000;
    WR_MEM_32(0x4A003C64,regVal);

    /*Enable-DIV Select*/
    regVal = RD_MEM_32(0x4A003C64);
    regVal &= ~(0x10000000);
    regVal |= 0x10000000;
    WR_MEM_32(0x4A003C64,regVal);

    /*Toggle - 1*/
    regVal = RD_MEM_32(0x4A003C64);
    regVal &= ~(0x00400000);
    regVal |= 0x00400000;
    WR_MEM_32(0x4A003C64,regVal);

    /*Toggle - 0*/
    regVal = RD_MEM_32(0x4A003C64);
    regVal &= ~(0x00400000);
    WR_MEM_32(0x4A003C64,regVal);

    prcm_set_clkdomain_state(DSS_CM_CORE,DSS_CM_CORE__CM_DSS_CLKSTCTRL,SW_WKUP );

    prcm_set_dss_mode(DSS_CM_CORE,DSS_CM_CORE__CM_DSS_DSS_CLKCTRL,MODE_ENABLED);

    GEL_TextOut("--->>> END DSS Init ... <<<---\n");
}

prcm_set_module_mode(uint32_t module_base, uint32_t module_offset, uint32_t mode, uint32_t extrabits, uint32_t extrabitsMask)
{
    uint32_t reg_val;
    uint32_t timeout = CLKCTRL_TIMEOUOT;

    if (DEBUG_PRINT)
    {
        GEL_TextOut("module_base:   %x\n",,,,, module_base);
        GEL_TextOut("module_offset: %x\n",,,,, module_offset);
    }

    reg_val = RD_MEM_32(module_base + module_offset) & ~(extrabitsMask | 0x00000003);
    WR_MEM_32(module_base+module_offset, (reg_val | (extrabits & extrabitsMask) | (mode & 0x3)));

    if (DEBUG_PRINT)
    {
        GEL_TextOut("\tWaiting for module IDLE status....\n");
    }
    while(((RD_MEM_32(module_base + module_offset) & 0x00030000) != 0) && (timeout>0))
    {
        timeout--;
    }
    if (DEBUG_PRINT)
    {
        if (timeout==0)
        {
            GEL_TextOut("module_base:   %x\n",,,,, module_base);
            GEL_TextOut("module_offset: %x\n",,,,, module_offset);
            GEL_TextOut("\tTIMEOUT\n");
        }
        else
        {
            GEL_TextOut("\tDONE\n");
        }
    }
}
prcm_set_clkdomain_state(uint32_t module_base, uint32_t module_offset, uint32_t state)
{
    uint32_t reg_val;
    uint32_t timeout = CLKSTCTRL_TIMEOUOT;

    if (DEBUG_PRINT)
    {
        GEL_TextOut("module_base:   %x\n",,,,, module_base);
        GEL_TextOut("module_offset: %x\n",,,,, module_offset);
    }

    reg_val = RD_MEM_32(module_base+module_offset);
    WR_MEM_32(module_base+module_offset, ((reg_val & ~(0x3)) | (state & 0x3)));

    /*if (DEBUG_PRINT)
    {
        GEL_TextOut("\tWaiting for clock active....\n");
    }
    while( ((RD_MEM_32(module_base + module_offset) & 0x100) != 0x100) && (timeout>0) )
    {
        timeout--;
    }
    if (DEBUG_PRINT)
    {
        if (timeout==0)
        {
            GEL_TextOut("\tTIMEOUT\n");
        }
        else
        {
            GEL_TextOut("\tDONE\n");
        }
    }*/
}

prcm_set_dss_mode(uint32_t module_base, uint32_t module_offset, uint32_t mode)
{
    uint32_t reg_val;
    uint32_t timeout = CLKCTRL_TIMEOUOT;

    if (DEBUG_PRINT)
    {
        GEL_TextOut("module_base:   %x\n",,,,, module_base);
        GEL_TextOut("module_offset: %x\n",,,,, module_offset);
    }

    /* DESHDCP Clock ENABLE for DSS */
    WR_MEM_32(CTRL_CORE_CONTROL_IO_2, RD_MEM_32(CTRL_CORE_CONTROL_IO_2) | 0x1);

    reg_val = RD_MEM_32(module_base + module_offset);
    reg_val = (reg_val & ~0x3) | 0x00003F00 | mode;
    WR_MEM_32(module_base + module_offset, reg_val);

    if (DEBUG_PRINT)
    {
        GEL_TextOut("\tWaiting for DSS module IDLE status....\n");
    }
    while(((RD_MEM_32(module_base + module_offset) & 0x00030000) != 0) && (timeout>0))
    {
        timeout--;
    }
    if (DEBUG_PRINT)
    {
        if (timeout==0)
        {
            GEL_TextOut("module_base:   %x\n",,,,, module_base);
            GEL_TextOut("module_offset: %x\n",,,,, module_offset);
            GEL_TextOut("\tTIMEOUT\n");
        }
        else
        {
            GEL_TextOut("\tDONE\n");
        }
    }
}

dpll_ddr_config()
{
    GEL_TextOut("--->>> PLL Configuration... <<<---\n");
    /* CM_CLKSEL_DPLL_DDR DPLL MULT */
    WR_MEM_32(0x4A00521c, 0x10a04);
    /* CM_DIV_M2_DPLL_DDR */
    WR_MEM_32(0x4A005220, 0x2);
    /* CM_DIV_M3_DPLL_DDR  */
    WR_MEM_32(0x4A005224, 0x1);
    /* CM_DIV_H11_DPLL_DDR */
    WR_MEM_32(0x4A005228, 0x8);
    /* Put DPLL into lock mode */
    WR_MEM_32(0x4A005210, 0x7);
    GEL_TextOut("--->>> PLL Configuration Done... <<<---\n");
}

/******************************************************************
*   Initializing DDR3 in 532Mhz
******************************************************************/

hotmenu issinit()
{
    GEL_TextOut("--->>> Starting ISS Init... <<<---\n");

    WR_MEM_32(0x550809A0, 0x55020000); /* Pointing 0x0 to RAM */
    WR_MEM_32(0x55020000, 0x1000); /* while 1 loop at 0x0 location */
    WR_MEM_32(0x55020004, 0x9); /* Entry point to 0x8 */
    WR_MEM_32(0x55080004, 0x1C); /* Disable cache */

    prcm_set_clkdomain_state(ISS_CM_CORE, ISS_CM_CORE__CM_ISS_CLKSTCTRL, SW_WKUP);
    prcm_set_module_mode(ISS_CM_CORE, ISS_CM_CORE__CM_ISS_CLKCTRL, MODE_AUTO, 0x00000000, 0x00000000);

    //WR_MEM_32(0x4A005760, 0x00000002); //ISS CLKSTCTRL
    //WR_MEM_32(0x4A005764, 0x00000001); //ISS CLKCTRL
    WR_MEM_32(0x52000084, 0xFFFFFFFF); //ISS All Enable

    WR_MEM_32(0x52020010, 0x00000001); //SIMCOP RESET
    WR_MEM_32(0x52012010, 0x00000001); //CAL RESET
    WR_MEM_32(0x52040010, 0x00000002); //ISP RESET
    WR_MEM_32(0x52000010, 0x00000001); //ISS RESET

    WR_MEM_32(0x4A009100, 0x00000002); //DSS CLKSTCTRL
    WR_MEM_32(0x4A009120, 0x00003F01); //DSS CLKCTRL

    GEL_TextOut("--->>> ISS Init Done... <<<---\n");
}

hotmenu ADAS_LOW_DDR3_532MHz_Config()
{
    uint32_t loop_index;
    uint32_t dummy_read;
    uint32_t temp;

    uint32_t temp;

    temp = RD_MEM_32(0x4A005300);
    temp |= 0x3;
    WR_MEM_32(0x4A005300, temp);

    temp = RD_MEM_32(0x4A008B00);
    temp |= 0x2;
    WR_MEM_32(0x4A008B00, temp);


    // WR_MEM_32(0x4A005210, 0x00000007);
    GEL_TextOut("--->>> DDR3 Initialization is in progress ... <<<---\n");

    /* DDR PLL config */
    dpll_ddr_config();

    // EMIF - DDR Overall Configuration  -
    if (DEBUG_PRINT)
    {
        GEL_TextOut(">> START ==> Overall DDR configuration\n");
    }

    // EMIF - DDR IOs CONFIG
    if (DEBUG_PRINT)
    {
        GEL_TextOut(">> START ==> EMIF1 DDR IOs config (CTRL_MODULE_CORE_PAD module)\n");
    }

    WR_MEM_32(0x4A005110, 0x00000001);     // DLL override disable =0 ; enable = 1

    WR_MEM_32(0x4A002E30, 0x4A4A4A4A);     //CONTROL_DDR3CH1_0 -- channel_1 CMDs / 40Ohm Ron (011) / SR=slowest-3 (111) on CMDs but CLK SR=slow (011) / No pulls (00)
    WR_MEM_32(0x4A002E34, 0x4A4A4A4A);     //CONTROL_DDR3CH2_0 -- channel_2 CMDs / 40Ohm Ron (011) / SR=slowest-3 (111) on CMDs but CLK SR=slow (011) / No pulls (00)
    WR_MEM_32(0x4A002E38, 0x4A4A4A4A);     //CONTROL_DDRCH1_0 -- channel_1 DATA byte 0+1 / 40Ohm Ron (011) / SR=faster (001) / Pull-up (10) on DQS / No pull (00) on DQ
    WR_MEM_32(0x4A002E3C, 0x4A4A4A4A);     //CONTROL_DDRCH1_1 -- channel_1 DATA byte 2+3 / 40Ohm Ron (011) / SR=faster (001) / Pull-up (10) on DQS / No pull (00) on DQ
    WR_MEM_32(0x4A002E40, 0x4A4A4A4A);     //CONTROL_DDRCH2_0 -- channel_2 DATA byte 0+1 / 40Ohm Ron (011) / SR=faster (001) / Pull-up (10) on DQS / No pull (00) on DQ
    WR_MEM_32(0x4A002E44, 0x4A4A4A4A);     //CONTROL_DDRCH2_1 -- channel_2 DATA byte 2+3 / 40Ohm Ron (011) / SR=faster (001) / Pull-up (10) on DQS / No pull (00) on DQ
    WR_MEM_32(0x4A002E48, 0x004A4A00);     //CONTROL_LPDDR2CH1_0 -- channel_1 LPDDR2 CMD PHYs IOs not used on OMAP5432
    WR_MEM_32(0x4A002E4C, 0x004A4A00);     //CONTROL_CONTROL_LPDDR2CH1_1 -- channel_1 LPDDR2 CMD PHYs IOs not used on OMAP5432

    WR_MEM_32(0x4A002E50, 0x0009CE60);     //DDRIO_0 -- VREF cells (CH1 DQ3/0 INT 2uA / Cap to GND / CMD1/0 DDR3 INT-OUT 32uA / Cap to GND)
    WR_MEM_32(0x4A002E54, 0x04E73000);     //DDRIO_1 -- VREF cells (CH1 OUT 32uA Cap to GND / CH2 DQ3/0 INT 2uA / Cap to GND / CH2 OUT 32uA Cap to GND)
    WR_MEM_32(0x4A002E58, 0x00000000);     //DDRIO_2 -- VREF cells (LPDDR2 CH1/2 CA INT/OUT - unused on OMAP5432)
    WR_MEM_32(0x4A002E88, 0x9A600000);     //CONTROL_DDRIO_EXT_0


    // EMIF1 PHYs extra CONFIG - CTRL_MODULE_WKUP
    if (DEBUG_PRINT)
    {
        GEL_TextOut(">> START ==> DDR PHY config (CTRL_MODULE_WKUP module)\n");
    }

    WR_MEM_32(0x4AE0C144, 0x00010107);     //EMIF1_SDRAM_CONFIG_EXT -- cslice_en[2:0]=111 / Local_odt=01 / dyn_pwrdn=1 / dis_reset=1 / rd_lvl_samples=11 (128)

    if(0)
    {
        WR_MEM_32(0x4AE0CDC8, 0x00000000);     //EFUSE0 -- IOs p/n setting since devices are not yet trimmed
        WR_MEM_32(0x4AE0CDCC, 0x00000000);     //EFUSE1 -- IOs p/n setting since devices are not yet trimmed
        WR_MEM_32(0x4AE0CDD0, 0x00000000);     //EFUSE2 -- IOs p/n setting since devices are not yet trimmed
        WR_MEM_32(0x4AE0CDD4, 0x00000000);     //EFUSE3 -- IOs p/n setting since devices are not yet trimmed
    }

    // EMIF1 controller CONFIG
    if (DEBUG_PRINT)
    {
        GEL_TextOut(">> START ==> EMIF1 ctrl + associated DDR PHYs initial config (EMIF1 module)\n");
    }

    WR_MEM_32(0x4C000018, 0x1F7FCC1D);     //SDRAM_TIM_1 --
    WR_MEM_32(0x4C00001C, 0x1F7FCC1D);     //SDRAM_TIM_1_SHDW --
    WR_MEM_32(0x4C000020, 0x5071975D);     //SDRAM_TIM_2 --
    WR_MEM_32(0x4C000024, 0x5071975D);     //SDRAM_TIM_2_SHDW --
    WR_MEM_32(0x4C000028, 0x0EDF972F);     //SDRAM_TIM_3 --
    WR_MEM_32(0x4C00002C, 0x0EDF972F);     //SDRAM_TIM_3_SHDW --
    WR_MEM_32(0x4C000030, 0x11220C0C);     //LPDDR2_NVM_TIM --
    WR_MEM_32(0x4C000034, 0x11220C0C);     //LPDDR2_NVM_TIM_SHDW --
    WR_MEM_32(0x4C000038, 0x00000000);     //PWR_MGMT_CTRL --
    WR_MEM_32(0x4C00003C, 0x00000000);     //PWR_MGMT_CTRL_SHDW --
    WR_MEM_32(0x4C000054, 0x07770000);     //OCP_CONFIG --
    WR_MEM_32(0x4C000060, 0x00002011);     //IODFT_TLGC --
    WR_MEM_32(0x4C000098, 0x00090000);     //DLL_CALIB_CTRL --
    WR_MEM_32(0x4C00009C, 0x00090000);     //DLL_CALIB_CTRL_SHDW --
    WR_MEM_32(0x4C0000C8, 0x00000000);     //ZQ_CONFIG --
    WR_MEM_32(0x4C0000CC, 0x00000000);     //TEMP_ALERT_CONFIG --
    WR_MEM_32(0x4C0000D4, 0x00000000);     //RDWR_LVL_RMP_WIN --
    WR_MEM_32(0x4C0000D8, 0x00000000);     //RDWR_LVL_RMP_CTRL --

    WR_MEM_32(0x4C0000DC, 0x00000000);     //RDWR_LVL_CTRL -- force RDWRLVLFULL_START=0 for now / No incremental LVL
    WR_MEM_32(0x4C0000E4, 0x0020080C);     //DDR_PHY_CTRL_1 -- force invert_clkout=0 for now
    WR_MEM_32(0x4C0000E8, 0x0020080C);     //DDR_PHY_CTRL_1_SHDW -- force invert_clkout=0 for now
    WR_MEM_32(0x4C0000EC, 0x00000000);     //DDR_PHY_CTRL_2 --
    WR_MEM_32(0x4C000100, 0x00000000);     //PRI_COS_MAP --
    WR_MEM_32(0x4C000104, 0x00000000);     //CONNID_COS_1_MAP --
    WR_MEM_32(0x4C000108, 0x00000000);     //CONNID_COS_2_MAP --
    WR_MEM_32(0x4C000120, 0x00000305);     //RD_WR_EXEC_THRSH --
    WR_MEM_32(0x4C000124, 0x000FFFFF);     //COS_CONFIG --
    WR_MEM_32(0x4C000200, 0x04020080);     //EXT_PHY_CTRL_1 --
    WR_MEM_32(0x4C000204, 0x04020080);     //EXT_PHY_CTRL_1_SHDW --
    WR_MEM_32(0x4C000208, 0x00000000);     //EXT_PHY_CTRL_2 --
    WR_MEM_32(0x4C00020C, 0x00000000);     //EXT_PHY_CTRL_2_SHDW --
    WR_MEM_32(0x4C000210, 0x00000000);     //EXT_PHY_CTRL_3 --
    WR_MEM_32(0x4C000214, 0x00000000);     //EXT_PHY_CTRL_3_SHDW --
    WR_MEM_32(0x4C000218, 0x00000000);     //EXT_PHY_CTRL_4 --
    WR_MEM_32(0x4C00021C, 0x00000000);     //EXT_PHY_CTRL_4_SHDW --
    WR_MEM_32(0x4C000220, 0x00000000);     //EXT_PHY_CTRL_5 --
    WR_MEM_32(0x4C000224, 0x00000000);     //EXT_PHY_CTRL_5_SHDW --
    WR_MEM_32(0x4C000228, 0x00000000);     //EXT_PHY_CTRL_6 --
    WR_MEM_32(0x4C00022C, 0x00000000);     //EXT_PHY_CTRL_6_SHDW --
    WR_MEM_32(0x4C000230, 0x00350035);     //EXT_PHY_CTRL_7 --
    WR_MEM_32(0x4C000234, 0x00350035);     //EXT_PHY_CTRL_7_SHDW --
    WR_MEM_32(0x4C000238, 0x00350035);     //EXT_PHY_CTRL_8 --
    WR_MEM_32(0x4C00023C, 0x00350035);     //EXT_PHY_CTRL_8_SHDW --
    WR_MEM_32(0x4C000240, 0x00350035);     //EXT_PHY_CTRL_9 --
    WR_MEM_32(0x4C000244, 0x00350035);     //EXT_PHY_CTRL_9_SHDW --
    WR_MEM_32(0x4C000248, 0x00350035);     //EXT_PHY_CTRL_10 --
    WR_MEM_32(0x4C00024C, 0x00350035);     //EXT_PHY_CTRL_10_SHDW --
    WR_MEM_32(0x4C000250, 0x00350035);     //EXT_PHY_CTRL_11 --
    WR_MEM_32(0x4C000254, 0x00350035);     //EXT_PHY_CTRL_11_SHDW --
    WR_MEM_32(0x4C000258, 0x00400040);     //EXT_PHY_CTRL_12 --
    WR_MEM_32(0x4C00025C, 0x00400040);     //EXT_PHY_CTRL_12_SHDW --
    WR_MEM_32(0x4C000260, 0x00400040);     //EXT_PHY_CTRL_13 --
    WR_MEM_32(0x4C000264, 0x00400040);     //EXT_PHY_CTRL_13_SHDW --
    WR_MEM_32(0x4C000268, 0x00400040);     //EXT_PHY_CTRL_14 --
    WR_MEM_32(0x4C00026C, 0x00400040);     //EXT_PHY_CTRL_14_SHDW --
    WR_MEM_32(0x4C000270, 0x00400040);     //EXT_PHY_CTRL_15 --
    WR_MEM_32(0x4C000274, 0x00400040);     //EXT_PHY_CTRL_15_SHDW --
    WR_MEM_32(0x4C000278, 0x00400040);     //EXT_PHY_CTRL_16 --
    WR_MEM_32(0x4C00027C, 0x00400040);     //EXT_PHY_CTRL_16_SHDW --
    WR_MEM_32(0x4C000280, 0x00000000);     //EXT_PHY_CTRL_17 --
    WR_MEM_32(0x4C000284, 0x00000000);     //EXT_PHY_CTRL_17_SHDW --
    WR_MEM_32(0x4C000288, 0x00000000);     //EXT_PHY_CTRL_18 --
    WR_MEM_32(0x4C00028C, 0x00000000);     //EXT_PHY_CTRL_18_SHDW --
    WR_MEM_32(0x4C000290, 0x00000000);     //EXT_PHY_CTRL_19 --
    WR_MEM_32(0x4C000294, 0x00000000);     //EXT_PHY_CTRL_19_SHDW --
    WR_MEM_32(0x4C000298, 0x00000000);     //EXT_PHY_CTRL_20 --
    WR_MEM_32(0x4C00029C, 0x00000000);     //EXT_PHY_CTRL_20_SHDW --
    WR_MEM_32(0x4C0002A0, 0x00000000);     //EXT_PHY_CTRL_21 --
    WR_MEM_32(0x4C0002A4, 0x00000000);     //EXT_PHY_CTRL_21_SHDW --
    WR_MEM_32(0x4C0002A8, 0x00800080);     //EXT_PHY_CTRL_22 --
    WR_MEM_32(0x4C0002AC, 0x00800080);     //EXT_PHY_CTRL_22_SHDW --
    WR_MEM_32(0x4C0002B0, 0x00800080);     //EXT_PHY_CTRL_23 --
    WR_MEM_32(0x4C0002B4, 0x00800080);     //EXT_PHY_CTRL_23_SHDW --
    WR_MEM_32(0x4C0002B8, 0x40010080);     //EXT_PHY_CTRL_24 --
    WR_MEM_32(0x4C0002BC, 0x40010080);     //EXT_PHY_CTRL_24_SHDW --
    WR_MEM_32(0x4C0002C0, 0x08102040);     //EXT_PHY_CTRL_25 --
    WR_MEM_32(0x4C0002C4, 0x08102040);     //EXT_PHY_CTRL_25_SHDW --
    WR_MEM_32(0x4C0002C8, 0x01500150);     //EXT_PHY_CTRL_26 --
    WR_MEM_32(0x4C0002CC, 0x01500150);     //EXT_PHY_CTRL_26_SHDW --
    WR_MEM_32(0x4C0002D0, 0x01500150);     //EXT_PHY_CTRL_27 --
    WR_MEM_32(0x4C0002D4, 0x01500150);     //EXT_PHY_CTRL_27_SHDW --
    WR_MEM_32(0x4C0002D8, 0x01500150);     //EXT_PHY_CTRL_28 --
    WR_MEM_32(0x4C0002DC, 0x01500150);     //EXT_PHY_CTRL_28_SHDW --
    WR_MEM_32(0x4C0002E0, 0x01500150);     //EXT_PHY_CTRL_29 --
    WR_MEM_32(0x4C0002E4, 0x01500150);     //EXT_PHY_CTRL_29_SHDW --
    WR_MEM_32(0x4C0002E8, 0x01500150);     //EXT_PHY_CTRL_30 --
    WR_MEM_32(0x4C0002EC, 0x01500150);     //EXT_PHY_CTRL_30_SHDW --
    WR_MEM_32(0x4C000014, 0x00000F3D);     //SDRAM_REF_CTRL_SHDW --
    WR_MEM_32(0x4C000010, 0x12000F3D);     //SDRAM_REF_CTRL --
    WR_MEM_32(0x4C00000C, 0x00000010);     //SDRAM_CONFIG_2 --
    WR_MEM_32(0x4C000008, 0x61A32232);     //SDRAM_CONFIG --

    // EMIF1 controller CONFIG - enter self-refresh and configure invert_clkout
    if (DEBUG_PRINT)
    {
        GEL_TextOut(">> START ==> Configure EMIF1 DDR in Self Refresh (CKE=0 and clk stopped) and configure invert_clkout\n");
    }

    WR_MEM_32(0x4C000038, 0x00000200);     //PWR_MGMT_CTRL -- Enter "self refresh" mode
    for (loop_index=0;loop_index<0xF;loop_index++)
    {
        dummy_read = RD_MEM_32(0x40300000);
    }    // Insert 16 dummy read
    WR_MEM_32(0x4C0000E4, 0x0020080C);     //DDR_PHY_CTRL_1 -- Set invert_clkout (if activated)
    WR_MEM_32(0x4C0000E8, 0x0020080C);     //DDR_PHY_CTRL_1_SHDW -- Set invert_clkout (if activated)
    for (loop_index=0;loop_index<0xF;loop_index++)
    {
        dummy_read = RD_MEM_32(0x40300000);
    }    // Insert 16 dummy read
    WR_MEM_32(0x4C000038, 0x00000000);     //PWR_MGMT_CTRL -- Exit "self refresh" mode

    // EMIF1 channel - Launch full leveling (WR_LVL + READ_GATE_LVL + READ_LVL)
    if (DEBUG_PRINT)
    {
        GEL_TextOut(">> START ==> EMIF1 channel - Launch full leveling (WR_LVL + READ_GATE_LVL + READ_VLV)\n");
    }

    if (0)
    {
        WR_MEM_32(0x4C0000DC, 0x80000000);     //RDWR_LVL_CTRL -- force RDWRLVLFULL_START=1 / Launch full leveling
    }
    dummy_read = RD_MEM_32(0x4AE0C5C8);    // Wait for EMIF1 to be done with Full_LVL (SW stalling - EMIF keeps IDLE_ack adderted until Full_LVL completion)

    // EMIF1 channel - Put back the Read Data Eye LVL num_of_samples=4
    if (DEBUG_PRINT)
    {
        GEL_TextOut(">> START ==> EMIF1 channel - Put back the Read Data Eye LVL num_of_samples=4\n");
    }

    WR_MEM_32(0x4AE0C144, 0x00010107);     //EMIF1_SDRAM_CONFIG_EXT -- cslice_en[2:0]=111 / Local_odt=01 / dyn_pwrdn=1 / dis_reset=1 / rd_lvl_samples=00 (4)

    // EMIF1 channel - Launch 8 incremental WR_LVL (to compensate for a PHY limitation)
    if (DEBUG_PRINT)
    {
        GEL_TextOut(">> START ==> EMIF1 channel - Launch 8 incremental WR_LVL (to compensate for a PHY limitation)\n");
    }

    // FIXME: Daniel - commented this out
    if(0)
    {
        WR_MEM_32(0x4C0000DC, 0x01000002);     //RDWR_LVL_CTRL -- force RDWRLVLFULL_START=0 / Set Write Leveling period = 2
    }
    for (loop_index=0;loop_index<0xF;loop_index++)
    {
        dummy_read = RD_MEM_32(0x40300000);
    }    // Insert 4096 dummy read (should be at least 128us)

    // EMIF1 channel - Turn-OFF any incremental LVL for first samples debug
    if (DEBUG_PRINT)
    {
        GEL_TextOut(">> START ==> EMIF1 channel - Turn-OFF any incremental LVL for first samples debug\n");
    }

    WR_MEM_32(0x4C0000DC, 0x00000000);     //RDWR_LVL_CTRL -- Turn-OFF any incremental LVL for first samples debug

    //MA_LISA_MAP_i
    //WR_MEM_32(0x482AF040, 0x80700100);
    //WR_MEM_32(0x482AF044, 0x00000000);
    //WR_MEM_32(0x4E000040, 0x80710100);
    //WR_MEM_32(0x4E000044, 0x00000000);

    // EMIF - DDR Overall Configuration  - COMPLETED
    if (DEBUG_PRINT)
    {
        GEL_TextOut(">> END ==> overall DDR configuration completed / DDR memory can now be accessed\n");
    }

    // FIXME: Why is this here?
    WR_MEM_32(0x4C000008, 0x61A32232);     //SDRAM_CONFIG --
    RD_MEM_32(0x4C000008);     //SDRAM_CONFIG --
    WR_MEM_32(0x4C000008, 0x61A32232);     //SDRAM_CONFIG --

    GEL_TextOut("--->>> DDR3 Initialization is DONE! <<<---\n");
    GEL_TextOut("--->>> DDR3 Testing... <<<---\n");
    Test_Memory();
    GEL_TextOut("--->>> DDR3 Testing is DONE! <<<---\n");
}

/******************************************************************
*   Test for memory
*   Writing into 100 locations and then reading them and then
*   compare them to check error
******************************************************************/

Test_Memory(){
    int address,fail = 0,i,temp, wr_data;
    GEL_TextOut("\tWRITING to DDR memspace \n","Output",1,1,1 );

    address = 0x80000000;
    wr_data = 0x33221100;
    WR_MEM_32(address, wr_data);
    GEL_TextOut("\tREADING FROM DDR memspace \n","Output",1,1,1 );
    temp=  RD_MEM_32(address);
    if(temp != (wr_data)) {
        GEL_TextOut("\t MEMSS READ FAILED******: Address = %x, Expected data = %x, Received data = %x \n",,,,,address, wr_data, temp);
        fail = 1 ;
    } else {
        GEL_TextOut("\t MEMSS READ SUCCESS: Address = %x, data  = %x \n",,,,,address, temp);
    }

    address = address + 0x4;
    wr_data = 0x77665544;
    WR_MEM_32(address, wr_data);
    GEL_TextOut("\tREADING FROM DDR memspace \n","Output",1,1,1 );
    temp=  RD_MEM_32(address);
    if(temp != (wr_data)) {
        GEL_TextOut("\t MEMSS READ FAILED******: Address = %x, Expected data = %x, Received data = %x \n",,,,,address, wr_data, temp);
        fail = 1 ;
    } else {
        GEL_TextOut("\t MEMSS READ SUCCESS: Address = %x, data  = %x \n",,,,,address, temp);
    }

    address = address + 0x4;
    wr_data = 0xBBAA9988;
    WR_MEM_32(address, wr_data);
    GEL_TextOut("\tREADING FROM DDR memspace \n","Output",1,1,1 );
    temp=  RD_MEM_32(address);
    if(temp != (wr_data)) {
        GEL_TextOut("\t MEMSS READ FAILED******: Address = %x, Expected data = %x, Received data = %x \n",,,,,address, wr_data, temp);
        fail = 1 ;
    } else {
        GEL_TextOut("\t MEMSS READ SUCCESS: Address = %x, data  = %x \n",,,,,address, temp);
    }


    address = address + 0x4;
    wr_data = 0xFFEEDDCC;
    WR_MEM_32(address, wr_data);
    GEL_TextOut("\tREADING FROM DDR memspace \n","Output",1,1,1 );
    temp=  RD_MEM_32(address);
    if(temp != (wr_data)) {
        GEL_TextOut("\t MEMSS READ FAILED******: Address = %x, Expected data = %x, Received data = %x \n",,,,,address, wr_data, temp);
        fail = 1 ;
    } else {
        GEL_TextOut("\t MEMSS READ SUCCESS: Address = %x, data  = %x \n",,,,,address, temp);
    }


    address = 0x80000010;
    wr_data = address;
    WR_MEM_32(address, wr_data);
    GEL_TextOut("\tREADING FROM DDR memspace \n","Output",1,1,1 );
    temp=  RD_MEM_32(address);
    if(temp != (wr_data)) {
        GEL_TextOut("\t MEMSS READ FAILED******: Address = %x, Expected data = %x, Received data = %x \n",,,,,address, wr_data, temp);
        fail = 1 ;
    } else {
        GEL_TextOut("\t MEMSS READ SUCCESS: Address = %x, data  = %x \n",,,,,address, temp);
    }

    address = address + 0x4;
    wr_data = address;
    WR_MEM_32(address, wr_data);
    GEL_TextOut("\tREADING FROM DDR memspace \n","Output",1,1,1 );
    temp=  RD_MEM_32(address);
    if(temp != (wr_data)) {
        GEL_TextOut("\t MEMSS READ FAILED******: Address = %x, Expected data = %x, Received data = %x \n",,,,,address, wr_data, temp);
        fail = 1 ;
    } else {
        GEL_TextOut("\t MEMSS READ SUCCESS: Address = %x, data  = %x \n",,,,,address, temp);
    }

    address = address + 0x4;
    wr_data = address;
    WR_MEM_32(address, wr_data);
    GEL_TextOut("\tREADING FROM DDR memspace \n","Output",1,1,1 );
    temp=  RD_MEM_32(address);
    if(temp != (wr_data)) {
        GEL_TextOut("\t MEMSS READ FAILED******: Address = %x, Expected data = %x, Received data = %x \n",,,,,address, wr_data, temp);
        fail = 1 ;
    } else {
        GEL_TextOut("\t MEMSS READ SUCCESS: Address = %x, data  = %x \n",,,,,address, temp);
    }

    address = address + 0x4;
    wr_data = address;
    WR_MEM_32(address, wr_data);
    GEL_TextOut("\tREADING FROM DDR memspace \n","Output",1,1,1 );
    temp=  RD_MEM_32(address);
    if(temp != (wr_data)) {
        GEL_TextOut("\t MEMSS READ FAILED******: Address = %x, Expected data = %x, Received data = %x \n",,,,,address, wr_data, temp);
        fail = 1 ;
    } else {
        GEL_TextOut("\t MEMSS READ SUCCESS: Address = %x, data  = %x \n",,,,,address, temp);
    }


    address = 0x80000000;
    for(i =0; i < 0x10;  i = i +4)
    {
        temp = address + i ;
        WR_MEM_32(address+i, address+i);
        GEL_TextOut("\t MEMSS WRITE: Address = %x, data  = %x \n",,,,,address+i, temp);
        temp=  RD_MEM_32(address+i);
        if(temp != (address+i)) {
            GEL_TextOut("\t MEMSS READ FAILED******: Address = %x, data  = %x \n",,,,,address+i, temp);
            fail = 1 ;
        }
        else {
            GEL_TextOut("\t MEMSS READ SUCCESS: Address = %x, data  = %x \n",,,,,address+i, temp);
        }
    }

    if (1 == fail) {
        GEL_TextOut("\t MEMSS TEST COMPLETED with FAILURES\n","Output",1,1,1 );
    } else {
        GEL_TextOut("\t MEMSS TEST COMPLETED and PASSED \n","Output",1,1,1 );
    }
}
bit_swap_ddr_debug()
{
    int i;
    int j;
    int local_data;
    int read_value;

    GEL_TextOut(">> START bit_swap_ddr_debug\n");

    i = 0;
    j = 0;
    local_data = ddr_data_pattern;
    while (j<(int)(BIT_SWAP_SIZE))
    {
        *(int*)(j+0x80000000) = (int)(local_data);
        //GEL_TextOut(">> address (%x) \n",,,,,(int)(j+0x80000000));
        //GEL_TextOut(">> value (%x) \n",,,,,*(int*)((int)(j+0x80000000)));
        i=i+1;
        j=j+4;
        local_data = ~local_data;
    }

    i = 0;
    j = 0;
    local_data = ddr_data_pattern;
    while (j<(int)(BIT_SWAP_SIZE))
    {
        read_value = *(int*)((int)(j+0x80000000));
        if (read_value!= (int)(local_data))
        {
            GEL_TextOut(">> error address (%x) \n",,,,,j+0x80000000);
            GEL_TextOut(">> read value (%x) \n",,,,,read_value);
            GEL_TextOut(">> value expected (%x) \n",,,,,local_data);
        }
        i=i+1;
        j=j+4;
        local_data = ~local_data;
    }

    ddr_data_pattern = ~ddr_data_pattern;
    GEL_TextOut(">> END bit_swap_ddr_debug\n");

}

block_burst_ddr_debug()
{

    int i;
    int j;
    int local_data;
    int write_value;
    int read_value;


    GEL_TextOut(">> START block_burst_ddr_debug\n");

    i = 0;
    j = 0;
    local_data = ddr_data_pattern;
    while (j<(int)(BIT_SWAP_SIZE))
    {
        write_value = local_data | (local_data << 8) | (local_data << 16) | (local_data << 24);
        *(int*)(j+0x80000000) = (int)(write_value);
        //GEL_TextOut(">> address (%x) \n",,,,,(int)(j+0x80000000));
        //GEL_TextOut(">> value (%x) \n",,,,,*(int*)((int)(j+0x80000000)));
        i=i+1;
        j=j+4;
        if (local_data < 255)
        {
            local_data = local_data + 1;
        }
        else
        {
            local_data = 0;
        }
    }

    i = 0;
    j = 0;
    local_data = ddr_data_pattern;
    while (j<(int)(BIT_SWAP_SIZE))
    {
        write_value = local_data | (local_data << 8) | (local_data << 16) | (local_data << 24);
        read_value = *(int*)((int)(j+0x80000000));
        if (read_value!= write_value)
        {
            GEL_TextOut(">> error address (%x) \n",,,,,j+0x80000000);
            GEL_TextOut(">> read value (%x) \n",,,,,read_value);
            GEL_TextOut(">> value expected (%x) \n",,,,,write_value);
        }
        i=i+1;
        j=j+4;
        if (local_data < 255)
        {
            local_data = local_data + 1;
        }
        else
        {
            local_data = 0;
        }
    }

    if (ddr_data_pattern < 255)
    {
        ddr_data_pattern = ddr_data_pattern + 1;
    }
    else
    {
        ddr_data_pattern = 1;
    }
    GEL_TextOut(">> END block_burst_ddr_debug\n");
}

repetitive_opp_change()
{
    int i;
    i = 0;
    while (i<(int)(NUM_OF_OPP_CHG))
    {
        opp_change_to_opp_low();
        //    bit_swap_ddr_debug();
        block_burst_ddr_debug();
        opp_change_to_opp_nom();
        //    bit_swap_ddr_debug();
        block_burst_ddr_debug();
        i=i+1;
    }
}

/******************************************************************
*   End of DDR3 initialization.
******************************************************************/

/******************************************************************
*   DSP core enable starts here...
******************************************************************/

menuitem "ADAS_LOW MULTICORE Initialization"

/*******************************************************************************
*        DRA7xx Registers Map Defines: CortexM4_CPU1 view
*******************************************************************************/


#define L4_WKUP_TARG                 0x4AE00000
#define DSP1_L2_SRAM_TARG            0x40800000
#define DSP2_L2_SRAM_TARG            0x41000000

/*******************************************************************************
*        L4_CFG Registers Map Defines: CortexM4_CPU1 view
*******************************************************************************/

#define CM_CORE_AON                  (L4_CFG_TARG + 0x5000)
#define CM_CORE                      (L4_CFG_TARG + 0x8000)

/*******************************************************************************
    L4_WKUP Registers Map Defines: CortexM4_CPU1 view
*******************************************************************************/

#define PRM                          (L4_WKUP_TARG + 0x6000)

/*******************************************************************************
*        PRCM Registers Map Defines: CortexM4_CPU1 view
*******************************************************************************/

#define DSP1_CM_CORE_AON             (CM_CORE_AON + 0x400)
#define DSP2_CM_CORE_AON             (CM_CORE_AON + 0x600)
#define DSP1_PRM                     (PRM + 0x400)
#define DSP2_PRM                     (PRM + 0x1B00)

/*******************************************************************************
*       DSPSS1 Address Map defines: CortexM4_CPU1 view
*******************************************************************************/

#define CM_DSP1_CLKSTCTRL            (DSP1_CM_CORE_AON + 0x0)
#define CM_DSP1_DSP1_CLKCTRL         (DSP1_CM_CORE_AON + 0x20)
#define RM_DSP1_RSTCTRL              (DSP1_PRM + 0x10)
#define RM_DSP1_RSTST                (DSP1_PRM + 0x14)
#define DSPSS1BOOTADDR               (CTRL_MODULE_CORE + 0x55C)
#define DSPSS1BOOTADDRVALUE          (DSP1_L2_SRAM_TARG - 0x40000000)

/*******************************************************************************
*        DSPSS2 Address Map defines: CortexM4_CPU1 view
*******************************************************************************/
#define CM_DSP2_CLKSTCTRL            (DSP2_CM_CORE_AON + 0x0)
#define CM_DSP2_DSP2_CLKCTRL         (DSP2_CM_CORE_AON + 0x20)
#define RM_DSP2_RSTCTRL              (DSP2_PRM + 0x10)
#define RM_DSP2_RSTST                (DSP2_PRM + 0x14)
#define DSPSS2BOOTADDR               (CTRL_MODULE_CORE + 0x560)
#define DSPSS2BOOTADDRVALUE          (DSP2_L2_SRAM_TARG - 0x40800000)

/*******************************************************************************
*            DSPSS CPU Independent defines
*******************************************************************************/
#define CM_DSP_CLKSTCTRL             ((cpu_num == 1) ? (CM_DSP1_CLKSTCTRL) : (CM_DSP2_CLKSTCTRL))
#define CM_DSP_DSP_CLKCTRL           ((cpu_num == 1) ? (CM_DSP1_DSP1_CLKCTRL) : (CM_DSP2_DSP2_CLKCTRL))
#define RM_DSP_RSTCTRL               ((cpu_num == 1) ? (RM_DSP1_RSTCTRL) : (RM_DSP2_RSTCTRL))
#define RM_DSP_RSTST                 ((cpu_num == 1) ? (RM_DSP1_RSTST) : (RM_DSP2_RSTST))
#define DSPSSBOOTADDR                ((cpu_num == 1) ? (DSPSS1BOOTADDR) : (DSPSS2BOOTADDR))
#define DSPSSBOOTADDRVALUE           ((cpu_num == 1) ? (DSPSS1BOOTADDRVALUE) : (DSPSS2BOOTADDRVALUE))
#define DSP_L2_SRAM_TARG             ((cpu_num == 1) ? (DSP1_L2_SRAM_TARG) : (DSP2_L2_SRAM_TARG))

#define BOOTADDR (DSPSSBOOTADDRVALUE>>10)
hotmenu ADAS_LOW_MULTICORE_EnableAllDSPCores()
{
    DSP1SSClkEnable_API();
    DSP2SSClkEnable_API();
}

/************ Enable the DSP1 Clocks ***************/
hotmenu DSP1SSClkEnable_API()
{
    DSPSSClkEnable(1);
}

/************ Enable the DSP2 Clocks ***************/
hotmenu DSP2SSClkEnable_API()
{
    DSPSSClkEnable(2);
}

/*******************************************************************************
*       Enabling clock for DSP core
*******************************************************************************/

DSPSSClkEnable(uint32_t cpu_num)
{
    uint32_t i, fail = 0;
    GEL_TextOut("--->>> DSP%dSS Initialization is in progress ... <<<---\n",,,,,cpu_num);

    /* DSPSS Boot Address */
    WR_MEM_32(DSPSSBOOTADDR, (DSPSSBOOTADDRVALUE >> 10));

    /* Ware reset asserted for DSP_LRST, DSP Cache and Slave */
    WR_MEM_32(RM_DSP_RSTCTRL, 0x3);

    /* Start a SW force wakeup for DSPSS */
    WR_MEM_32(CM_DSP_CLKSTCTRL, 0x2);
    /* Enable DSPSS clock */
    WR_MEM_32(CM_DSP_DSP_CLKCTRL, 0x1);

    /* Check whether GFCLK is gated or not */
    while ((RD_MEM_32(CM_DSP_CLKSTCTRL) & 0x100) != 0x100);
    if (DEBUG_PRINT)
    {
        GEL_TextOut("DEBUG: Clock is active ... \n");
    }

    /* Reset de-assertion for DSPSS */
    WR_MEM_32(RM_DSP_RSTCTRL, 0x1);
    /* Check the reset state: DSPSS */
    while ((RD_MEM_32(RM_DSP_RSTST) & 0x2) != 0x2);

    WR_MEM_32(DSP_L2_SRAM_TARG, 0x0000A120); //Self branch loop for DSP

    /*Insertion of while(1)*/
    for( i = 0 ; i < 8 ; i++)
    WR_MEM_32((BOOTADDR) + 4 * i, 0x00000012);

    /* Reset de-assertion for DSP CPUs */
    WR_MEM_32(RM_DSP_RSTCTRL, 0x0);
    /* Check the reset state: DSPSS Core, Cache and Slave interface */
    while ((RD_MEM_32(RM_DSP_RSTST) & 0x3) != 0x3);
    /* Check module mode */
    while ((RD_MEM_32(CM_DSP_DSP_CLKCTRL) & 0x30000) != 0x0);

    if (DEBUG_PRINT)
    {
        GEL_TextOut("DEBUG: Checking for data integrity in DSPSS L2RAM ... \n");
    }
    for (i = 1; i < 16; i++)
    {
        WR_MEM_32((DSP_L2_SRAM_TARG + (i << 2)), 0x12345678);
    }

    for (i = 1; i < 16; i++)
    {
        if (RD_MEM_32(DSP_L2_SRAM_TARG + (i << 2)) != 0x12345678)
        {
            fail++;
            break;
        }
    }

    if (fail)
    {
        GEL_TextOut("ERROR: Data integrity check in GEM L2RAM has failed! \n");
    }
    else
    {
        if (DEBUG_PRINT)
        {
            GEL_TextOut("DEBUG: Data integrity check in GEM L2RAM is sucessful! \n");
        }
    }

    GEL_TextOut("--->>> DSP%dSS Initialization is DONE! <<<---\n",,,,,cpu_num);
}

/******************************************************************
*   End of DSP enabling.
******************************************************************/
