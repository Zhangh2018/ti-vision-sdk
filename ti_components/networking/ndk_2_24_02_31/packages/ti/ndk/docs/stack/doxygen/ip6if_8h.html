<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>NDK Stack Documentation: inc/stack/inc/ip6if.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="tilogo.gif"></a></td>
  <td bgcolor="red"><img src="titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>inc/stack/inc/ip6if.h File Reference</h1>Common structures and definitions for IPv6. <a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_p_v6___d_e_v___r_e_c_o_r_d.html">IPV6_DEV_RECORD</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The structure describes the IPv6 Device Record.  <a href="struct_i_p_v6___d_e_v___r_e_c_o_r_d.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_p_v6_s_t_a_t_s.html">IPV6STATS</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The structure describes the IPv6 Statistics Block.  <a href="struct_i_p_v6_s_t_a_t_s.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">_extern void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ip6if_8h.html#5062558421b5bcfd92d558909f06caa2">IPv6ParseExtnHeaders</a> (PBM_Pkt *pPkt, IPV6HDR *ptr_ipv6hdr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">_extern int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ip6if_8h.html#d77f67e9eec9e8c1557810bcb8cd6944">IPv6ParseFragHdr</a> (PBM_Pkt *pPkt, IPV6HDR *ptr_ipv6hdr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">_extern void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ip6if_8h.html#4d78c8870b3534aaa5272cdd0eb898f6">IPv6RxPacket</a> (PBM_Pkt *pPkt)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">_extern HANDLE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ip6if_8h.html#152a835b3f17900c94e36cc938f1b0ed">IPv6GetRoute</a> (IP6N DstIP)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">_extern int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ip6if_8h.html#e352b96cca06307845c38b2a26b4dbef">IPv6TxPacket</a> (PBM_Pkt *pPkt, UINT32 Flags)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">_extern int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ip6if_8h.html#ba2190c0acd54cba94ee178e6d8399ab">IPv6InterfaceDeInit</a> (UINT16 dev_index)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">_extern int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ip6if_8h.html#cc1f8a06d0c69702ddf46aeaeaaa67a2">IPv6AddAddress</a> (UINT16 dev_index, IP6N Address, UINT16 NetBits, UINT32 VLT, UINT32 PLT, UINT8 IsAny)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">_extern int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ip6if_8h.html#f83ddbb4db46e17fb14d17a5353c3100">IPv6DelAddress</a> (UINT16 dev_index, IP6N Address)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">_extern void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ip6if_8h.html#c63e4696466ddd56bb1ae8311db5a4f1">IPv6GetSubnetMaskFromBits</a> (IP6N *SubnetMask, UINT16 bits)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">_extern void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ip6if_8h.html#a4cc67a10107a95d2aec861fa9de9181">IPv6DisplayIPAddress</a> (IP6N address)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">_extern int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ip6if_8h.html#f51019ea4814cae2d365afabf64c0f1b">IPv6StringToIPAddress</a> (char *StringIP, IP6N *address)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">_extern UINT16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ip6if_8h.html#f6c7ad0193c17ba1c39ab8b72f572542">IPv6CompareAddress</a> (IP6N addr1, IP6N addr2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">_extern UINT16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ip6if_8h.html#9968bf32f9096fc97da924259430bced">IPv6IsMulticast</a> (IP6N address)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">_extern UINT16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ip6if_8h.html#afaef0a63376b88648aa6ccbc722f768">IPv6IsLinkLocal</a> (IP6N address)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">_extern UINT16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ip6if_8h.html#c980370282bd865ca360a5d9af702fc5">IPv6Layer4ComputeChecksum</a> (UINT8 *ptr_l4Hdr, PSEUDOV6 *ptr_pseudoHdr)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Common structures and definitions for IPv6. 
<p>
<dl class="user" compact><dt><b></b></dt><dd>NOTE: (C) Copyright 2008, Texas Instruments, Inc.</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd></dd></dl>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="cc1f8a06d0c69702ddf46aeaeaaa67a2"></a><!-- doxytag: member="ip6if.h::IPv6AddAddress" ref="cc1f8a06d0c69702ddf46aeaeaaa67a2" args="(UINT16 dev_index, IP6N Address, UINT16 NetBits, UINT32 VLT, UINT32 PLT, UINT8 IsAny)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_extern int IPv6AddAddress           </td>
          <td>(</td>
          <td class="paramtype">UINT16&nbsp;</td>
          <td class="paramname"> <em>dev_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IP6N&nbsp;</td>
          <td class="paramname"> <em>Address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT16&nbsp;</td>
          <td class="paramname"> <em>NetBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&nbsp;</td>
          <td class="paramname"> <em>ValidLifetime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&nbsp;</td>
          <td class="paramname"> <em>PrefLifetime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT8&nbsp;</td>
          <td class="paramname"> <em>IsAnycast</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 This function is used to add an IPv6 address to an interface. This function should not be used to add Link Local Addresses to the interface. Link Local Addresses are automatically added to the interface when the IPv6 stack is initialized on it. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ipv6_8c.html#74347009e232ac2b77823576fdd40b7f">IPv6AddAddress</a></dd></dl>
The function is exported to system developers and should only be called from outside kernel mode.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dev_index</em>&nbsp;</td><td>The device index on which the IPv6 address needs to be added. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Address</em>&nbsp;</td><td>The IPv6 Address which needs to be added. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>NetBits</em>&nbsp;</td><td>The number of bits which make the Subnet-Mask. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ValidLifetime</em>&nbsp;</td><td>The Valid Lifetime of the address. Set to INFINITE_LT if the address is permanent </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>PrefLifetime</em>&nbsp;</td><td>The Preferred Lifetime of the address. Set to INFINITE_LT if the address is permanent. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>IsAnycast</em>&nbsp;</td><td>Flag which indicates if the address to be added is ANYCAST or UNICAST. Set to 1 for ANYCAST.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>- Success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>&lt;0</em>&nbsp;</td><td>- Error </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f6c7ad0193c17ba1c39ab8b72f572542"></a><!-- doxytag: member="ip6if.h::IPv6CompareAddress" ref="f6c7ad0193c17ba1c39ab8b72f572542" args="(IP6N addr1, IP6N addr2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_extern UINT16 IPv6CompareAddress           </td>
          <td>(</td>
          <td class="paramtype">IP6N&nbsp;</td>
          <td class="paramname"> <em>addr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IP6N&nbsp;</td>
          <td class="paramname"> <em>addr2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 Utility Function used to compare the 2 IPv6 Addresses.<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>addr1</em>&nbsp;</td><td>The first IPv6 Address which is to be compared.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>addr2</em>&nbsp;</td><td>The second IPv6 Address which is to be compared.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>- The IP Addresses match </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>- The IP Addresses do not match </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f83ddbb4db46e17fb14d17a5353c3100"></a><!-- doxytag: member="ip6if.h::IPv6DelAddress" ref="f83ddbb4db46e17fb14d17a5353c3100" args="(UINT16 dev_index, IP6N Address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_extern int IPv6DelAddress           </td>
          <td>(</td>
          <td class="paramtype">UINT16&nbsp;</td>
          <td class="paramname"> <em>dev_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IP6N&nbsp;</td>
          <td class="paramname"> <em>Address</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 This function is used to delete an IPv6 address from an interface This function should not be used to delete Link Local Addresses from the interface. Link Local Addresses are automatically deleted from the interface when the IPv6 stack is de-initialized on it. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ipv6_8c.html#645d0eb7bf5e6820ac86bdf33b759052">IPv6InterfaceDeInit</a></dd></dl>
The function is exported to system developers and should only be called from outside kernel mode.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dev_index</em>&nbsp;</td><td>The device index on which the IPv6 address needs to be deleted. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Address</em>&nbsp;</td><td>The IPv6 Address which needs to be deleted.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>- Success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>&lt;0</em>&nbsp;</td><td>- Error </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a4cc67a10107a95d2aec861fa9de9181"></a><!-- doxytag: member="ip6if.h::IPv6DisplayIPAddress" ref="a4cc67a10107a95d2aec861fa9de9181" args="(IP6N address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_extern void IPv6DisplayIPAddress           </td>
          <td>(</td>
          <td class="paramtype">IP6N&nbsp;</td>
          <td class="paramname"> <em>address</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 Utility Function which prints the IPv6 address. The IP address passed has to be specified in network order (IP6N).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>address</em>&nbsp;</td><td>IPv6 Address to be displayed. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Not</em>&nbsp;</td><td>Applicable. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="152a835b3f17900c94e36cc938f1b0ed"></a><!-- doxytag: member="ip6if.h::IPv6GetRoute" ref="152a835b3f17900c94e36cc938f1b0ed" args="(IP6N DstIP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_extern HANDLE IPv6GetRoute           </td>
          <td>(</td>
          <td class="paramtype">IP6N&nbsp;</td>
          <td class="paramname"> <em>DstIP</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function is used to get an IPv6 route matching the destination IP Address. The function increments the reference counter for the ROUTE6 object.<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>DstIP</em>&nbsp;</td><td>IPv6 Destination IP address we are trying to find a route for.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Success</em>&nbsp;</td><td>- Handle of the Route6 object to be used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Error</em>&nbsp;</td><td>- 0 </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c63e4696466ddd56bb1ae8311db5a4f1"></a><!-- doxytag: member="ip6if.h::IPv6GetSubnetMaskFromBits" ref="c63e4696466ddd56bb1ae8311db5a4f1" args="(IP6N *SubnetMask, UINT16 bits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_extern void IPv6GetSubnetMaskFromBits           </td>
          <td>(</td>
          <td class="paramtype">IP6N *&nbsp;</td>
          <td class="paramname"> <em>SubnetMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT16&nbsp;</td>
          <td class="paramname"> <em>bits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 Utility Function which gets the subnet mask given the number of bits.<p>
For example: Subnet Mask = 0xFFFF:: if the bits is 16<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>SubnetMask</em>&nbsp;</td><td>Pointer to the computed subnet mask in network order. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bits</em>&nbsp;</td><td>Number of bits in the subnet mask</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Not</em>&nbsp;</td><td>Applicable. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ba2190c0acd54cba94ee178e6d8399ab"></a><!-- doxytag: member="ip6if.h::IPv6InterfaceDeInit" ref="ba2190c0acd54cba94ee178e6d8399ab" args="(UINT16 dev_index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_extern int IPv6InterfaceDeInit           </td>
          <td>(</td>
          <td class="paramtype">UINT16&nbsp;</td>
          <td class="paramname"> <em>dev_index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 This function is used to deinitialize the IPv6 stack on the the specific device name. The function is available to System Developers and should only be called from within kernel mode.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dev_index</em>&nbsp;</td><td>The device index on which the IPv6 stack is to be deinitialized.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>- Success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>&lt;0</em>&nbsp;</td><td>- Error </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="afaef0a63376b88648aa6ccbc722f768"></a><!-- doxytag: member="ip6if.h::IPv6IsLinkLocal" ref="afaef0a63376b88648aa6ccbc722f768" args="(IP6N address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_extern UINT16 IPv6IsLinkLocal           </td>
          <td>(</td>
          <td class="paramtype">IP6N&nbsp;</td>
          <td class="paramname"> <em>address</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 Utility Function which determines if the IPv6 Address specified is a Link Local address or not?<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>address</em>&nbsp;</td><td>IPv6 Address which needs to be verfied.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>- The address passed is Link Local </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>- The address passed is NOT Link Local </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9968bf32f9096fc97da924259430bced"></a><!-- doxytag: member="ip6if.h::IPv6IsMulticast" ref="9968bf32f9096fc97da924259430bced" args="(IP6N address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_extern UINT16 IPv6IsMulticast           </td>
          <td>(</td>
          <td class="paramtype">IP6N&nbsp;</td>
          <td class="paramname"> <em>address</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 Utility Function which determines if the IPv6 Address specified is a Multicast address or not?<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>address</em>&nbsp;</td><td>IPv6 Address which needs to be verfied.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>- The address passed is MULTICAST </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>- The address passed is NOT Multicast </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c980370282bd865ca360a5d9af702fc5"></a><!-- doxytag: member="ip6if.h::IPv6Layer4ComputeChecksum" ref="c980370282bd865ca360a5d9af702fc5" args="(UINT8 *ptr_l4Hdr, PSEUDOV6 *ptr_pseudoHdr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_extern UINT16 IPv6Layer4ComputeChecksum           </td>
          <td>(</td>
          <td class="paramtype">UINT8 *&nbsp;</td>
          <td class="paramname"> <em>ptr_l4Hdr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PSEUDOV6 *&nbsp;</td>
          <td class="paramname"> <em>ptr_pseudoHdr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function does the Layer4 Checksum computation.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr_l4Hdr</em>&nbsp;</td><td>Pointer to the Layer4 Header. This could be TCP, UDP or ICMPv6. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr_pseudoHdr</em>&nbsp;</td><td>Pointer to the Pseudo Header.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Returns</em>&nbsp;</td><td>the computed checksum.</td></tr>
  </table>
</dl>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>Ensure that the Checksum field in the layer4 header is set to 0 before calling this function. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5062558421b5bcfd92d558909f06caa2"></a><!-- doxytag: member="ip6if.h::IPv6ParseExtnHeaders" ref="5062558421b5bcfd92d558909f06caa2" args="(PBM_Pkt *pPkt, IPV6HDR *ptr_ipv6hdr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_extern void IPv6ParseExtnHeaders           </td>
          <td>(</td>
          <td class="paramtype">PBM_Pkt *&nbsp;</td>
          <td class="paramname"> <em>pPkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IPV6HDR *&nbsp;</td>
          <td class="paramname"> <em>ptr_ipv6hdr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function handles all IPV6 extension headers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pPkt</em>&nbsp;</td><td>Pointer to the entire IPv6 Packet.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr_ipv6hdr</em>&nbsp;</td><td>Pointer to the IPv6 Header.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>None</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d77f67e9eec9e8c1557810bcb8cd6944"></a><!-- doxytag: member="ip6if.h::IPv6ParseFragHdr" ref="d77f67e9eec9e8c1557810bcb8cd6944" args="(PBM_Pkt *pPkt, IPV6HDR *ptr_ipv6hdr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_extern int IPv6ParseFragHdr           </td>
          <td>(</td>
          <td class="paramtype">PBM_Pkt *&nbsp;</td>
          <td class="paramname"> <em>pPkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IPV6HDR *&nbsp;</td>
          <td class="paramname"> <em>ptr_ipv6hdr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function handles all packets with fragmentation header.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pPkt</em>&nbsp;</td><td>Pointer to the entire IPv6 Packet.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr_ipv6hdr</em>&nbsp;</td><td>Pointer to the IPv6 Header.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>- Error in processing the packet. Packet has been cleaned up. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>- Packet has been successfully processed by fragmentation module. Its been absorbed by this module for reassembly. Ignore this packet. This packet is now a responsibility of the fragmentation layer for further processing. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4d78c8870b3534aaa5272cdd0eb898f6"></a><!-- doxytag: member="ip6if.h::IPv6RxPacket" ref="4d78c8870b3534aaa5272cdd0eb898f6" args="(PBM_Pkt *pPkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_extern void IPv6RxPacket           </td>
          <td>(</td>
          <td class="paramtype">PBM_Pkt *&nbsp;</td>
          <td class="paramname"> <em>pPkt</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 This function is used to process an IPv6 packet received on the network.<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pPkt</em>&nbsp;</td><td>Pointer to the IPv6 packet.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Not</em>&nbsp;</td><td>Applicable. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f51019ea4814cae2d365afabf64c0f1b"></a><!-- doxytag: member="ip6if.h::IPv6StringToIPAddress" ref="f51019ea4814cae2d365afabf64c0f1b" args="(char *StringIP, IP6N *address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_extern int IPv6StringToIPAddress           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>StringIP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IP6N *&nbsp;</td>
          <td class="paramname"> <em>address</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 Utility Function which converts an IPv6 Address from CHAR Format to IP6N<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>StringIP</em>&nbsp;</td><td>The IPv6 Address in String Format </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>address</em>&nbsp;</td><td>The IPv6 Address in IP6N format.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>- Success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>- Error </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e352b96cca06307845c38b2a26b4dbef"></a><!-- doxytag: member="ip6if.h::IPv6TxPacket" ref="e352b96cca06307845c38b2a26b4dbef" args="(PBM_Pkt *pPkt, UINT32 Flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_extern int IPv6TxPacket           </td>
          <td>(</td>
          <td class="paramtype">PBM_Pkt *&nbsp;</td>
          <td class="paramname"> <em>pPkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&nbsp;</td>
          <td class="paramname"> <em>Flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function is used to transmit an IPv6 packet.<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pPkt</em>&nbsp;</td><td>Pointer to the IPv6 packet which needs to be transmitted </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Flags</em>&nbsp;</td><td>Flags which need to be worked out. (Placeholder)</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Success</em>&nbsp;</td><td>- 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Error</em>&nbsp;</td><td>- &lt;0 </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr size="1"><small>
Copyright  2009, Texas Instruments Incorporated</small>
</body>
</html>
