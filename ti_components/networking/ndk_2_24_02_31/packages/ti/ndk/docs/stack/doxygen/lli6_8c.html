<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>NDK Stack Documentation: src/stack/lli6/lli6.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="tilogo.gif"></a></td>
  <td bgcolor="red"><img src="titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>src/stack/lli6/lli6.c File Reference</h1>The file implements the LLI6 Module which is responsible for keeping track of the Neighbor Cache entries and the Neighbor Unreachability Algorithm as specified in RFC 2461. <a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lli6_8c.html#e356446586e76a2a4df3a58d8c561e06">LLI6Update</a> (HANDLE hLLI6, UINT8 *mac_address, UINT32 RxPktType, UINT32 Flags)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lli6_8c.html#353efe933a9aac76f878c7666d5f6fc8">LLI6Msg</a> (uint Msg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lli6_8c.html#85a5ad32bc9cba8a3ef1e87344b73c7f">LLI6IncRefCount</a> (HANDLE hLLI6)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">UINT8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lli6_8c.html#d1d7ccdbcbd32e1e1a6f4e119971160d">LLI6IsRouter</a> (HANDLE hLLI6)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">UINT8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lli6_8c.html#c32fcc31ecfd46fd38337a0556e0e3de">LLI6IsDead</a> (HANDLE hLLI6)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">UINT8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lli6_8c.html#b0e5fe64cc65fea2871c4777d7a08e6f">LLI6IsValid</a> (HANDLE hLLI6)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lli6_8c.html#7c4c098b18ed43fdc508d74cad5b334e">LLI6SetIncomplete</a> (HANDLE hLLI6)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NETIF_DEVICE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lli6_8c.html#eaf256026f86d2d9bff14f3bbb657bdb">LLI6GetNetDevice</a> (HANDLE hLLI6)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">HANDLE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lli6_8c.html#f077682dbc6b948b2c90c10f0d2c40b6">LLI6New</a> (<a class="el" href="struct_r_t6___e_n_t_r_y.html">RT6_ENTRY</a> *ptr_rt6, UINT8 *pMacAddress, UINT8 IsRouter)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lli6_8c.html#d09ddf211d3ea63c4147fadc2adf4df7">LLI6Free</a> (HANDLE hLLI6)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lli6_8c.html#5c4f22543404e6533ba501c301be7db3">LLI6TxIPPacket</a> (PBM_Pkt *pPkt, HANDLE hLLI6, NETIF_DEVICE *ptr_device, IP6N Address)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The file implements the LLI6 Module which is responsible for keeping track of the Neighbor Cache entries and the Neighbor Unreachability Algorithm as specified in RFC 2461. 
<p>
<dl class="user" compact><dt><b></b></dt><dd>NOTE: (C) Copyright 2008, Texas Instruments, Inc.</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd></dd></dl>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="d09ddf211d3ea63c4147fadc2adf4df7"></a><!-- doxytag: member="lli6.c::LLI6Free" ref="d09ddf211d3ea63c4147fadc2adf4df7" args="(HANDLE hLLI6)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LLI6Free           </td>
          <td>(</td>
          <td class="paramtype">HANDLE&nbsp;</td>
          <td class="paramname"> <em>hLLI6</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 This function is used to delete the LLI6 Entry. LLI6 Entries can only be deleted by the ROUTE6 Module.<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hLLI6</em>&nbsp;</td><td>Handle to the LLI6 Object to be deleted.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Not</em>&nbsp;</td><td>Applicable. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="eaf256026f86d2d9bff14f3bbb657bdb"></a><!-- doxytag: member="lli6.c::LLI6GetNetDevice" ref="eaf256026f86d2d9bff14f3bbb657bdb" args="(HANDLE hLLI6)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NETIF_DEVICE* LLI6GetNetDevice           </td>
          <td>(</td>
          <td class="paramtype">HANDLE&nbsp;</td>
          <td class="paramname"> <em>hLLI6</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function gets the network device associated with the LLI6 Entry.<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hLLI6</em>&nbsp;</td><td>Handle to the LLI6 Entry whose network device we need to return.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Success</em>&nbsp;</td><td>- Handle to the Network Device Error - 0 </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="85a5ad32bc9cba8a3ef1e87344b73c7f"></a><!-- doxytag: member="lli6.c::LLI6IncRefCount" ref="85a5ad32bc9cba8a3ef1e87344b73c7f" args="(HANDLE hLLI6)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LLI6IncRefCount           </td>
          <td>(</td>
          <td class="paramtype">HANDLE&nbsp;</td>
          <td class="paramname"> <em>hLLI6</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function Increments the reference counter for the LLI6 Entry. This can be invoked by the ROUTE6 Module if it detects multiple hosts which have different IP addresses but are actual one and the same.<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hLLI6</em>&nbsp;</td><td>Handle of the LLI6 Entry whose reference counter we need to increment.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Not</em>&nbsp;</td><td>Applicable. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c32fcc31ecfd46fd38337a0556e0e3de"></a><!-- doxytag: member="lli6.c::LLI6IsDead" ref="c32fcc31ecfd46fd38337a0556e0e3de" args="(HANDLE hLLI6)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT8 LLI6IsDead           </td>
          <td>(</td>
          <td class="paramtype">HANDLE&nbsp;</td>
          <td class="paramname"> <em>hLLI6</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function checks if the LLI6 Entry is DEAD or not?<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hLLI6</em>&nbsp;</td><td>Handle to the LLI6 Entry which we need to check.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>- LLI6 Entry is DEAD &amp; can be removed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>- LLI6 Entry is not DEAD </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d1d7ccdbcbd32e1e1a6f4e119971160d"></a><!-- doxytag: member="lli6.c::LLI6IsRouter" ref="d1d7ccdbcbd32e1e1a6f4e119971160d" args="(HANDLE hLLI6)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT8 LLI6IsRouter           </td>
          <td>(</td>
          <td class="paramtype">HANDLE&nbsp;</td>
          <td class="paramname"> <em>hLLI6</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function verifies if the LLI6 Entry belongs to a ROUTER or HOST.<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hLLI6</em>&nbsp;</td><td>Handle to the LLI6 Entry which we need to verify.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>- LLI6 Entry belongs to a ROUTER </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>- LLI6 Entry belongs to a HOST </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b0e5fe64cc65fea2871c4777d7a08e6f"></a><!-- doxytag: member="lli6.c::LLI6IsValid" ref="b0e5fe64cc65fea2871c4777d7a08e6f" args="(HANDLE hLLI6)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT8 LLI6IsValid           </td>
          <td>(</td>
          <td class="paramtype">HANDLE&nbsp;</td>
          <td class="paramname"> <em>hLLI6</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function checks if the LLI6 Entry is VALID or not? An LLI6 Entry can be used only if it is !INCOMPLETE and its !DEAD<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hLLI6</em>&nbsp;</td><td>Handle to the LLI6 Entry which we need to check.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>- LLI6 Entry is VALID and can be used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>- LLI6 Entry is not VALID and should not be used. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="353efe933a9aac76f878c7666d5f6fc8"></a><!-- doxytag: member="lli6.c::LLI6Msg" ref="353efe933a9aac76f878c7666d5f6fc8" args="(uint Msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LLI6Msg           </td>
          <td>(</td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>Msg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 Sevices intialization and resource messages for the LLI6 Module.<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Msg</em>&nbsp;</td><td>The message event which needs to be handled.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Not</em>&nbsp;</td><td>Applicable. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f077682dbc6b948b2c90c10f0d2c40b6"></a><!-- doxytag: member="lli6.c::LLI6New" ref="f077682dbc6b948b2c90c10f0d2c40b6" args="(RT6_ENTRY *ptr_rt6, UINT8 *pMacAddress, UINT8 IsRouter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HANDLE LLI6New           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_r_t6___e_n_t_r_y.html">RT6_ENTRY</a> *&nbsp;</td>
          <td class="paramname"> <em>ptr_rt6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT8 *&nbsp;</td>
          <td class="paramname"> <em>pMacAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT8&nbsp;</td>
          <td class="paramname"> <em>IsRouter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 This function is used to create a new LLI6 Entry. LLI6 Entries can only be created by the ROUTE6 Module.<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr_rt6</em>&nbsp;</td><td>Pointer to the Route6 Entry on which the LLI6 Object is created. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pMacAddress</em>&nbsp;</td><td>Pointer to the layer2 MAC Address. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>IsRouter</em>&nbsp;</td><td>Flag which indicates if the LLI6 Entry is ROUTER or HOST. This is set to 1 for ROUTER and 0 for HOST.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Handle</em>&nbsp;</td><td>to the new LLI Entry - Success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>- Error </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7c4c098b18ed43fdc508d74cad5b334e"></a><!-- doxytag: member="lli6.c::LLI6SetIncomplete" ref="7c4c098b18ed43fdc508d74cad5b334e" args="(HANDLE hLLI6)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LLI6SetIncomplete           </td>
          <td>(</td>
          <td class="paramtype">HANDLE&nbsp;</td>
          <td class="paramname"> <em>hLLI6</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function moves an LLI6 Entry to INCOMPLETE STATE. This API should be used very carefully as it might break the Neighbor Unreachability Detection Logic. This is currently being used from the ROUTE6 Module to handle the special case for the Default Router Selection.<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hLLI6</em>&nbsp;</td><td>Handle to the LLI6 Entry whose status needs to be modified.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Not</em>&nbsp;</td><td>Applicable. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5c4f22543404e6533ba501c301be7db3"></a><!-- doxytag: member="lli6.c::LLI6TxIPPacket" ref="5c4f22543404e6533ba501c301be7db3" args="(PBM_Pkt *pPkt, HANDLE hLLI6, NETIF_DEVICE *ptr_device, IP6N Address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LLI6TxIPPacket           </td>
          <td>(</td>
          <td class="paramtype">PBM_Pkt *&nbsp;</td>
          <td class="paramname"> <em>pPkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HANDLE&nbsp;</td>
          <td class="paramname"> <em>hLLI6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NETIF_DEVICE *&nbsp;</td>
          <td class="paramname"> <em>ptr_device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IP6N&nbsp;</td>
          <td class="paramname"> <em>Address</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 This function is called from the IPv6 stack to resolve the IPv6 address to a corresponding MAC address and push the packet to the drivers.<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pPkt</em>&nbsp;</td><td>Pointer to the packet which needs to be transmitted. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hLLI6</em>&nbsp;</td><td>Handle to the LLI6 Entry. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr_device</em>&nbsp;</td><td>Pointer to the Network Interface Object on which the packet needs to be sent out. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Address</em>&nbsp;</td><td>The Destination Address of the packet.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Not</em>&nbsp;</td><td>Applicable. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e356446586e76a2a4df3a58d8c561e06"></a><!-- doxytag: member="lli6.c::LLI6Update" ref="e356446586e76a2a4df3a58d8c561e06" args="(HANDLE hLLI6, UINT8 *mac_address, UINT32 RxPktType, UINT32 Flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LLI6Update           </td>
          <td>(</td>
          <td class="paramtype">HANDLE&nbsp;</td>
          <td class="paramname"> <em>hLLI6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT8 *&nbsp;</td>
          <td class="paramname"> <em>mac_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&nbsp;</td>
          <td class="paramname"> <em>RxPktType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&nbsp;</td>
          <td class="paramname"> <em>Flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function is used to update the LLI6 Entry. This is called whenever one of the Neighbour Discovery packets are received:- a) NS b) NA c) RS d) RA e) Redirect. The function executes the Neighbor Unreachability Detection and Is Router State Machine.<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hLLI6</em>&nbsp;</td><td>Handle to the LLI6 Entry being updated. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mac_address</em>&nbsp;</td><td>MAC Address which needs to be updated. This can be NULL in which case only the IsRouterStateMachine is executed; the Neighbor Unreachability State Machine is bypassed.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>RxPktType</em>&nbsp;</td><td>The packet type received which has triggered a call to this function. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Flags</em>&nbsp;</td><td>The flags field in the NA Header received. 0 for all other packets.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Not</em>&nbsp;</td><td>Applicable. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr size="1"><small>
Copyright  2009, Texas Instruments Incorporated</small>
</body>
</html>
