/* ======================================================================
 *   Copyright (C) 2013 Texas Instruments Incorporated
 *
 *   All rights reserved. Property of Texas Instruments Incorporated.
 *   Restricted rights to use, duplicate or disclose this code are
 *   granted through contract.
 *
 *   The program may not be used without the written permission
 *   of Texas Instruments Incorporated or against the terms and conditions
 *   stipulated in the agreement under which this program has been
 *   supplied.
 * ==================================================================== */
/**
 * @file lld_hsi2c.c
 *
 * This file contains the device LLD APIs for High Speed I2c
 *
 * @path  $(ds)\lld\i2c_master\lld_hsi2c.h
 *
 */

#ifndef LLD_HSI2C_H_
#define LLD_HSI2C_H_

#ifdef __cplusplus
extern "C" {
#endif

/******************************************************************************
 *                             INCLUDE FILES
 *******************************************************************************/
#include "stdint.h"
#include <stdio.h>
#include <string.h>

/******************************************************************************
 *                        MACRO DEFINITIONS
 ******************************************************************************/

/* ========================================================================== */
/** definitions stating maximum limitations of I2C
 *
 *  @def    HSI2C_NUM_OPENS           -    Max number of handles for each
 *                                         instance
 *  @def    HSI2C_MIN_BUS_FREQ        -    Minimum bus frequency
 *  @def    HSI2C_MAX_BUS_FREQ        -    Maximum bus frequency
 *  @def    HSI2C_BUFFER_MAXLENGTH    -    Maximum buffer length
 *
 */
/* ========================================================================== */
#define HSI2C_NUM_OPENS    ((uint32_t) 4U)

#define HSI2C_MIN_BUS_FREQ ((uint32_t) 100U)
#define HSI2C_MAX_BUS_FREQ ((uint32_t) 400U)

#define HSI2C_BUFFER_MAXLENGTH 32768

/* ========================================================================== */
/** Note: The following flags offer the user maximum flexibility in terms
 *  of making the right I2C transaction. In case the user does not want
 *  to set the flags on his own, the default read/write flag can be specified
 *
 *  @def     LLD_HSI2C_READ               - Read from I2C bus (device).\n
 *  @def     LLD_HSI2C_WRITE              - Write to I2C bus (device)
 *  @def     LLD_HSI2C_MASTER             - Configure I2C in Master mode
 *  @def     LLD_HSI2C_SLAVE              - Configure I2C in Slave mode
 *  @def     LLD_HSI2C_START              - Generate Start - valid in master
 *                                          mode only
 *  @def     LLD_HSI2C_STOP               - Generate Stop - valid in master mode
 *                                          only
 *  @def     LLD_HSI2C_RESTART            - Re-Start is generated by Master
 *  @def     LLD_HSI2C_REPEAT             - Repeat mode
 *  @def     LLD_HSI2C_IGNORE_BUS_BUSY    - Ignore Bus Busy condition
 *  @def     LLD_HSI2C_M_IGNORE_NAK       - Ignore NAK
 *
 *  Use these flags for simple MASTER read/write transactions on the I2C bus
 *  @def     LLD_HSI2C_DEFAULT_READ       - Default read flag
 *  @def     LLD_HSI2C_DEFAULT_WRITE      - Default write flag
 *
 */
/* ========================================================================== */

#define LLD_HSI2C_READ                ((uint32_t) 0x0001U)
#define LLD_HSI2C_WRITE               ((uint32_t) 0x0002U)
#define LLD_HSI2C_MASTER              ((uint32_t) 0x0004U)
#define LLD_HSI2C_SLAVE               ((uint32_t) 0x0008U)
#define LLD_HSI2C_START               ((uint32_t) 0x0010U)
#define LLD_HSI2C_STOP                ((uint32_t) 0x0020U)
#define LLD_HSI2C_RESTART             ((uint32_t) 0x0040U)
#define LLD_HSI2C_REPEAT              ((uint32_t) 0x0080U)
#define LLD_HSI2C_IGNORE_BUS_BUSY     ((uint32_t) 0x0100U)
#define LLD_HSI2C_M_IGNORE_NAK        ((uint32_t) 0x0200U)
#define LLD_HSI2C_DEFAULT_READ \
    (LLD_HSI2C_READ | LLD_HSI2C_MASTER | LLD_HSI2C_START | LLD_HSI2C_STOP)
#define LLD_HSI2C_DEFAULT_WRITE \
    (LLD_HSI2C_WRITE | LLD_HSI2C_MASTER | LLD_HSI2C_START | LLD_HSI2C_STOP)

/* ========================================================================== */
/** Local values that can be passed to hal_hsi2c_delay  API
 *
 *  @def    HSI2C_DELAY_SMALL  - Small delay
 *  @def    HSI2C_DELAY_MED    - average delay
 *  @def    HSI2C_DELAY_BIG    - large delay
 *  @def    HSI2C_DELAY_HUGE   - huge delay
 *
 */
/* ========================================================================== */
#define     HSI2C_DELAY_SMALL   ((uint32_t) 5000U)
#define     HSI2C_DELAY_MED     ((uint32_t) 10000U)
#define     HSI2C_DELAY_BIG     ((uint32_t) 20000U)
#define     HSI2C_DELAY_HUGE    ((uint32_t) 50000U)

/* ========================================================================== */
/** Error base value. All error values returned from lib are smaller than this
 *
 *  @def    HSI2C_ERROR_BASE  - Error base value
 *
 */
/* ========================================================================== */
#define     HSI2C_ERROR_BASE    (-16)
/* upto 16 are used/reserved by IOM model of SysBios */

/* ========================================================================== */
/** lld_i2c_busspeed defines the I2C bus frequencies that can be operated
 *
 *  @param    I2C_NORMAL    I2C device operates at 100 kHz
 *  @param    I2C_FAST      I2C device operates at 400 kHz
 *  @param    I2C_HIGH      I2C device operates at 200000 kHz - Not supported
 *
 */
/* ========================================================================== */
typedef enum
{
    I2C_NORMAL = 100,
    I2C_FAST   = 400,
    I2C_HIGH   = 200000
}lld_i2c_busspeed;

/* ========================================================================== */
/** lld_hsi2c_opMode defines operating mode of the driver
 *
 *  @param    HSI2C_OPMODE_POLLED       Polled mode operation
 *  @param    HSI2C_OPMODE_INTERRUPT    Interrupt mode operation
 *  @param    HSI2C_OPMODE_DMA          DMA mode of operation
 *
 */
/* ========================================================================== */
typedef enum
{
    /* Polled operation mode */
    HSI2C_OPMODE_POLLED = (uint8_t) 0,

    /* Interrupt mode of operation */
    HSI2C_OPMODE_INTERRUPT,

    /* DMA mode of operation */
    HSI2C_OPMODE_DMA
} lld_hsi2c_opMode;

/* ========================================================================== */
/** LLD_hsi2cErrorCode_t status and error codes that are returned from LLD
 *
 *  @param    LLD_HSI2C_SUCCESS                   Operation is successful
 *  @param    LLD_HSI2C_FAIL                      Operation failed
 *  @param    LLD_HSI2C_BADARGS                   Bad argument is passed
 *  @param    LLD_HSI2C_ETIMEOUT                  Time out occurs
 *  @param    LLD_HSI2C_HANDLE_UNAVAIL            Handle not available
 *  @param    LLD_HSI2C_BUS_BUSY_ERR              Bus is busy
 *  @param    LLD_HSI2C_ARBITRATION_LOSS_ERR      arbitration error occurred
 *  @param    LLD_HSI2C_NACK_ERR                  No ACK received from slave
 *  @param    LLD_HSI2C_TRANSMIT_UNDERFLOW_ERR    transmit underflow occurred
 *  @param    LLD_HSI2C_RECEIVE_OVERFLOW_ERR      receiver overflow occurred
 *
 */
/* ========================================================================== */
typedef enum {
    LLD_HSI2C_SUCCESS = (int32_t) 0,

    LLD_HSI2C_FAIL = ((int32_t)HSI2C_ERROR_BASE - 1),

    LLD_HSI2C_BADARGS = -10,
    /* Value same as IOM error IOM_EBADARGS as defined in IOM.h of SysBios */

    LLD_HSI2C_ETIMEOUT = -2,
    /* Value same as IOM error IOM_ETIMEOUT as defined in IOM.h of SysBios */

    LLD_HSI2C_HANDLE_UNAVAIL = ((int32_t)HSI2C_ERROR_BASE - 2),

    /** \brief  Returned when the I2C bus find that the bus is busy */
    LLD_HSI2C_BUS_BUSY_ERR = ((int32_t)HSI2C_ERROR_BASE - 3),

    /** \brief  Returned when the I2C driver lost the bus arbitration */
    LLD_HSI2C_ARBITRATION_LOSS_ERR = ((int32_t)HSI2C_ERROR_BASE - 4),

    /** \brief  Returned when the I2C slave did not acknowledgement */
    LLD_HSI2C_NACK_ERR = ((int32_t)HSI2C_ERROR_BASE - 5),

    /** \brief  Returned in case of an transmit underflow error */
    LLD_HSI2C_TRANSMIT_UNDERFLOW_ERR = ((int32_t)HSI2C_ERROR_BASE - 6),

    /** \brief  Returned in case of an receive overflow error */
    LLD_HSI2C_RECEIVE_OVERFLOW_ERR = ((int32_t)HSI2C_ERROR_BASE - 7)
}LLD_hsi2cErrorCode_t;

typedef enum {
    EDMA_TRANSFER_SUCCESS,
    EDMA_TRANSFER_FAIL
}LLD_hsi2cEdmaStatus;

/* ========================================================================== */
/** LLD_Hsi2cInstId_t defines I2C instances that can be selected to operated.
 *  These values are passed as argument to lld_i2c_init() and lld_i2c_open fn
 *
 *  @param    HSI2C_INST_0      0th instance
 *  @param    HSI2C_INST_1      1st instance
 *  @param    HSI2C_INST_2      2nd instance
 *  @param    HSI2C_INST_3      3rd instance
 *  @param    HSI2C_INST_4      4th instance
 *  @param    HSI2C_INST_5      5th instance
 *  @param    HSI2C_INST_MAX    Maximum instances that are supported
 *
 */
/* ========================================================================== */
typedef enum
{
    HSI2C_INST_0 = 0,
    HSI2C_INST_1,
#if defined (TI814X_FAMILY_BUILD) || defined (TDA2XX_FAMILY_BUILD)
    HSI2C_INST_2,
    HSI2C_INST_3,
#endif
    /*TI814x has only 4 instance*/
#ifdef TDA2XX_FAMILY_BUILD
    HSI2C_INST_4,
#if defined (TDA2EX_BUILD)
    HSI2C_INST_5,
#endif
#endif
    /**< TODO Many places instance is asserted with < HSI2C_INST_MAX.
     *      This asserts. Please check and fix */
    HSI2C_INST_MAX_1,

    HSI2C_INST_MAX
}LLD_Hsi2cInstId_t;

/* ========================================================================== */
/**
 *
 *  @def    hsI2cHandle       -    defines the I2C lld handle type
 *
 */
/* ========================================================================== */
typedef void *hsI2cHandle;

/* ========================================================================== */
/**
 * @def    hsI2cObjHandle       -    defines the I2C lld Obj handle type
 */
/* ========================================================================== */
typedef void *hsI2cObjHandle;

/* ========================================================================== */
/**
 *
 *  @def    lldHsi2cAppCallback       -    I2C lld application callback function
 *                                         format
 *
 */
/* ========================================================================== */
typedef void (*lldHsi2cAppCallback)(hsI2cHandle appHandle,
                                    LLD_hsi2cErrorCode_t status, void *appData);

typedef void (*lldHsi2cEdmaCallback)(uint32_t            tcc,
                                     LLD_hsi2cEdmaStatus i2cEdmaErrStatus,
                                     void               *arg);

typedef void (*lld_hsi2c_isr_handler)(void *handle);

/* ========================================================================== */
/**
 *   lld_hsi2c_initParam_s contains the I2C initialisation parameters.
 *   This is passed as an argument to lld_i2c_init() API.
 *
 *   @see enum lld_hsi2c_opMode
 */
/* ========================================================================== */
typedef struct lld_hsi2c_initParam_s {
    /* Driver operating mode - polled ,interrupt or DMA.
     * For valid values see lld_hsi2c_opMode
     */
    lld_hsi2c_opMode opMode;

    /* Operating in Master/Slave mode:
     * 0: Slave mode
     * 1: Master mode
     */
    uint32_t         isMasterMode;

    /* Addressing mode:
     * 0: 7 bit addressing mode
     * 1: 10 bit addressing mode
     */
    uint32_t         is10BitAddr;

    /* I2C Bus Frequency (in KHz)
     */
    lld_i2c_busspeed i2cBusFreq;

    /*Own address (7 or 10 bits)
     */
    uint32_t         i2cOwnAddr;

    /*Interrupt number
     */
    uint32_t         i2cIntNum;

    /*
     * Edma Handle
     */
    /* void *                    hEdma;*/

    /*
     * Event Number
     */

    /* int32_t                   edma3EventQueue;*/

    /*
     * EDMA parameters
     */
    void                 *edmaParam;

    lld_hsi2c_isr_handler i2cIsr;
}lld_hsi2c_initParam_t;

/* ========================================================================== */
/**
 *   lld_hsi2c_datatfr_params_s contains the I2C transfer parameters.
 *   This is passed as an argument to lld_i2c_transfer() API.
 *
 *   @see
 */
/* ========================================================================== */
typedef struct lld_hsi2c_datatfr_params_s
{
    /* Address of the slave to talk to, not valid in Slave mode
     */
    uint8_t  slaveAddr;

    /* Data buffer
     */
    uint8_t *buffer;

    /* Length of buffer
     */
    uint32_t bufLen;

    /* Flags to indicate the various modes of operation
     */
    uint32_t flags;

    /* Timeout value
     */
    uint32_t timeout;
}lld_hsi2c_datatfr_params_t;

/* ========================================================================= */
/**
 * @fn      lld_i2c_init() Initializes i2c instance object properties.
 *          Read the application initialization parameters & initialize
 *          the data structure. Changes the state to created after successful
 *          initialization.
 *
 * @param   i2cObjHandle  Handle to the instance object
 * @param   numInstance   Instance ID(i2c port number).
 * @param   initParams    Initialization parameters.
 *
 * @return  status    status of the initialization.
 *                    HAL_HSI2C_SUCCESS - if initialization is successful
 *                    HAL_HSI2C_FAIL -    if initialization fails
 *                    HAL_HSI2C_BADARGS - if wrong argument is passed
 *
 * @see
 */
/* ========================================================================= */
LLD_hsi2cErrorCode_t lld_i2c_init(hsI2cObjHandle        *i2cObjHandle,
                                  LLD_Hsi2cInstId_t      numInstance,
                                  lld_hsi2c_initParam_t *initParams);

/* ========================================================================= */
/**
 * @fn      lld_i2c_open() creates the handle for I2C port for a open.
 *          There can be maximum of HSI2C_NUM_OPENS opens
 *          Initialize the hardware port & change the state to open
 *          Funtion is not Re-entrant. Please use semaphore in the application
 *
 * @param   instanceId     Instance Id(i2c port number)
 * @param   appCallback    Application call back function
 * @param   appData        Application data to be passed to call back function
 *
 * @return  hsI2cHandle    valid handle is successful
 *                         NULL if failed to open
 *
 * @see
 */
/* ========================================================================= */
hsI2cHandle          lld_i2c_open(LLD_Hsi2cInstId_t   instanceId,
                                  lldHsi2cAppCallback appCallback,
                                  void               *appData);

/* ========================================================================= */
/**
 * @fn      lld_i2c_transfer() is used to send or receive data
 *          Data is transfered depending on the mode of operation(DMA, Interrupt
 *          or polled)
 *          Function is not Re-entrant. Please use semaphore lock in the
 *          application
 *
 *
 * @param   handle           Handle to I2C port
 * @param   i2cXferParams    Data transfer parameters
 *
 * @return  status    Status of transfer or error code
 *                    LLD_HSI2C_SUCCESS - if initialization is successful
 *                    LLD_HSI2C_FAIL    -    if initialization fails
 *                    LLD_HSI2C_BADARGS - if wrong argument is passed
 *
 * @see
 */
/* ========================================================================= */
LLD_hsi2cErrorCode_t lld_i2c_transfer(
    hsI2cHandle handle,
    const lld_hsi2c_datatfr_params_t *
    i2cXferParams);

/* ========================================================================= */
/**
 * @fn      lld_i2c_close() closes the handle for I2C port for a open.
 *          Decreaments number of open handles. Changes the state of object
 *          to CLOSED. Clears the handle
 *
 * @param   hsI2cHandle    i2c handle
 *
 * @return  status    status of close
 *                    LLD_HSI2C_SUCCESS - close successful
 *                    LLD_HSI2C_FAIL    - close failed
 *
 * @see
 */
/* ========================================================================= */
LLD_hsi2cErrorCode_t lld_i2c_close(hsI2cHandle *handle);

/* ========================================================================= */
/**
 * @fn      lld_i2c_probe() probes the i2c device for the slave address passed
 *
 * @param   handle      i2c handle
 * @param   slaveAddr   address of the device to be probed
 *
 * @return  status    status of probe
 *                    LLD_HSI2C_BADARGS - if arguments are incorrect
 *                    LLD_HSI2C_SUCCESS - close successful
 *                    LLD_HSI2C_FAIL    - close failed
 *
 * @see
 */
/* ========================================================================= */
LLD_hsi2cErrorCode_t lld_i2c_probe(hsI2cHandle handle, uint8_t slaveAddr);

/* ========================================================================= */
/**
 * @fn      lld_i2c_recoverBus() Generate 9 CLK pulses on SCL
 *
 * @param   handle      i2c handle
 * @param   i2cDelay    used as busy loop count down value to generate delay
 *                      in toggelling SCL signal (high to low or low to high)
 *
 * @return  status    status of probe
 *                    LLD_HSI2C_BADARGS - if arguments are incorrect
 *                    LLD_HSI2C_SUCCESS - generate clock pulse successful
 *
 * @see
 */
/* ========================================================================= */
LLD_hsi2cErrorCode_t lld_i2c_recoverBus(hsI2cHandle handle, uint32_t i2cDelay);

/* ========================================================================= */
/**
 * @fn      lld_i2c_resetCtrl() resets the i2c controller
 *
 * @param   handle      i2c handle
 *
 * @return  status    status of contoller reset
 *                    LLD_HSI2C_BADARGS - if arguments are incorrect
 *                    LLD_HSI2C_SUCCESS - ctrl reset successful
 *                    LLD_HSI2C_FAIL    - ctrl reset failed
 *
 * @see
 */
/* ========================================================================= */
LLD_hsi2cErrorCode_t lld_i2c_resetCtrl(hsI2cHandle handle);

/* ========================================================================= */
/**
 * @fn      lld_i2c_deinit() closes all the handles and clears the instance
 *          for the instance number passed
 *
 * @param   numInstance  instance number
 *
 * @return  status    status of de initialization
 *                    LLD_HSI2C_SUCCESS - de-initialization successful
 *
 * @see
 */
/* ========================================================================= */
LLD_hsi2cErrorCode_t lld_i2c_deinit(LLD_Hsi2cInstId_t numInstance);

/* ========================================================================= */
/**
 * @fn      lld_i2c_getInitParams() gets the init Params
 *          of the instance belonging to the handle passed
 *
 * @param   i2chandle  i2c handle
 *
 * @param   initParams  initParams which needs to be updated.
 *
 * @return  -
 *
 * @see
 */
/* ========================================================================= */
void lld_i2c_getInitParams(hsI2cHandle            i2chandle,
                           lld_hsi2c_initParam_t *initParams);

/* ========================================================================= */
/**
 * @fn      lld_i2c_getInstNum() gets the instance Number
 *          of the handle passed
 *
 * @param   i2chandle  i2c handle
 *
 * @param   instNum  instNum which needs to be updated.
 *
 * @return  -
 *
 * @see
 */
/* ========================================================================= */
void lld_i2c_getInstNum(hsI2cHandle i2chandle, LLD_Hsi2cInstId_t *instNum);

/* ========================================================================= */
/**
 * @fn      lld_i2c_getOpenCount() gets the open count
 *          of the instance belonging to the handle passed
 *
 * @param   i2chandle  i2c handle
 *
 * @param   instNum  instNum which needs to be updated.
 *
 * @return  -
 *
 * @see
 */
/* ========================================================================= */
void lld_i2c_getOpenCount(hsI2cHandle i2chandle, uint8_t *numOpens);

/* ========================================================================= */
/**
 * @fn      lld_i2c_SetFifoThreshold() sets the threshold value for FIFO for
 *          buffered transfer.
 *
 *          Note : API should be called before calling lld_i2c_open and after
 *                 calling lld_i2c_init
 *
 * @param   instanceId   i2c instance number can be one of the following values
 *         from
 *          enum LLD_Hsi2cInstId_t
 *              HSI2C_INST_0 = 0,
 *              HSI2C_INST_1
 *              HSI2C_INST_2
 *              HSI2C_INST_3
 *              HSI2C_INST_4
 *              HSI2C_INST_5
 *
 * @param   rxThreshold  Threshold value for Rx FIFO
 *
 * @param   txThreshold  Threshold value for Tx FIFO
 *
 *          rxThreshold or txThreshold can take values 0-31 to configure FIFO
 *          from 1 to 32 bytes
 *          value 0 = 1 byte(default)
 *
 *
 * @return  LLD_hsi2cErrorCode_t    Status.
 *                    HAL_HSI2C_SUCCESS - if success
 *                    HAL_HSI2C_BADARGS - if instanceId is wrong
 *
 * @see
 */
/* ========================================================================= */
LLD_hsi2cErrorCode_t lld_i2c_SetFifoThreshold(LLD_Hsi2cInstId_t instanceId,
                                              uint8_t           rxThreshold,
                                              uint8_t           txThreshold);
/* ========================================================================= */
/**
 * @fn      lld_i2c_clockConfig() configures I2C bus clock frequency
 *
 *          Note : API should be called after calling lld_i2c_open and before
 *                 calling lld_i2c_transfer. This API can be used in two case
 *                 1. If functional clock to I2C is other than that of the
 *                    default functional clock used for TDA2XX(96 MHz)
 *                    and TI814x(48 MHz)
 *                 2. Changing frequency on demand without reinitializing the
 *                    driver
 *
 * @param   instanceId   i2c instance number can be one of the following values
 *         from
 *          enum LLD_Hsi2cInstId_t
 *              HSI2C_INST_0 = 0,
 *              HSI2C_INST_1
 *              HSI2C_INST_2
 *              HSI2C_INST_3
 *              HSI2C_INST_4
 *              HSI2C_INST_5
 *
 * @param   functionalClock  Functional input clock to I2C in Hz
 *              e.g. for 24 MHz input clock provide 24000000
 *              Default functional clock used for TDA2XX is 96 MHz
 *               and for TI814x is 48 MHz
 *
 * @param   busFrequency  I2C output frequency in kbps
 *          as defined by lld_i2c_busspeed enum
 *
 * @return  LLD_hsi2cErrorCode_t    LLD_HSI2C_SUCCESS Status.
 *
 * @see
 */
/* ========================================================================= */
LLD_hsi2cErrorCode_t lld_i2c_clockConfig(LLD_Hsi2cInstId_t instanceId,
                                         uint32_t          functionalClock,
                                         lld_i2c_busspeed  busFrequency);

/* ========================================================================= */

/**
 * @fn      lld_i2c_getClockDiv() returns I2C Clock divider values
 *
 *          Note : API should be called after calling lld_i2c_open and before
 *                 calling lld_i2c_transfer.
 *
 * @param   instanceId   i2c instance number can be one of the following values
 *         from
 *          enum LLD_Hsi2cInstId_t
 *              HSI2C_INST_0 = 0,
 *              HSI2C_INST_1
 *              HSI2C_INST_2
 *              HSI2C_INST_3
 *              HSI2C_INST_4
 *              HSI2C_INST_5
 *
 * @param   sCll  pointer to sCll divider value
 *
 * @param   sClh  pointer to sClh divider value
 *
 * @param   pSc  pointer to pSc divider value
 *
 *
 * @return  LLD_hsi2cErrorCode_t    LLD_HSI2C_SUCCESS Status.
 *
 * @see
 */

/* ========================================================================= */
LLD_hsi2cErrorCode_t lld_i2c_getClockDiv(LLD_Hsi2cInstId_t instanceId,
                                         uint32_t         *sCll,
                                         uint32_t         *sClh,
                                         uint32_t         *pSc);

/* ========================================================================= */

/**
 * @fn      lld_i2c_setClockDiv() returns I2C Clock divider values
 *
 *          Note : API should be called after calling lld_i2c_open and before
 *                 calling lld_i2c_transfer.Normal sequence should be
 *                 lld_i2c_clockConfig, lld_i2c_getClockDiv and then
 *                 lld_i2c_setClockDiv
 *
 * @param   instanceId   i2c instance number can be one of the following values
 *         from
 *          enum LLD_Hsi2cInstId_t
 *              HSI2C_INST_0 = 0,
 *              HSI2C_INST_1
 *              HSI2C_INST_2
 *              HSI2C_INST_3
 *              HSI2C_INST_4
 *              HSI2C_INST_5
 *
 * @param   sCll  Actual sCll divider value
 *
 * @param   sClh  Actual sClh divider value
 *
 * @param   pSc  Actual  pSc divider value
 *
 *
 * @return  LLD_hsi2cErrorCode_t    LLD_HSI2C_SUCCESS Status.
 *
 * @see
 */

/* ========================================================================= */
LLD_hsi2cErrorCode_t lld_i2c_setClockDiv(LLD_Hsi2cInstId_t instanceId,
                                         uint32_t          sCll,
                                         uint32_t          sClh,
                                         uint32_t          pSc);

/* ========================================================================= */
/**
 * @fn      lld_i2c_getFclk() gets the I2C bus input clock frequency
 *
 *             Default functional clock used for TDA2XX is 96 MHz
 *                    and TI814x is 48 MHz
 *
 *
 * @param   instanceId   i2c instance number can be one of the following values
 *         from
 *          enum LLD_Hsi2cInstId_t
 *              HSI2C_INST_0 = 0,
 *              HSI2C_INST_1
 *              HSI2C_INST_2
 *              HSI2C_INST_3
 *              HSI2C_INST_4
 *              HSI2C_INST_5
 *
 *
 *
 * @return  uint32_t   Functional input clock to I2C in Hz
 *
 * @see
 */
/* ========================================================================= */
uint32_t lld_i2c_getFclk(LLD_Hsi2cInstId_t instanceId);

/* ========================================================================= */
/**
 * @fn      lld_i2c_setFclk() sets the I2C bus input clock frequency
 *
 *          Note : API should be called before calling lld_i2c_open and after
 *          calling lld_i2c_init. This API can be used to specify the input
 *          functional clock to I2C. Applicationr Should take care that
 *           appropriate input clock is already provided to the I2C  as
 *          part of system init.
 *           This API does not take care of checking if the input clock
 *           provided is valid
 *
 *
 * @param   instanceId   i2c instance number can be one of the following values
 *         from
 *          enum LLD_Hsi2cInstId_t
 *              HSI2C_INST_0 = 0,
 *              HSI2C_INST_1
 *              HSI2C_INST_2
 *              HSI2C_INST_3
 *              HSI2C_INST_4
 *              HSI2C_INST_5
 *
 * @param   fclk  Functional input clock to I2C in Hz
 *
 *
 * @return  LLD_hsi2cErrorCode_t    LLD_HSI2C_SUCCESS Status.
 *
 * @see
 */
/* ========================================================================= */
LLD_hsi2cErrorCode_t lld_i2c_setFclk(LLD_Hsi2cInstId_t instanceId,
                                     uint32_t          fclk);

/* ========================================================================= */
/**
 * @fn      lld_i2c_getIclk() gets the I2C internal clock frequency
 *
 *             Default Internal clock used for FAST Mode is 12 MHz
 *                    and NORMAL Mode is 4 MHz
 *
 *
 * @param   instanceId   i2c instance number can be one of the following values
 *         from
 *          enum LLD_Hsi2cInstId_t
 *              HSI2C_INST_0 = 0,
 *              HSI2C_INST_1
 *              HSI2C_INST_2
 *              HSI2C_INST_3
 *              HSI2C_INST_4
 *              HSI2C_INST_5
 *
 *
 *
 * @return  uint32_t   Internal clock to I2C in Hz.
 *
 * @see
 */
/* ========================================================================= */
uint32_t lld_i2c_getIclk(LLD_Hsi2cInstId_t instanceId);

/* ========================================================================= */
/**
 * @fn      lld_i2c_setIclk() sets the I2C Internal clock frequency
 *
 *          Note : API should be called before calling lld_i2c_open and after
 *          calling lld_i2c_init. This API can be used to specify the input
 *          functional clock to I2C. Applicationr Should take care that
 *           appropriate input clock is already provided to the I2C  as
 *          part of system init.
 *           This API does not take care of checking if the input clock
 *           provided is valid
 *
 *
 * @param   instanceId   i2c instance number can be one of the following values
 *         from
 *          enum LLD_Hsi2cInstId_t
 *              HSI2C_INST_0 = 0,
 *              HSI2C_INST_1
 *              HSI2C_INST_2
 *              HSI2C_INST_3
 *              HSI2C_INST_4
 *              HSI2C_INST_5
 *
 * @param   iclk  Internal clock to I2C in Hz
 *
 *
 * @return  LLD_hsi2cErrorCode_t    LLD_HSI2C_SUCCESS Status.
 *
 * @see
 */
/* ========================================================================= */
LLD_hsi2cErrorCode_t lld_i2c_setIclk(LLD_Hsi2cInstId_t instanceId,
                                     uint32_t          iclk);

/* ========================================================================= */
/**
 * @fn      lld_i2c_getBusFreq() gets the current I2C bus frequency in KHz
 *
 * @param   instanceId   i2c instance number can be one of the following values
 *         from
 *          enum LLD_Hsi2cInstId_t
 *              HSI2C_INST_0 = 0,
 *              HSI2C_INST_1
 *              HSI2C_INST_2
 *              HSI2C_INST_3
 *              HSI2C_INST_4
 *              HSI2C_INST_5
 *
 * @param   busFrequency   pointer to store the current i2c bus frequency
 *
 * @return  LLD_hsi2cErrorCode_t    LLD_HSI2C_SUCCESS Status.
 *
 * @see
 */
/* ========================================================================= */
LLD_hsi2cErrorCode_t lld_i2c_getBusFreq(LLD_Hsi2cInstId_t instanceId,
                                        lld_i2c_busspeed *busFreq);

/* ========================================================================= */
/**
 * @fn      lld_i2c_setBusFreq() sets the current I2C bus frequency in KHz.
 *
 * @param   instanceId   i2c instance number can be one of the following values
 *         from
 *          enum LLD_Hsi2cInstId_t
 *              HSI2C_INST_0 = 0,
 *              HSI2C_INST_1
 *              HSI2C_INST_2
 *              HSI2C_INST_3
 *              HSI2C_INST_4
 *              HSI2C_INST_5
 *
 * @param   busFreq   i2c bus frequencyto be configured in KHz
 *
 * @return  LLD_hsi2cErrorCode_t    LLD_HSI2C_SUCCESS Status.
 *
 * @see
 */
/* ========================================================================= */
LLD_hsi2cErrorCode_t lld_i2c_setBusFreq(LLD_Hsi2cInstId_t instanceId,
                                        lld_i2c_busspeed  busFreq);

LLD_hsi2cErrorCode_t lld_i2c_abort_transfer(hsI2cHandle handle);

#ifdef __cplusplus
}
#endif

#endif

