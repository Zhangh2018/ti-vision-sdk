<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>NDK Stack Documentation: src/stack/nimu/nimu.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="tilogo.gif"></a></td>
  <td bgcolor="red"><img src="titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>src/stack/nimu/nimu.c File Reference</h1>Implements the network interface management code. This is required when the NDK Core stack has been built to be able to handle multiple drivers. The file has the code which resides in the data path. <a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nimu_8c.html#40bc7cf8f9ea4ff3baf89fbec104dae3">NIMUSendPacket</a> (HANDLE hIF, PBM_Pkt *pPkt)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nimu_8c.html#13888518b584af2022631daf5e4fef1b">NIMUAddHeader</a> (NETIF_DEVICE *ptr_device, HANDLE hPkt, UINT8 *dst_mac, UINT8 *src_mac, UINT16 protocol)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nimu_8c.html#9cdbd6e5db0d72bd8fbb0f34cc7f5fcd">NIMUPacketService</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nimu_8c.html#0a17fa199fd7f85fbbd6a0aa68891c3a">NIMUPacketServiceCheck</a> (int fEvents)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nimu_8c.html#f5941d66ae70c755844000709980261a">NIMUReceivePacket</a> (PBM_Handle hPkt)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PBM_Pkt *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nimu_8c.html#df5354cab738c61c0a1a547cd6f958b2">NIMUCreatePacket</a> (uint packet_size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nimu_8c.html#e7ca5fb64f8984e93157f88000ef28d3">NIMUAddEthernetHeader</a> (NETIF_DEVICE *ptr_net_device, PBM_Handle hPkt, UINT8 *dst_mac, UINT8 *src_mac, UINT16 ether_type)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NETIF_DEVICE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nimu_8c.html#3f87ad0419f63f130e48346cf08a048f">NIMUFindByIndex</a> (uint index)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NETIF_DEVICE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nimu_8c.html#3fa109f660fedb79bd34ecd2082a229c">NIMUFindByName</a> (char *name)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nimu_8c.html#6cef7c784675809ba2953387c92d52b5">NIMURegister</a> (NETIF_DEVICE *ptr_netif_device)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nimu_8c.html#430f8657a52056801f3ac1acae57efa6">NIMUUnregister</a> (NETIF_DEVICE *ptr_netif_device)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nimu_8c.html#3906b407bf2656ec8455459c369b1576">NIMUIoctl</a> (uint cmd, NIMU_IF_REQ *ptr_nimu_ifreq, void *pBuf, uint size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nimu_8c.html#2fb9298ca5d02c03be8a659d1d25edcb">NIMUGetRsvdSizeInfo</a> (int *header_size, int *trailer_size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nimu_8c.html#ced475d01ad0cb49490cdd2a96079e73">NIMUSetRsvdSizeInfo</a> (int header_size, int trailer_size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nimu_8c.html#277dfd331bce6a2f01b4976af100ede9">NIMUInit</a> (STKEVENT_Handle hEvent)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nimu_8c.html#5d33c21047775afa40c2632bea771907">NIMUShutdown</a> (void)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Implements the network interface management code. This is required when the NDK Core stack has been built to be able to handle multiple drivers. The file has the code which resides in the data path. 
<p>
<dl class="user" compact><dt><b></b></dt><dd>NOTE: (C) Copyright 2008, Texas Instruments, Inc.</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd></dd></dl>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="e7ca5fb64f8984e93157f88000ef28d3"></a><!-- doxytag: member="nimu.c::NIMUAddEthernetHeader" ref="e7ca5fb64f8984e93157f88000ef28d3" args="(NETIF_DEVICE *ptr_net_device, PBM_Handle hPkt, UINT8 *dst_mac, UINT8 *src_mac, UINT16 ether_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NIMUAddEthernetHeader           </td>
          <td>(</td>
          <td class="paramtype">NETIF_DEVICE *&nbsp;</td>
          <td class="paramname"> <em>ptr_net_device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PBM_Handle&nbsp;</td>
          <td class="paramname"> <em>hPkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT8 *&nbsp;</td>
          <td class="paramname"> <em>dst_mac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT8 *&nbsp;</td>
          <td class="paramname"> <em>src_mac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT16&nbsp;</td>
          <td class="paramname"> <em>ether_type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function is a UTILITY function which is provided for use to driver authors if the driver is a simple Ethernet driver. Driver Authors should initialize the 'add_header' field of the NIMU Network Interface object to this function.<p>
This will ensure that all packets passed to the driver are pre-pended with the correct layer2 ethernet header before they are transmitted. Failure to do will cause no Layer2 headers to be added.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr_net_device</em>&nbsp;</td><td>The NIMU Network interface object on which the packet will be transmitted and which is used to tag the correct L2 header. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hPkt</em>&nbsp;</td><td>Handle to the packet which will be sent out and on which the L2 header is added. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dst_mac</em>&nbsp;</td><td>The Dst MAC Address to be added on the packet </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>src_mac</em>&nbsp;</td><td>The Src MAC Address to be added on the packet </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ether_type</em>&nbsp;</td><td>The 'Protocol' tag which needs to be appended.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>- Success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>&lt;0</em>&nbsp;</td><td>- Error </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="13888518b584af2022631daf5e4fef1b"></a><!-- doxytag: member="nimu.c::NIMUAddHeader" ref="13888518b584af2022631daf5e4fef1b" args="(NETIF_DEVICE *ptr_device, HANDLE hPkt, UINT8 *dst_mac, UINT8 *src_mac, UINT16 protocol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NIMUAddHeader           </td>
          <td>(</td>
          <td class="paramtype">NETIF_DEVICE *&nbsp;</td>
          <td class="paramname"> <em>ptr_device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HANDLE&nbsp;</td>
          <td class="paramname"> <em>hPkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT8 *&nbsp;</td>
          <td class="paramname"> <em>dst_mac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT8 *&nbsp;</td>
          <td class="paramname"> <em>src_mac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT16&nbsp;</td>
          <td class="paramname"> <em>protocol</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function is used to add an appropriate layer2 header as specified by the NIMU object. This function is called when the packet is passed down from layer3 to layer2 and is used to prep the packet by adding the correct layer2 header.<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr_device</em>&nbsp;</td><td>The NIMU Network interface object on which the packet will be transmitted and which is used to tag the correct L2 header. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hPkt</em>&nbsp;</td><td>Handle to the packet which will be sent out and on which the L2 header is added. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dst_mac</em>&nbsp;</td><td>The Dst MAC Address to be added on the packet </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>src_mac</em>&nbsp;</td><td>The Src MAC Address to be added on the packet </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>protocol</em>&nbsp;</td><td>The 'Protocol' tag which needs to be appended.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>- Success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>&lt;0</em>&nbsp;</td><td>- Error </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="df5354cab738c61c0a1a547cd6f958b2"></a><!-- doxytag: member="nimu.c::NIMUCreatePacket" ref="df5354cab738c61c0a1a547cd6f958b2" args="(uint packet_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PBM_Pkt* NIMUCreatePacket           </td>
          <td>(</td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>packet_size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function is a generic utility function which creates a packet that is used for transmission on any network interface object which has been registered with the NIMU. The packet allocated has 'header' and 'trailer' padding added.<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>packet_size</em>&nbsp;</td><td>Size of the packet which needs to be allocated.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Handle</em>&nbsp;</td><td>to the packet - Success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NULL</em>&nbsp;</td><td>- Error </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3f87ad0419f63f130e48346cf08a048f"></a><!-- doxytag: member="nimu.c::NIMUFindByIndex" ref="3f87ad0419f63f130e48346cf08a048f" args="(uint index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NETIF_DEVICE* NIMUFindByIndex           </td>
          <td>(</td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function searches the NIMU database and finds an entry matching the device 'index'<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>The device index we are trying to locate.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NIMU</em>&nbsp;</td><td>Network Interface Object - Matching entry found. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NULL</em>&nbsp;</td><td>- No Match </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3fa109f660fedb79bd34ecd2082a229c"></a><!-- doxytag: member="nimu.c::NIMUFindByName" ref="3fa109f660fedb79bd34ecd2082a229c" args="(char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NETIF_DEVICE* NIMUFindByName           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function searches the NIMU database and finds an entry matching the device 'name'<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>The device name we are trying to locate.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NIMU</em>&nbsp;</td><td>Network Interface Object - Matching entry found. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NULL</em>&nbsp;</td><td>- No Match </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2fb9298ca5d02c03be8a659d1d25edcb"></a><!-- doxytag: member="nimu.c::NIMUGetRsvdSizeInfo" ref="2fb9298ca5d02c03be8a659d1d25edcb" args="(int *header_size, int *trailer_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NIMUGetRsvdSizeInfo           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>header_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>trailer_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function is to used to retrieve the header and trailer reserved size information. The Network Interface Management Unit keeps track of all devices present in the system and is also responsible for ensuring that there is suffient headroom and tailroom for various driver layers to be able to add headers or trailers as the need be. This ensures that there are no copies being done because of insufficient headroom.<p>
The function is available for usage; but it should only be called from kernel mode (llEnter()/llExit())<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>header_size</em>&nbsp;</td><td>The current header size which is reserved. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>trailer_size</em>&nbsp;</td><td>The current trailer size which is reserved. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Not</em>&nbsp;</td><td>Applicable. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="277dfd331bce6a2f01b4976af100ede9"></a><!-- doxytag: member="nimu.c::NIMUInit" ref="277dfd331bce6a2f01b4976af100ede9" args="(STKEVENT_Handle hEvent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NIMUInit           </td>
          <td>(</td>
          <td class="paramtype">STKEVENT_Handle&nbsp;</td>
          <td class="paramname"> <em>hEvent</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function initializes the NDK core stack Network Interface Management Unit<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hEvent</em>&nbsp;</td><td>The stack event handle which is used by the NDK Network Scheduler to indicate data is present on the drivers. This handle is required by the drivers for its operation.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>- Success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>&lt;0</em>&nbsp;</td><td>- Error </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3906b407bf2656ec8455459c369b1576"></a><!-- doxytag: member="nimu.c::NIMUIoctl" ref="3906b407bf2656ec8455459c369b1576" args="(uint cmd, NIMU_IF_REQ *ptr_nimu_ifreq, void *pBuf, uint size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NIMUIoctl           </td>
          <td>(</td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NIMU_IF_REQ *&nbsp;</td>
          <td class="paramname"> <em>ptr_nimu_ifreq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function is the standard IOCTL interface to the NIMU module and is used to get/set parameters to the NIMU. The API is available to use for applications outside the core NDK stack since it does the necessary llEnter/llExit.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cmd</em>&nbsp;</td><td>One of the special commands mentioned above. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr_nimu_ifreq</em>&nbsp;</td><td>The NIMU Interface request structure which identifies the NIMU object to which the 'cmd' is directed upon. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pBuf</em>&nbsp;</td><td>The pointer to the buffer where the result of the command execution will be stored. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size</em>&nbsp;</td><td>The size of the result buffer i.e. pBuf.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>- Success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>&lt;0</em>&nbsp;</td><td>- Error </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9cdbd6e5db0d72bd8fbb0f34cc7f5fcd"></a><!-- doxytag: member="nimu.c::NIMUPacketService" ref="9cdbd6e5db0d72bd8fbb0f34cc7f5fcd" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NIMUPacketService           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function is called by the NDK Net Scheduler to service all NIMU Network Interface objects registered in the system. This is called when the NDK scheduler detects that a packet has been received by the lower HAL drivers and needs to be serviced.<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Not</em>&nbsp;</td><td>Applicable. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0a17fa199fd7f85fbbd6a0aa68891c3a"></a><!-- doxytag: member="nimu.c::NIMUPacketServiceCheck" ref="0a17fa199fd7f85fbbd6a0aa68891c3a" args="(int fEvents)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NIMUPacketServiceCheck           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fEvents</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function is called by the NDK Net Scheduler to allow HAL drivers to be able to perform 'periodic' activities; such as Ethernet Link management. There also exists a mode in which the HAL drivers can execute in 'polled' mode. In this case this the HAL drivers do not use 'interrupts' and are polled by the NDK Net Scheduler to check for transmit/receive activity.<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fEvents</em>&nbsp;</td><td>This is set to 1 if the function is invoked by the NDK Net Scheduler because of a timer tick. Set to 0 otherwise. This flag is available to the HAL drivers to determine the source of the function invocation.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Not</em>&nbsp;</td><td>Applicable. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f5941d66ae70c755844000709980261a"></a><!-- doxytag: member="nimu.c::NIMUReceivePacket" ref="f5941d66ae70c755844000709980261a" args="(PBM_Handle hPkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NIMUReceivePacket           </td>
          <td>(</td>
          <td class="paramtype">PBM_Handle&nbsp;</td>
          <td class="paramname"> <em>hPkt</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 This routine is the API interface routine which needs to be invoked by the drivers to pass the packet up the NDK core stack The function takes the raw packet received from the MAC device, and validates the link level related data. Packets are passed up the stack on the basis of the 'protocol' field.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hPkt</em>&nbsp;</td><td>Handle to the packet which is to be passed up the NDK stack.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>- Error </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>- Success </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6cef7c784675809ba2953387c92d52b5"></a><!-- doxytag: member="nimu.c::NIMURegister" ref="6cef7c784675809ba2953387c92d52b5" args="(NETIF_DEVICE *ptr_netif_device)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NIMURegister           </td>
          <td>(</td>
          <td class="paramtype">NETIF_DEVICE *&nbsp;</td>
          <td class="paramname"> <em>ptr_netif_device</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 This API is used by driver authors to register a network device with the NDK Network Interface Management Unit. The function verifies the arguments, checks for duplicates and adds the device to NIMU (Network Interface Management Unit)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr_netif_device</em>&nbsp;</td><td>The NIMU Network Interface Object to be registered.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>- Success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>&lt;0</em>&nbsp;</td><td>- Error </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="40bc7cf8f9ea4ff3baf89fbec104dae3"></a><!-- doxytag: member="nimu.c::NIMUSendPacket" ref="40bc7cf8f9ea4ff3baf89fbec104dae3" args="(HANDLE hIF, PBM_Pkt *pPkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NIMUSendPacket           </td>
          <td>(</td>
          <td class="paramtype">HANDLE&nbsp;</td>
          <td class="paramname"> <em>hIF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PBM_Pkt *&nbsp;</td>
          <td class="paramname"> <em>pPkt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function is the interface routine which is called to send a packet via the registered the NIMU Network Interface Object.<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hIF</em>&nbsp;</td><td>Handle of the NIMU Network interface object on which the packet will be transmitted. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pPkt</em>&nbsp;</td><td>Handle to the packet which needs to be sent </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Not</em>&nbsp;</td><td>Applicable. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ced475d01ad0cb49490cdd2a96079e73"></a><!-- doxytag: member="nimu.c::NIMUSetRsvdSizeInfo" ref="ced475d01ad0cb49490cdd2a96079e73" args="(int header_size, int trailer_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NIMUSetRsvdSizeInfo           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>header_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>trailer_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function is to used to set the header and trailer reserved size information. This is typically used by driver authors if the driver needs a L2 header or trailer and the current size are not sufficient.<p>
There is no validation done on the arguments.<p>
The function is available for usage; but it should only be called from kernel mode (llEnter()/llExit())<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>header_size</em>&nbsp;</td><td>The new header size which is to be reserved </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>trailer_size</em>&nbsp;</td><td>The new trailer size which is to be reserved </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Not</em>&nbsp;</td><td>Applicable. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5d33c21047775afa40c2632bea771907"></a><!-- doxytag: member="nimu.c::NIMUShutdown" ref="5d33c21047775afa40c2632bea771907" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NIMUShutdown           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 The function closes the NDK core stack Network Interface Management Unit<p>
This is for *internal* NDK Stack Usage.<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Not</em>&nbsp;</td><td>applicable. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="430f8657a52056801f3ac1acae57efa6"></a><!-- doxytag: member="nimu.c::NIMUUnregister" ref="430f8657a52056801f3ac1acae57efa6" args="(NETIF_DEVICE *ptr_netif_device)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NIMUUnregister           </td>
          <td>(</td>
          <td class="paramtype">NETIF_DEVICE *&nbsp;</td>
          <td class="paramname"> <em>ptr_netif_device</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description</b> <br>
 This API is used by driver authors to unregister and stop the network device from the NIMU. The device should have been registered with the NIMU.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr_netif_device</em>&nbsp;</td><td>The NIMU Network Interface Object to be unregistered.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>- Success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>&lt;0</em>&nbsp;</td><td>- Error </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr size="1"><small>
Copyright  2009, Texas Instruments Incorporated</small>
</body>
</html>
