% /*==========================================================================*/
% /*      Copyright (C) 2009-2015 Texas Instruments Incorporated.             */
% /*                      All Rights Reserved                                 */
% /*==========================================================================*/

% rectify_stereo_pair.m
%
% Script file that rectifies a set of stereo images after stereo calibration
% This script loads the stereo calibration file Calib_Results_stereo generated by calib_stereo.m
% Therefore, type help calib_stereo for more information.
function generateRemapTLU(stereoVision_tb_dir, output_dir),


qFactor= 4;

if ~exist('fc_right')|~exist('cc_right')|~exist('kc_right')|~exist('alpha_c_right')|~exist('fc_left')|~exist('cc_left')|~exist('kc_left')|~exist('alpha_c_left')|~exist('om')|~exist('T')
    
    if exist('Calib_Results_stereo.mat')~=2,
        fprintf(1,'No stereo calibration data.\n');
        return;
    else
        fprintf(1,'\nLoading the stereo calibration file Calib_Results_stereo.mat.\n');
        load Calib_Results_stereo; % Load the stereo calibration result
    end;
    
end;



fprintf(1,'\nCalculating the rotation to be applied to the right and left images in order to bring the epipolar lines aligned with the horizontal scan lines, and in correspondence...\n\n');

R = rodrigues(om);

% Bring the 2 cameras in the same orientation by rotating them "minimally": 
r_r = rodrigues(-om/2);
r_l = r_r';
t = r_r * T;

% Rotate both cameras so as to bring the translation vector in alignment with the (1;0;0) axis:
if abs(t(1)) > abs(t(2)),
    type_stereo = 0;
    uu = [1;0;0]; % Horizontal epipolar lines
else
    type_stereo = 1;
    uu = [0;1;0]; % Vertical epipolar lines
end;
if dot(uu,t)<0,
    uu = -uu; % Swtich side of the vector 
end;
ww = cross(t,uu);
ww = ww/norm(ww);
ww = acos(abs(dot(t,uu))/(norm(t)*norm(uu)))*ww;
R2 = rodrigues(ww);


% Global rotations to be applied to both views:
R_R = R2 * r_r;
R_L = R2 * r_l;


% The resulting rigid motion between the two cameras after image rotations (substitutes of om, R and T):
R_new = eye(3);
om_new = zeros(3,1);
T_new = R_R*T;



% Computation of the *new* intrinsic parameters for both left and right cameras:

% Vertical focal length *MUST* be the same for both images (here, we are trying to find a focal length that retains as much information contained in the original distorted images):
if kc_left(1) < 0,
    fc_y_left_new = fc_left(2) * (1 + kc_left(1)*(nx^2 + ny^2)/(4*fc_left(2)^2));
else
    fc_y_left_new = fc_left(2);
end;
if kc_right(1) < 0,
    fc_y_right_new = fc_right(2) * (1 + kc_right(1)*(nx^2 + ny^2)/(4*fc_right(2)^2));
else
    fc_y_right_new = fc_right(2);
end;
fc_y_new = min(fc_y_left_new,fc_y_right_new);


% For simplicity, let's pick the same value for the horizontal focal length as the vertical focal length (resulting into square pixels):
fc_left_new = round([fc_y_new;fc_y_new]);
fc_right_new = round([fc_y_new;fc_y_new]);

% Select the new principal points to maximize the visible area in the rectified images

cc_left_new = [(nx-1)/2;(ny-1)/2] - mean(project_points2([normalize_pixel([0  nx-1 nx-1 0; 0 0 ny-1 ny-1],fc_left,cc_left,kc_left,alpha_c_left);[1 1 1 1]],rodrigues(R_L),zeros(3,1),fc_left_new,[0;0],zeros(5,1),0),2);
cc_right_new = [(nx-1)/2;(ny-1)/2] - mean(project_points2([normalize_pixel([0  nx-1 nx-1 0; 0 0 ny-1 ny-1],fc_right,cc_right,kc_right,alpha_c_right);[1 1 1 1]],rodrigues(R_R),zeros(3,1),fc_right_new,[0;0],zeros(5,1),0),2);


% For simplivity, set the principal points for both cameras to be the average of the two principal points.
if ~type_stereo,
    %-- Horizontal stereo
    cc_y_new = (cc_left_new(2) + cc_right_new(2))/2;
    cc_left_new = [cc_left_new(1);cc_y_new];
    cc_right_new = [cc_right_new(1);cc_y_new];
else
    %-- Vertical stereo
    cc_x_new = (cc_left_new(1) + cc_right_new(1))/2;
    cc_left_new = [cc_x_new;cc_left_new(2)];
    cc_right_new = [cc_x_new;cc_right_new(2)];
end;


% Of course, we do not want any skew or distortion after rectification:
alpha_c_left_new = 0;
alpha_c_right_new = 0;
kc_left_new = zeros(5,1);
kc_right_new = zeros(5,1);


% The resulting left and right camera matrices:
KK_left_new = [fc_left_new(1) fc_left_new(1)*alpha_c_left_new cc_left_new(1);0 fc_left_new(2) cc_left_new(2); 0 0 1];
KK_right_new = [fc_right_new(1) fc_right_new(1)*alpha_c_right cc_right_new(1);0 fc_right_new(2) cc_right_new(2); 0 0 1];

% The sizes of the images are the same:
nx_right_new = nx;
ny_right_new = ny;
nx_left_new = nx;
ny_left_new = ny;

% Save the resulting extrinsic and intrinsic paramters into a file:
fprintf(1,'Saving the *NEW* set of intrinsic and extrinsic parameters corresponding to the images *AFTER* rectification under Calib_Results_stereo_rectified.mat...\n\n');
save Calib_Results_stereo_rectified om_new R_new T_new  fc_left_new cc_left_new kc_left_new alpha_c_left_new KK_left_new fc_right_new cc_right_new kc_right_new alpha_c_right_new KK_right_new nx_right_new ny_right_new nx_left_new ny_left_new

% Let's rectify the entire set of calibration images:

fprintf(1,'Pre-computing the necessary data to quickly rectify the images (may take a while depending on the image resolution, but needs to be done only once - even for color images)...\n\n');

% Pre-compute the necessary indices and blending coefficients to enable quick rectification: 
[xLeft, yLeft] = calcRemapTLU(zeros(ny,nx),R_L,fc_left,cc_left,kc_left,alpha_c_left,KK_left_new,qFactor);
[xRight, yRight] = calcRemapTLU(zeros(ny,nx),R_R,fc_right,cc_right,kc_right,alpha_c_right,KK_right_new,qFactor);

% Correct coordinates if they fall outside of the input image
xLeft(xLeft < 0)=0;
xLeft(xLeft >= qFactor*nx)= qFactor*nx - 1;
yLeft(yLeft < 0)=0;
yLeft(yLeft >= qFactor*ny)= qFactor*ny -1;

xyLeft=zeros(1,size(xLeft,2)*2);
xyLeft(1:2:end)= xLeft;
xyLeft(2:2:end)= yLeft;

% Correct coordinates if they fall outside of the input image
xRight(xRight < 0)=0;
xRight(xRight >= qFactor*nx)= qFactor*nx - 1;
yRight(yRight < 0)=0;
yRight(yRight >= qFactor*ny)= qFactor*ny -1;

xyRight=zeros(1,size(xRight,2)*2);
xyRight(1:2:end)= xRight;
xyRight(2:2:end)= yRight;

fid=fopen('rectMapLeft_int.c','w');
fprintf(fid,'#if (!VCOP_HOST_EMULATION)\nfar const\n#endif\n');
fprintf(fid,'unsigned int rectMapLeft_int[%d*%d*2]={\n', nx, ny);
fprintf(fid,'        %d, %d,\n', xyLeft, xyLeft);
fprintf(fid,'};\n');
fclose(fid);
fid=fopen('rectMapRight_int.c','w');
fprintf(fid,'#if (!VCOP_HOST_EMULATION)\nfar const\n#endif\n');
fprintf(fid,'unsigned int rectMapRight_int[%d*%d*2]={\n', nx, ny);
fprintf(fid,'        %d, %d,\n', xyRight, xyRight);
fprintf(fid,'};\n');
fclose(fid);

fid=fopen('rectMapLeft_int.bin','wb');
fwrite(fid, xyLeft, 'uint32');
fclose(fid);

fid=fopen('rectMapRight_int.bin','wb');
fwrite(fid, xyRight, 'uint32');
fclose(fid);

% Calculate indLeft and indRight, which can be used for testing
indLeft= uint32(floor((xLeft./qFactor)) + floor(yLeft./qFactor)*nx) + 1;
indRight= uint32(floor((xRight./qFactor)) + floor(yRight./qFactor)*nx) + 1;

% For testing
%I=loadpgm('left1.pgm');
%J=reshape(I',[1 size(I,1)*size(I,2)]);
%K=J(indLeft);
%L=reshape(K',[size(I,2) size(I,1)])';
%imshow(L,[0 255]);

% From this point, the rest of matlab code deals with invoking a PC
% executable called stereoVision_tb, which converts the 
% file rectMapLeft_int.bin and rectMapLeft_int.bin into EVE
% format for the remap function.
% The path of the executable is provided through the input parameter stereoVision_tb_dir 

disp('Execute stereoVision_tb ... ');

% Modify stereoVision\test\testvecs\config\config_list.txt
configList_path= [stereoVision_tb_dir, '\test\testvecs\config\config_list.txt'];
fid=fopen(configList_path, 'w');
if (fid==-1)
    fprintf(2, 'Could not create file %s\n', configList_path);
end;
fprintf(fid,'1 ../testvecs/config/calib.cfg');
fprintf(fid,'\n0\n');
fclose(fid);

% Get file names of first two calibration images
active_idx= find(active_images);
firstLeftFile= [calib_name_left num2str(active_idx(1)) '.pgm'];
firstRightFile= [calib_name_right num2str(active_idx(1)) '.pgm'];
outputFile= ['disparityMap' num2str(active_idx(1)) '.pgm'];

% create config file for stereoVision_tb
calib_path= [stereoVision_tb_dir, '\test\testvecs\config\calib.cfg'];
fid=fopen(calib_path, 'w');
if (fid==-1)
    fprintf(2, 'Could not create file %s\n', calib_path);
end;
fprintf(fid,'numTestCases = 1\n');
fprintf(fid,'0inImageRight     = "input/TI/right/%s"', firstRightFile);
fprintf(fid,'\n0inImageLeft    = "input/TI/left/%s"', firstLeftFile);
fprintf(fid,'\n0remapLeft      = "input/TI/left/rectMapLeft_int.bin"');
fprintf(fid,'\n0remapRight      = "input/TI/right/rectMapRight_int.bin"');
fprintf(fid,'\n0gtScale		 = 1');
fprintf(fid,'\n0stereoMode		 = "CENSUS"'); 
fprintf(fid,'\n0censusWinWidth  = 9');
fprintf(fid,'\n0censusWinHeight = 9');
fprintf(fid,'\n0censusWinHorzStep = 2');
fprintf(fid,'\n0censusWinVertStep = 2');
fprintf(fid,'\n0disparityWinWidth = 9');
fprintf(fid,'\n0disparityWinHeight = 9');
fprintf(fid,'\n0numDisparities = 128');
fprintf(fid,'\n0disparityStep   = 1');
fprintf(fid,'\n0extraRLdisparities = 0');
fprintf(fid,'\n0maxMinCostRatio = 1.0');
fprintf(fid,'\n0outImage        = "output/TI/%s"', outputFile);
fprintf(fid,'\n0pattern         = 1');
fprintf(fid,'\n0enableRectify   = 1');
fprintf(fid,'\n0isRectifyMapInEveFormat   = 0');
fprintf(fid,'\n0saveRectifyMapInEveFormat  = 1');
fprintf(fid,'\n0remapWidth   = %d',nx);
fprintf(fid,'\n0remapHeight  = %d',ny);
fprintf(fid,'\n0disparityOffset= 0');
fclose(fid);

% Copy rectMapLeft_int.bin and rectMapLeft_int.bin to
% stereoVision\test\testvecs\input\TI\left and
% stereoVision\test\testvecs\input\TI\right
copyfile('rectMapLeft_int.bin',[stereoVision_tb_dir, '\test\testvecs\input\TI\left']);
copyfile('rectMapRight_int.bin',[stereoVision_tb_dir, '\test\testvecs\input\TI\right']);

% Copy first two calibratio images to
% stereoVision\test\testvecs\input\TI\left and
% stereoVision\test\testvecs\input\TI\right
% The disparity map between these two images will be written into
% stereoVision\test\testvecs\input\TI\output
% So you can check quality of disparity map after distorsion correction
copyfile(firstLeftFile,[stereoVision_tb_dir, '\test\testvecs\input\TI\left']);
copyfile(firstRightFile,[stereoVision_tb_dir, '\test\testvecs\input\TI\right']);

% Call stereovision testbench will do 3 things:
% - Produce EVE map of calibration table and saved them in
% rectMapLeft_int_converted.c and rectMapRight_int_converted.c
% - perform rectifications of left and right images
oldFolder= cd([stereoVision_tb_dir '\test\elf_out']);
system('test_stereoVision.eve.out.exe'); 
cd(oldFolder);

% Copy rectMapLeft_int_converted.c and rectMapRight_int_converted.c into output_dir
copyfile([stereoVision_tb_dir, '\test\testvecs\input\TI\left\rectMapLeft_int_converted.c'], output_dir);
copyfile([stereoVision_tb_dir, '\test\testvecs\input\TI\right\rectMapRight_int_converted.c'], output_dir);
disp(' ');
disp('Remap TLUs generated and converted successfully !');



