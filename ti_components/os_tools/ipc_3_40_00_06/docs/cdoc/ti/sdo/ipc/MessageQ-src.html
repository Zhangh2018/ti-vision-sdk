<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>module ti.sdo.ipc.MessageQ</title>
<meta name="googlebot" content="noindex,nofollow">
<link rel="stylesheet" type="text/css" href="../../../src.css"/>
</head>
<body>
<pre class=src>
     1    <span class="comment">/*
</span>     2    <span class="comment"> * Copyright (c) 2012-2015 Texas Instruments Incorporated - http://www.ti.com
</span>     3    <span class="comment"> * All rights reserved.
</span>     4    <span class="comment"> *
</span>     5    <span class="comment"> * Redistribution and use in source and binary forms, with or without
</span>     6    <span class="comment"> * modification, are permitted provided that the following conditions
</span>     7    <span class="comment"> * are met:
</span>     8    <span class="comment"> *
</span>     9    <span class="comment"> * *  Redistributions of source code must retain the above copyright
</span>    10    <span class="comment"> *    notice, this list of conditions and the following disclaimer.
</span>    11    <span class="comment"> *
</span>    12    <span class="comment"> * *  Redistributions in binary form must reproduce the above copyright
</span>    13    <span class="comment"> *    notice, this list of conditions and the following disclaimer in the
</span>    14    <span class="comment"> *    documentation and/or other materials provided with the distribution.
</span>    15    <span class="comment"> *
</span>    16    <span class="comment"> * *  Neither the name of Texas Instruments Incorporated nor the names of
</span>    17    <span class="comment"> *    its contributors may be used to endorse or promote products derived
</span>    18    <span class="comment"> *    from this software without specific prior written permission.
</span>    19    <span class="comment"> *
</span>    20    <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
</span>    21    <span class="comment"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
</span>    22    <span class="comment"> * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
</span>    23    <span class="comment"> * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
</span>    24    <span class="comment"> * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
</span>    25    <span class="comment"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
</span>    26    <span class="comment"> * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
</span>    27    <span class="comment"> * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
</span>    28    <span class="comment"> * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
</span>    29    <span class="comment"> * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
</span>    30    <span class="comment"> * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</span>    31    <span class="comment"> */</span>
    32    <span class="comment">/*
</span>    33    <span class="comment"> *  ======== MessageQ.xdc ========
</span>    34    <span class="comment"> *
</span>    35    <span class="comment"> */</span>
    36    
    37    <span class=key>package</span> ti.sdo.ipc;
    38    
    39    import xdc.runtime.IHeap;
    40    import xdc.runtime.Assert;
    41    import xdc.runtime.Error;
    42    import xdc.runtime.Diags;
    43    import xdc.runtime.Log;
    44    import xdc.runtime.IGateProvider;
    45    import xdc.runtime.knl.ISync;
    46    
    47    import ti.sysbios.syncs.SyncSem;
    48    
    49    import ti.sdo.ipc.interfaces.ITransport;
    50    import ti.sdo.ipc.interfaces.IMessageQTransport;
    51    import ti.sdo.utils.NameServer;
    52    import ti.sdo.utils.List;
    53    
    54    import xdc.rov.ViewInfo;
    55    
    56    <span class="xdoc">/*!
</span>    57    <span class="xdoc"> *  ======== MessageQ ========
</span>    58    <span class="xdoc"> *  Message-passing with queuing
</span>    59    <span class="xdoc"> *
</span>    60    <span class="xdoc"> *  The MessageQ module supports the structured sending and receiving of
</span>    61    <span class="xdoc"> *  variable length messages. This module can be used for homogeneous
</span>    62    <span class="xdoc"> *  (DSP to DSP)  or heterogeneous (Arm to DSP) multi-processor messaging.
</span>    63    <span class="xdoc"> *
</span>    64    <span class="xdoc"> *  MessageQ provides more sophisticated messaging than other modules. It is
</span>    65    <span class="xdoc"> *  typically used for complex situations such as multi-processor messaging.
</span>    66    <span class="xdoc"> *
</span>    67    <span class="xdoc"> *  The following are key features of the MessageQ module:
</span>    68    <span class="xdoc"> *  <b>@p(blist)</b>
</span>    69    <span class="xdoc"> *  -Writers and readers can be relocated to another processor with no
</span>    70    <span class="xdoc"> *   runtime code changes.
</span>    71    <span class="xdoc"> *  -Timeouts are allowed when receiving messages.
</span>    72    <span class="xdoc"> *  -Readers can determine the writer and reply back.
</span>    73    <span class="xdoc"> *  -Receiving a message is deterministic when the timeout is zero.
</span>    74    <span class="xdoc"> *  -Messages can reside on any message queue.
</span>    75    <span class="xdoc"> *  -Supports zero-copy transfers.
</span>    76    <span class="xdoc"> *  -Can send and receive from any type of thread.
</span>    77    <span class="xdoc"> *  -Notification mechanism is specified by application.
</span>    78    <span class="xdoc"> *  -Allows QoS (quality of service) on message buffer pools. For example,
</span>    79    <span class="xdoc"> *   using specific buffer pools for specific message queues.
</span>    80    <span class="xdoc"> *  <b>@p</b>
</span>    81    <span class="xdoc"> *
</span>    82    <span class="xdoc"> *  Messages are sent and received by being placed on and removed from a
</span>    83    <span class="xdoc"> *  message queue. A reader is a thread that gets (reads) messages from a
</span>    84    <span class="xdoc"> *  message queue. A writer is a thread that puts (writes) a message to a
</span>    85    <span class="xdoc"> *  message queue. Each message queue has one reader and can have many writers.
</span>    86    <span class="xdoc"> *  A thread may read from or write to multiple message queues.
</span>    87    <span class="xdoc"> *
</span>    88    <span class="xdoc"> *  Conceptually, the reader thread owns a message queue. The reader thread
</span>    89    <span class="xdoc"> *  creates a message queue. The writer threads open a created message queue
</span>    90    <span class="xdoc"> *  to get access to them.
</span>    91    <span class="xdoc"> *
</span>    92    <span class="xdoc"> *  Message queues are identified by a system-wide unique name. Internally,
</span>    93    <span class="xdoc"> *  MessageQ uses the {<b>@link</b> ti.sdo.utils.NameServer} module for managing
</span>    94    <span class="xdoc"> *  these names. The names are used for opening a message queue.
</span>    95    <span class="xdoc"> *
</span>    96    <span class="xdoc"> *  Messages must be allocated from the MessageQ module. Once a message is
</span>    97    <span class="xdoc"> *  allocated, it can be sent to any message queue. Once a message is sent, the
</span>    98    <span class="xdoc"> *  writer loses ownership of the message and should not attempt to modify the
</span>    99    <span class="xdoc"> *  message. Once the reader receives the message, it owns the message. It
</span>   100    <span class="xdoc"> *  may either free the message or re-use the message.
</span>   101    <span class="xdoc"> *
</span>   102    <span class="xdoc"> *  Messages in a message queue can be of variable length. The only
</span>   103    <span class="xdoc"> *  requirement is that the first field in the definition of a message must be a
</span>   104    <span class="xdoc"> *  {<b>@link</b> #MsgHeader} structure. For example:
</span>   105    <span class="xdoc"> *  <b>@p(code)</b>
</span>   106    <span class="xdoc"> *  typedef struct MyMsg {
</span>   107    <span class="xdoc"> *      MessageQ_MsgHeader header;
</span>   108    <span class="xdoc"> *      ...
</span>   109    <span class="xdoc"> *  } MyMsg;
</span>   110    <span class="xdoc"> *  <b>@p</b>
</span>   111    <span class="xdoc"> *
</span>   112    <span class="xdoc"> *  The MessageQ API uses the MessageQ_MsgHeader internally. Your application
</span>   113    <span class="xdoc"> *  should not modify or directly access the fields in the MessageQ_MsgHeader.
</span>   114    <span class="xdoc"> *
</span>   115    <span class="xdoc"> *  All messages sent via the MessageQ module must be allocated from a
</span>   116    <span class="xdoc"> *  {<b>@link</b> xdc.runtime.IHeap} implementation. The heap can also be used for
</span>   117    <span class="xdoc"> *  other memory allocation not related to MessageQ.
</span>   118    <span class="xdoc"> *
</span>   119    <span class="xdoc"> *  An application can use multiple heaps. The purpose of having multiple
</span>   120    <span class="xdoc"> *  heaps is to allow an application to regulate its message usage. For
</span>   121    <span class="xdoc"> *  example, an application can allocate critical messages from one heap of fast
</span>   122    <span class="xdoc"> *  on-chip memory and non-critical messages from another heap of slower
</span>   123    <span class="xdoc"> *  external memory.
</span>   124    <span class="xdoc"> *
</span>   125    <span class="xdoc"> *  The {<b>@link</b> #registerHeap} and {<b>@link</b> #registerHeapMeta} are APIs used to
</span>   126    <span class="xdoc"> *  assign a MessageQ heapId to a heap. When allocating a message, the heapId
</span>   127    <span class="xdoc"> *  is used, not the heap handle. This heapId is actually placed into the
</span>   128    <span class="xdoc"> *  message (part of the {<b>@link</b> #MsgHeader}). Care must be taken when assigning
</span>   129    <span class="xdoc"> *  heapIds. Refer to the {<b>@link</b> #registerHeap} and {<b>@link</b> #registerHeapMeta}
</span>   130    <span class="xdoc"> *  descriptions for more details.
</span>   131    <span class="xdoc"> *
</span>   132    <span class="xdoc"> *  MessageQ also supports the usage of messages that are not allocated via the
</span>   133    <span class="xdoc"> *  {<b>@link</b> #alloc} function. Please refer to the {<b>@link</b> #staticMsgInit}
</span>   134    <span class="xdoc"> *  function description for more details.
</span>   135    <span class="xdoc"> *
</span>   136    <span class="xdoc"> *  MessageQ supports reads/writes of different thread models. This is
</span>   137    <span class="xdoc"> *  accomplished by having the creator of the message queue specify a
</span>   138    <span class="xdoc"> *  {<b>@link</b> xdc.runtime.knl.ISync#Object} via the {<b>@link</b> #synchronizer}
</span>   139    <span class="xdoc"> *  configuration parameter. The {<b>@link</b> xdc.runtime.knl.ISync#signal}
</span>   140    <span class="xdoc"> *  portion of the ISync instance is called whenever the {<b>@link</b> #put}
</span>   141    <span class="xdoc"> *  is called. The {<b>@link</b> xdc.runtime.knl.ISync#wait} portion is
</span>   142    <span class="xdoc"> *  called in the {<b>@link</b> #get} if and only if there are no messages.
</span>   143    <span class="xdoc"> *
</span>   144    <span class="xdoc"> *  Since ISyncs are binary, the reader must drain the message queue of all
</span>   145    <span class="xdoc"> *  messages before waiting for another signal. For example, if the reader
</span>   146    <span class="xdoc"> *  was a SYSBIOS Swi, the {<b>@link</b> xdc.runtime.knl.ISync} instance
</span>   147    <span class="xdoc"> *  could be a SyncSwi. If a {<b>@link</b> #put} was called, the Swi_post() would
</span>   148    <span class="xdoc"> *  be called. The Swi would run and it must call {<b>@link</b> #get} until no
</span>   149    <span class="xdoc"> *  messages are returned.
</span>   150    <span class="xdoc"> *
</span>   151    <span class="xdoc"> *  In a multiple processor system, MessageQ communicates to other
</span>   152    <span class="xdoc"> *  processors via {<b>@link</b> ti.sdo.ipc.interfaces.IMessageQTransport} instances.
</span>   153    <span class="xdoc"> *  MessageQ supports a high priority and a normal priority transport between
</span>   154    <span class="xdoc"> *  any two processors. The IMessageQTransport instances are created via the
</span>   155    <span class="xdoc"> *  {<b>@link</b> #SetupTransportProxy}. The instances are responsible for
</span>   156    <span class="xdoc"> *  registering themselves with MessageQ. This is accomplished via the
</span>   157    <span class="xdoc"> *  {<b>@link</b> #registerTransport} function.
</span>   158    <span class="xdoc"> *
</span>   159    <span class="xdoc"> *  <b>@a(Note)</b>
</span>   160    <span class="xdoc"> *  This modules reflects upon the {<b>@link</b> ti.sdo.utils.MultiProc#procAddrMode}
</span>   161    <span class="xdoc"> *  configuration parameter. Some internal data structure allocations are
</span>   162    <span class="xdoc"> *  optimized for the given processor address mode. For example, when using
</span>   163    <span class="xdoc"> *  {<b>@link</b> ti.sdo.utils.MultiProc#ProcAddrMode_Global}, a message can be
</span>   164    <span class="xdoc"> *  addressed to any processor using only the destination queueId. However,
</span>   165    <span class="xdoc"> *  when using {<b>@link</b> ti.sdo.utils.MultiProc#ProcAddrMode_Cluster}, only
</span>   166    <span class="xdoc"> *  the processors within your cluster can be addressed using only the
</span>   167    <span class="xdoc"> *  destination queueId. For processors outside the cluster, you must also
</span>   168    <span class="xdoc"> *  specify the Transport ID.
</span>   169    <span class="xdoc"> */</span>
   170    
   171    @ModuleStartup
   172    @InstanceInitError
   173    @InstanceFinalize
   174    
   175    <span class=key>module</span> MessageQ
   176    {
   177        <span class="xdoc">/*!
</span>   178    <span class="xdoc">     *  ======== QueuesView ========
</span>   179    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   180    <span class="xdoc">     */</span>
   181        <span class=key>metaonly</span> <span class=key>struct</span> QueuesView {
   182            String  name;
   183            UInt    queueId;
   184        }
   185    
   186        <span class="xdoc">/*!
</span>   187    <span class="xdoc">     *  ======== MessagesView ========
</span>   188    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   189    <span class="xdoc">     */</span>
   190        <span class=key>metaonly</span> <span class=key>struct</span> MessagesView {
   191            Int          seqNum;
   192            Int          msgSize;
   193            String       priority;
   194            String       srcProc;
   195            String       replyProc;
   196            String       replyId;
   197            Int          msgId;
   198            String       heap;
   199            Bool         traceEnabled;
   200            Int          version;
   201        }
   202    
   203        <span class="xdoc">/*!
</span>   204    <span class="xdoc">     *  ======== ModuleView ========
</span>   205    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   206    <span class="xdoc">     */</span>
   207        <span class=key>metaonly</span> <span class=key>struct</span> ModuleView {
   208            String               heaps[];
   209            String               gate;
   210            UInt16               nextSeqNum;
   211            String               freeHookFxn[];
   212        }
   213    
   214        <span class="xdoc">/*!
</span>   215    <span class="xdoc">     *  ======== rovViewInfo ========
</span>   216    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   217    <span class="xdoc">     */</span>
   218        @Facet
   219        <span class=key>metaonly</span> <span class=key>config</span> xdc.rov.ViewInfo.Instance rovViewInfo =
   220            xdc.rov.ViewInfo.create({
   221                viewMap: [
   222                    [<span class="string">'Queues'</span>,
   223                        {
   224                            type: xdc.rov.ViewInfo.INSTANCE,
   225                            viewInitFxn: <span class="string">'viewInitQueues'</span>,
   226                            structName: <span class="string">'QueuesView'</span>
   227                        }
   228                    ],
   229                    [<span class="string">'Messages'</span>,
   230                        {
   231                            type: xdc.rov.ViewInfo.INSTANCE_DATA,
   232                            viewInitFxn: <span class="string">'viewInitMessages'</span>,
   233                            structName: <span class="string">'MessagesView'</span>
   234                        }
   235                    ],
   236                    [<span class="string">'Module'</span>,
   237                        {
   238                            type: xdc.rov.ViewInfo.MODULE,
   239                            viewInitFxn: <span class="string">'viewInitModule'</span>,
   240                            structName: <span class="string">'ModuleView'</span>
   241                        }
   242                    ]
   243                ]
   244            });
   245    
   246        <span class="xdoc">/*!
</span>   247    <span class="xdoc">     *  ======== LM_setTrace ========
</span>   248    <span class="xdoc">     *  Logged when setting the trace flag on a message
</span>   249    <span class="xdoc">     *
</span>   250    <span class="xdoc">     *  This is logged when tracing on a message is set via
</span>   251    <span class="xdoc">     *  {<b>@link</b> #setMsgTrace}.
</span>   252    <span class="xdoc">     */</span>
   253        <span class=key>config</span> Log.Event LM_setTrace = {
   254            mask: Diags.USER1,
   255            msg: <span class="string">"LM_setTrace: Message 0x%x (seqNum = %d, srcProc = %d) traceFlag = %d"</span>
   256        };
   257    
   258        <span class="xdoc">/*!
</span>   259    <span class="xdoc">     *  ======== LM_alloc ========
</span>   260    <span class="xdoc">     *  Logged when allocating a message
</span>   261    <span class="xdoc">     *
</span>   262    <span class="xdoc">     *  When the {<b>@link</b> #traceFlag} is true, all message allocations
</span>   263    <span class="xdoc">     *  are logged.
</span>   264    <span class="xdoc">     */</span>
   265        <span class=key>config</span> Log.Event LM_alloc = {
   266            mask: Diags.USER1,
   267            msg: <span class="string">"LM_alloc: Message 0x%x (seqNum = %d, srcProc = %d) was allocated"</span>
   268        };
   269    
   270        <span class="xdoc">/*!
</span>   271    <span class="xdoc">     *  ======== LM_staticMsgInit ========
</span>   272    <span class="xdoc">     *  Logged when statically initializing a message
</span>   273    <span class="xdoc">     *
</span>   274    <span class="xdoc">     *  When the {<b>@link</b> #traceFlag} is true, all messages that
</span>   275    <span class="xdoc">     *  are statically initialized via {<b>@link</b> #staticMsgInit} are logged.
</span>   276    <span class="xdoc">     */</span>
   277        <span class=key>config</span> Log.Event LM_staticMsgInit = {
   278            mask: Diags.USER1,
   279            msg: <span class="string">"LM_staticMsgInit: Message 0x%x (seqNum = %d, srcProc = %d) was set in MessageQ_staticMsgInit"</span>
   280        };
   281    
   282        <span class="xdoc">/*!
</span>   283    <span class="xdoc">     *  ======== LM_free ========
</span>   284    <span class="xdoc">     *  Logged when freeing a message
</span>   285    <span class="xdoc">     *
</span>   286    <span class="xdoc">     *  When the {<b>@link</b> #traceFlag} is true, all freeing of messages
</span>   287    <span class="xdoc">     *  are logged. If an individual message's tracing was enabled
</span>   288    <span class="xdoc">     *  via {<b>@link</b> #setMsgTrace}, the MessageQ_free is also logged.
</span>   289    <span class="xdoc">     */</span>
   290        <span class=key>config</span> Log.Event LM_free = {
   291            mask: Diags.USER1,
   292            msg: <span class="string">"LM_free: Message 0x%x (seqNum = %d, srcProc = %d) was freed"</span>
   293        };
   294    
   295        <span class="xdoc">/*!
</span>   296    <span class="xdoc">     *  ======== LM_putLocal ========
</span>   297    <span class="xdoc">     *  Logged when a message is placed onto a local queue
</span>   298    <span class="xdoc">     *
</span>   299    <span class="xdoc">     *  When the {<b>@link</b> #traceFlag} is true, all putting of messages
</span>   300    <span class="xdoc">     *  are logged. If an individual message's tracing was enabled
</span>   301    <span class="xdoc">     *  via {<b>@link</b> #setMsgTrace}, the MessageQ_put is also logged.
</span>   302    <span class="xdoc">     */</span>
   303        <span class=key>config</span> Log.Event LM_putLocal = {
   304            mask: Diags.USER1,
   305            msg: <span class="string">"LM_putLocal: Message 0x%x (seqNum = %d, srcProc = %d) was placed onto queue 0x%x"</span>
   306        };
   307    
   308        <span class="xdoc">/*!
</span>   309    <span class="xdoc">     *  ======== LM_putRemote ========
</span>   310    <span class="xdoc">     *  Logged when a message is given to a transport
</span>   311    <span class="xdoc">     *
</span>   312    <span class="xdoc">     *  When the {<b>@link</b> #traceFlag} is true, all putting of messages
</span>   313    <span class="xdoc">     *  to a transport are logged. If an individual message's tracing
</span>   314    <span class="xdoc">     *  was enabled  via {<b>@link</b> #setMsgTrace}, the MessageQ_put is
</span>   315    <span class="xdoc">     *  also logged.
</span>   316    <span class="xdoc">     */</span>
   317        <span class=key>config</span> Log.Event LM_putRemote = {
   318            mask: Diags.USER1,
   319            msg: <span class="string">"LM_putRemote: Message 0x%x (seqNum = %d, srcProc = %d) was given to processor %d transport"</span>
   320        };
   321    
   322        <span class="xdoc">/*!
</span>   323    <span class="xdoc">     *  ======== LM_rcvByTransport ========
</span>   324    <span class="xdoc">     *  Logged when a transport receives an incoming message
</span>   325    <span class="xdoc">     *
</span>   326    <span class="xdoc">     *  When the {<b>@link</b> #traceFlag} is true, all incoming messages
</span>   327    <span class="xdoc">     *  are logged. If an individual message's tracing
</span>   328    <span class="xdoc">     *  was enabled  via {<b>@link</b> #setMsgTrace}, the receiving of a message is
</span>   329    <span class="xdoc">     *  also logged.
</span>   330    <span class="xdoc">     */</span>
   331        <span class=key>config</span> Log.Event LM_rcvByTransport = {
   332            mask: Diags.USER1,
   333            msg: <span class="string">"LM_rcvByTransport: Message 0x%x (seqNum = %d, srcProc = %d) was received"</span>
   334        };
   335    
   336        <span class="xdoc">/*!
</span>   337    <span class="xdoc">     *  ======== LM_get ========
</span>   338    <span class="xdoc">     *  Logged when a message is received off the queue
</span>   339    <span class="xdoc">     *
</span>   340    <span class="xdoc">     *  When the {<b>@link</b> #traceFlag} is true, all getting of messages
</span>   341    <span class="xdoc">     *  are logged. If an individual message's tracing
</span>   342    <span class="xdoc">     *  was enabled  via {<b>@link</b> #setMsgTrace}, the MessageQ_get is
</span>   343    <span class="xdoc">     *  also logged.
</span>   344    <span class="xdoc">     */</span>
   345        <span class=key>config</span> Log.Event LM_get = {
   346            mask: Diags.USER1,
   347            msg: <span class="string">"LM_get: Message 0x%x (seqNum = %d, srcProc = %d) was received by queue 0x%x"</span>
   348        };
   349    
   350        <span class="xdoc">/*!
</span>   351    <span class="xdoc">     *  ======== FreeHookFxn ========
</span>   352    <span class="xdoc">     *  Function prototype for the MessageQ_free callback
</span>   353    <span class="xdoc">     *
</span>   354    <span class="xdoc">     *  <b>@param(Bits16)</b>  heapId of message that was freed
</span>   355    <span class="xdoc">     *  <b>@param(Bits16)</b>  msgId of message that was freed
</span>   356    <span class="xdoc">     */</span>
   357        <span class=key>typedef</span> Void (*FreeHookFxn)(Bits16, Bits16);
   358    
   359        <span class="xdoc">/*!
</span>   360    <span class="xdoc">     *  ======== PutHookFxn ========
</span>   361    <span class="xdoc">     *  Function prototype for the MessageQ_put callback
</span>   362    <span class="xdoc">     *
</span>   363    <span class="xdoc">     *  <b>@param(Bits32)</b>  queueId of the destination message queue
</span>   364    <span class="xdoc">     *  <b>@param(Ptr)</b>     pointer to a message header structure
</span>   365    <span class="xdoc">     */</span>
   366        <span class=key>typedef</span> Void (*PutHookFxn)(Bits32, Ptr);
   367    
   368        <span class="xdoc">/*! MessageQ ID */</span>
   369        <span class=key>typedef</span> UInt32 QueueId;
   370    
   371        <span class="xdoc">/*!
</span>   372    <span class="xdoc">     *  ======== SetupTransportProxy ========
</span>   373    <span class="xdoc">     *  MessageQ transport setup proxy
</span>   374    <span class="xdoc">     */</span>
   375        <span class=key>proxy</span> SetupTransportProxy <span class=key>inherits</span> ti.sdo.ipc.interfaces.ITransportSetup;
   376    
   377        <span class="xdoc">/*!
</span>   378    <span class="xdoc">     *  Message priority values. These must match the values defined in
</span>   379    <span class="xdoc">     *  ti/ipc/MessageQ.h but are needed here for ROV.
</span>   380    <span class="xdoc">     */</span>
   381        <span class=key>const</span> UInt NORMALPRI   = 0;
   382        <span class=key>const</span> UInt HIGHPRI     = 1;
   383        <span class=key>const</span> UInt RESERVEDPRI = 2;
   384        <span class=key>const</span> UInt URGENTPRI   = 3;
   385    
   386        <span class="xdoc">/*!
</span>   387    <span class="xdoc">     *  Denotes any queueId is acceptable
</span>   388    <span class="xdoc">     *
</span>   389    <span class="xdoc">     *  This constant is the default for the {<b>@link</b> #queueId} parameter.
</span>   390    <span class="xdoc">     *  This value must match ti/ipc/MessageQ.h but is needed to initialize
</span>   391    <span class="xdoc">     *  queueId.
</span>   392    <span class="xdoc">     */</span>
   393        <span class=key>const</span> Bits16 ANY = ~(0);
   394    
   395        <span class="xdoc">/*!
</span>   396    <span class="xdoc">     *  Assert raised when calling API with wrong handle
</span>   397    <span class="xdoc">     *
</span>   398    <span class="xdoc">     *  Some APIs can only be called with an opened handle (e.g.
</span>   399    <span class="xdoc">     *  {<b>@link</b> #close}. Some can only be called with a created handle
</span>   400    <span class="xdoc">     *  (e.g. {<b>@link</b> #get}).
</span>   401    <span class="xdoc">     */</span>
   402        <span class=key>config</span> Assert.Id A_invalidContext  = {
   403            msg: <span class="string">"A_invalidContext: Cannot call with an open/create handle"</span>
   404        };
   405    
   406        <span class="xdoc">/*!
</span>   407    <span class="xdoc">     *  Assert raised when attempting to free a static message
</span>   408    <span class="xdoc">     */</span>
   409        <span class=key>config</span> Assert.Id A_cannotFreeStaticMsg  = {
   410            msg: <span class="string">"A_cannotFreeStaticMsg: Cannot call MessageQ_free with static msg"</span>
   411        };
   412    
   413        <span class="xdoc">/*!
</span>   414    <span class="xdoc">     *  Assert raised when an invalid message is supplied
</span>   415    <span class="xdoc">     */</span>
   416        <span class=key>config</span> Assert.Id A_invalidMsg  = {
   417            msg: <span class="string">"A_invalidMsg: Invalid message"</span>
   418        };
   419    
   420        <span class="xdoc">/*!
</span>   421    <span class="xdoc">     *  Assert raised when an invalid queueId is supplied
</span>   422    <span class="xdoc">     */</span>
   423        <span class=key>config</span> Assert.Id A_invalidQueueId  = {
   424            msg: <span class="string">"A_invalidQueueId: Invalid queueId is used"</span>
   425        };
   426    
   427        <span class="xdoc">/*!
</span>   428    <span class="xdoc">     *  Assert raised when using an invalid heapId
</span>   429    <span class="xdoc">     */</span>
   430        <span class=key>config</span> Assert.Id A_heapIdInvalid  = {
   431            msg: <span class="string">"A_heapIdInvalid: heapId is invalid"</span>
   432        };
   433    
   434        <span class="xdoc">/*!
</span>   435    <span class="xdoc">     *  Assert raised when using an invalid procId
</span>   436    <span class="xdoc">     */</span>
   437        <span class=key>config</span> Assert.Id A_procIdInvalid  = {
   438            msg: <span class="string">"A_procIdInvalid: procId is invalid"</span>
   439        };
   440    
   441        <span class="xdoc">/*!
</span>   442    <span class="xdoc">     *  Assert raised for an invalid MessageQ object
</span>   443    <span class="xdoc">     */</span>
   444        <span class=key>config</span> Assert.Id A_invalidObj  = {
   445            msg: <span class="string">"A_invalidObj: an invalid obj is used"</span>
   446        };
   447    
   448        <span class="xdoc">/*!
</span>   449    <span class="xdoc">     *  Assert raised for an invalid parameter
</span>   450    <span class="xdoc">     */</span>
   451        <span class=key>config</span> Assert.Id A_invalidParam  = {
   452            msg: <span class="string">"A_invalidParam: an invalid parameter was passed in"</span>
   453        };
   454    
   455        <span class="xdoc">/*!
</span>   456    <span class="xdoc">     *  Assert raised when attempting to send a message to a core
</span>   457    <span class="xdoc">     *  where a transport has not been registered.
</span>   458    <span class="xdoc">     */</span>
   459        <span class=key>config</span> Assert.Id A_unregisteredTransport  = {
   460            msg: <span class="string">"A_unregisteredTransport: transport is not registered"</span>
   461        };
   462    
   463        <span class="xdoc">/*!
</span>   464    <span class="xdoc">     *  Assert raised when attempting to unblock a remote MessageQ or one that
</span>   465    <span class="xdoc">     *  has been configured with a non-blocking synchronizer
</span>   466    <span class="xdoc">     */</span>
   467        <span class=key>config</span> Assert.Id A_invalidUnblock  = {
   468            msg: <span class="string">"A_invalidUnblock: Trying to unblock a remote MessageQ or a queue with non-blocking synchronizer"</span>
   469        };
   470    
   471        <span class="xdoc">/*!
</span>   472    <span class="xdoc">     *  Error raised if all the message queue objects are taken
</span>   473    <span class="xdoc">     */</span>
   474        <span class=key>config</span> Error.Id E_maxReached  = {
   475            msg: <span class="string">"E_maxReached: All objects in use. MessageQ.maxRuntimeEntries is %d"</span>
   476        };
   477    
   478        <span class="xdoc">/*!
</span>   479    <span class="xdoc">     *  Error raised when heapId has not been registered
</span>   480    <span class="xdoc">     */</span>
   481        <span class=key>config</span> Error.Id E_unregisterHeapId  = {
   482            msg: <span class="string">"E_unregisterHeapId: Heap id %d not registered"</span>
   483        };
   484    
   485        <span class="xdoc">/*!
</span>   486    <span class="xdoc">     *  Error raised in a create call when a name fails to be added
</span>   487    <span class="xdoc">     *  to the NameServer table.  This can be because the name already
</span>   488    <span class="xdoc">     *  exists, the table has reached its max length, or out of memory.
</span>   489    <span class="xdoc">     */</span>
   490        <span class=key>config</span> Error.Id E_nameFailed  = {
   491            msg: <span class="string">"E_nameFailed: '%s' name failed to be added to NameServer"</span>
   492        };
   493    
   494        <span class="xdoc">/*!
</span>   495    <span class="xdoc">     *  Error raised if the requested queueIndex is not available
</span>   496    <span class="xdoc">     */</span>
   497        <span class=key>config</span> Error.Id E_indexNotAvailable  = {
   498            msg: <span class="string">"E_indexNotAvailable: queueIndex %d not available"</span>
   499        };
   500    
   501        <span class="xdoc">/*!
</span>   502    <span class="xdoc">     *  Trace setting
</span>   503    <span class="xdoc">     *
</span>   504    <span class="xdoc">     *  This flag allows the configuration of the default module trace
</span>   505    <span class="xdoc">     *  settings.
</span>   506    <span class="xdoc">     */</span>
   507        <span class=key>config</span> Bool traceFlag = <span class=key>false</span>;
   508    
   509        <span class="xdoc">/*!
</span>   510    <span class="xdoc">     *  Number of heapIds in the system
</span>   511    <span class="xdoc">     *
</span>   512    <span class="xdoc">     *  This allows MessageQ to pre-allocate the heaps table.
</span>   513    <span class="xdoc">     *  The heaps table is used when registering heaps.
</span>   514    <span class="xdoc">     *
</span>   515    <span class="xdoc">     *  There is no default heap, so unless the system is only using
</span>   516    <span class="xdoc">     *  {<b>@link</b> #staticMsgInit}, the application must register a heap.
</span>   517    <span class="xdoc">     */</span>
   518        <span class=key>config</span> UInt16 numHeaps = 8;
   519    
   520        <span class="xdoc">/*!
</span>   521    <span class="xdoc">     *  Maximum number of MessageQs that can be dynamically created
</span>   522    <span class="xdoc">     */</span>
   523        <span class=key>config</span> UInt maxRuntimeEntries = NameServer.ALLOWGROWTH;
   524    
   525        <span class="xdoc">/*!
</span>   526    <span class="xdoc">     *  Number of reserved MessageQ indexes
</span>   527    <span class="xdoc">     *
</span>   528    <span class="xdoc">     *  An application can request the first N message queue indexes be
</span>   529    <span class="xdoc">     *  reserved to be used by MessageQ_create2. MessageQ_create will
</span>   530    <span class="xdoc">     *  not use these slots. The application can use any index less than
</span>   531    <span class="xdoc">     *  the value of numReservedEntries for the queueIndex field in the
</span>   532    <span class="xdoc">     *  MessageQ_Params2 structure.
</span>   533    <span class="xdoc">     *
</span>   534    <span class="xdoc">     *  numReservedEntries must be equal or less than
</span>   535    <span class="xdoc">     *  {<b>@link</b> #maxRuntimeEntries}.
</span>   536    <span class="xdoc">     */</span>
   537        <span class=key>config</span> UInt numReservedEntries = 0;
   538    
   539        <span class="xdoc">/*!
</span>   540    <span class="xdoc">     *  Gate used to make the name table thread safe
</span>   541    <span class="xdoc">     *
</span>   542    <span class="xdoc">     *  This gate is used when accessing the name table during
</span>   543    <span class="xdoc">     *  a {<b>@link</b> #create}, {<b>@link</b> #delete}, and {<b>@link</b> #open}.
</span>   544    <span class="xdoc">     *
</span>   545    <span class="xdoc">     *  This gate is also used to protect MessageQ when growing
</span>   546    <span class="xdoc">     *  internal tables in the {<b>@link</b> #create}.
</span>   547    <span class="xdoc">     *
</span>   548    <span class="xdoc">     *  The table is in local memory, not shared memory. So a
</span>   549    <span class="xdoc">     *  single processor gate will work.
</span>   550    <span class="xdoc">     *
</span>   551    <span class="xdoc">     *  The default will be {<b>@link</b> xdc.runtime.knl.GateThread}
</span>   552    <span class="xdoc">     *  instance.
</span>   553    <span class="xdoc">     */</span>
   554        <span class=key>config</span> IGateProvider.Handle nameTableGate = <span class=key>null</span>;
   555    
   556        <span class="xdoc">/*!
</span>   557    <span class="xdoc">     *  Maximum length for Message queue names
</span>   558    <span class="xdoc">     */</span>
   559        <span class=key>config</span> UInt maxNameLen = 32;
   560    
   561        <span class="xdoc">/*!
</span>   562    <span class="xdoc">     *  Section name is used to place the names table
</span>   563    <span class="xdoc">     */</span>
   564        <span class=key>metaonly</span> <span class=key>config</span> String tableSection = <span class=key>null</span>;
   565    
   566        <span class="xdoc">/*!
</span>   567    <span class="xdoc">     *  ======== freeHookFxn ========
</span>   568    <span class="xdoc">     *  Free function in MessageQ_free after message was freed back to the heap
</span>   569    <span class="xdoc">     */</span>
   570        <span class=key>config</span> FreeHookFxn freeHookFxn = <span class=key>null</span>;
   571    
   572        <span class="xdoc">/*!
</span>   573    <span class="xdoc">     *  ======== putHookFxn ========
</span>   574    <span class="xdoc">     *  Put function hook
</span>   575    <span class="xdoc">     */</span>
   576        <span class=key>config</span> PutHookFxn putHookFxn = <span class=key>null</span>;
   577    
   578        <span class="xdoc">/*!
</span>   579    <span class="xdoc">     *  ======== registerHeapMeta ========
</span>   580    <span class="xdoc">     *  Statically register a heap with MessageQ
</span>   581    <span class="xdoc">     *
</span>   582    <span class="xdoc">     *  Build error if heapId is in use.
</span>   583    <span class="xdoc">     *
</span>   584    <span class="xdoc">     *  <b>@param(heap)</b>        Heap to register
</span>   585    <span class="xdoc">     *  <b>@param(heapId)</b>      heapId associated with the heap
</span>   586    <span class="xdoc">     */</span>
   587        <span class=key>metaonly</span> Void registerHeapMeta(IHeap.Handle heap, UInt16 heapId);
   588    
   589         <span class="xdoc">/*!
</span>   590    <span class="xdoc">     *  ======== registerTransportMeta ========
</span>   591    <span class="xdoc">     *  Statically register a transport with MessageQ
</span>   592    <span class="xdoc">     *
</span>   593    <span class="xdoc">     *  Build error if remote processor already has a transport
</span>   594    <span class="xdoc">     *  registered.
</span>   595    <span class="xdoc">     *
</span>   596    <span class="xdoc">     *  <b>@param(transport)</b>   transport to register
</span>   597    <span class="xdoc">     *  <b>@param(procId)</b>      procId that transport communicaties with
</span>   598    <span class="xdoc">     *  <b>@param(priority)</b>    priority of transport
</span>   599    <span class="xdoc">     */</span>
   600         <span class=key>metaonly</span> Void registerTransportMeta(IMessageQTransport.Handle transport,
   601                 UInt16 procId, UInt priority);
   602    
   603        <span class="xdoc">/*!
</span>   604    <span class="xdoc">     *  ======== registerTransport ========
</span>   605    <span class="xdoc">     *  Register a transport with MessageQ
</span>   606    <span class="xdoc">     *
</span>   607    <span class="xdoc">     *  This API is called by the transport when it is created.
</span>   608    <span class="xdoc">     *
</span>   609    <span class="xdoc">     *  <b>@param(transport)</b>   transport to register
</span>   610    <span class="xdoc">     *  <b>@param(procId)</b>      MultiProc id that transport communicates with
</span>   611    <span class="xdoc">     *  <b>@param(priority)</b>    priority of transport
</span>   612    <span class="xdoc">     *
</span>   613    <span class="xdoc">     *  <b>@b(returns)</b>         Whether the register was successful.
</span>   614    <span class="xdoc">     */</span>
   615        Bool registerTransport(IMessageQTransport.Handle transport, UInt16 procId,
   616            UInt priority);
   617    
   618        <span class="xdoc">/*!
</span>   619    <span class="xdoc">     *  ======== unregisterTransport ========
</span>   620    <span class="xdoc">     *  Unregister a transport with MessageQ
</span>   621    <span class="xdoc">     *
</span>   622    <span class="xdoc">     *  <b>@param(procId)</b>      unregister transport that communicates with
</span>   623    <span class="xdoc">     *                      this remote processor
</span>   624    <span class="xdoc">     *  <b>@param(priority)</b>    priority of transport
</span>   625    <span class="xdoc">     */</span>
   626        Void unregisterTransport(UInt16 procId, UInt priority);
   627    
   628    <span class=key>instance</span>:
   629    
   630        <span class="xdoc">/*!
</span>   631    <span class="xdoc">     *  ISync handle used to signal IO completion
</span>   632    <span class="xdoc">     *
</span>   633    <span class="xdoc">     *  The ISync instance is used in the {<b>@link</b> #get} and {<b>@link</b> #put}.
</span>   634    <span class="xdoc">     *  The {<b>@link</b> xdc.runtime.knl.ISync#signal} is called as part
</span>   635    <span class="xdoc">     *  of the {<b>@link</b> #put} call.  The {<b>@link</b> xdc.runtime.knl.ISync#wait} is
</span>   636    <span class="xdoc">     *  called in the {<b>@link</b> #get} if there are no messages present.
</span>   637    <span class="xdoc">     */</span>
   638        <span class=key>config</span> ISync.Handle synchronizer = <span class=key>null</span>;
   639    
   640        <span class="xdoc">/*!
</span>   641    <span class="xdoc">     *  Requested MessageQ_QueueIndex
</span>   642    <span class="xdoc">     *
</span>   643    <span class="xdoc">     *  This parameter allows an application to specify the queueIndex to
</span>   644    <span class="xdoc">     *  be used for a message queue. To use this functionality, the
</span>   645    <span class="xdoc">     *  MessageQ.numReservedEntries static configuration parameter must be
</span>   646    <span class="xdoc">     *  set to a specific value.
</span>   647    <span class="xdoc">     *
</span>   648    <span class="xdoc">     *  The default is {<b>@link</b> #ANY}. This means do that you are not asking for
</span>   649    <span class="xdoc">     *  an explicit index. MessageQ will find the first available one which is
</span>   650    <span class="xdoc">     *  equal or greater than MessageQ.numReservedEntries.
</span>   651    <span class="xdoc">     */</span>
   652        <span class=key>config</span> UInt16 queueIndex = ANY;
   653    
   654        <span class="xdoc">/*! <b>@_nodoc</b>
</span>   655    <span class="xdoc">     *  ======== create ========
</span>   656    <span class="xdoc">     *  Create a message queue
</span>   657    <span class="xdoc">     *
</span>   658    <span class="xdoc">     *  <b>@param(name)</b>         Name of the message queue.
</span>   659    <span class="xdoc">     */</span>
   660        create(String name);
   661    
   662    <span class=key>internal</span>:
   663        <span class="comment">/*
</span>   664    <span class="comment">     *  The following describes the usage of the flag field
</span>   665    <span class="comment">     *  ---------------------------------
</span>   666    <span class="comment">     *  |V V V|T|  reserved   |t t t|P P|
</span>   667    <span class="comment">     *  ---------------------------------
</span>   668    <span class="comment">     *   F E D C B A 9 8 7 6 5 4 3 2 1 0
</span>   669    <span class="comment">     *
</span>   670    <span class="comment">     *  [15:13] V = version
</span>   671    <span class="comment">     *  [12]    T = trace flag
</span>   672    <span class="comment">     *  [11:5]  reserved
</span>   673    <span class="comment">     *  [4:2]   t = transport Id, zero = default
</span>   674    <span class="comment">     *  [1:0]   P = priority
</span>   675    <span class="comment">     */</span>
   676    
   677        <span class="xdoc">/*! Mask to extract version setting */</span>
   678        <span class=key>const</span> UInt VERSIONMASK = 0xE000;
   679    
   680        <span class="xdoc">/*! Version setting */</span>
   681        <span class=key>const</span> UInt HEADERVERSION = 0x2000;
   682    
   683        <span class="xdoc">/*! Mask to extract Trace setting */</span>
   684        <span class=key>const</span> UInt TRACEMASK = 0x1000;
   685    
   686        <span class="xdoc">/*! Shift for Trace setting */</span>
   687        <span class=key>const</span> UInt TRACESHIFT = 12;
   688    
   689        <span class="xdoc">/*!
</span>   690    <span class="xdoc">     *  Mask to extract priority setting.
</span>   691    <span class="xdoc">     *  This is needed here for ROV but must match
</span>   692    <span class="xdoc">     *  the value defined in ti/ipc/MessageQ.h
</span>   693    <span class="xdoc">     */</span>
   694        <span class=key>const</span> UInt PRIORITYMASK = 0x3;
   695    
   696        <span class="xdoc">/*! Mask to extract priority setting */</span>
   697        <span class=key>const</span> UInt TRANSPORTPRIORITYMASK = 0x1;
   698    
   699         <span class="xdoc">/*! return code for Instance_init */</span>
   700        <span class=key>const</span> Int PROXY_FAILURE = 1;
   701    
   702        <span class="comment">/*
</span>   703    <span class="comment">     *  Used to denote a message that was initialized
</span>   704    <span class="comment">     *  with the MessageQ_staticMsgInit function.
</span>   705    <span class="comment">     */</span>
   706        <span class=key>const</span> UInt16 STATICMSG = 0xFFFF;
   707    
   708        <span class="xdoc">/*! Required first field in every message */</span>
   709        @Opaque <span class=key>struct</span> MsgHeader {
   710            Bits32       reserved0;         <span class="comment">/* reserved for List.elem-&gt;next */</span>
   711            Bits32       reserved1;         <span class="comment">/* reserved for List.elem-&gt;prev */</span>
   712            Bits32       msgSize;           <span class="comment">/* message size                 */</span>
   713            Bits16       flags;             <span class="comment">/* bitmask of different flags   */</span>
   714            Bits16       msgId;             <span class="comment">/* message id                   */</span>
   715            Bits16       dstId;             <span class="comment">/* destination queue id         */</span>
   716            Bits16       dstProc;           <span class="comment">/* destination processor id     */</span>
   717            Bits16       replyId;           <span class="comment">/* reply queue id               */</span>
   718            Bits16       replyProc;         <span class="comment">/* reply processor id           */</span>
   719            Bits16       srcProc;           <span class="comment">/* proc who initialized the msg */</span>
   720            Bits16       heapId;            <span class="comment">/* heap id                      */</span>
   721            Bits16       seqNum;            <span class="comment">/* sequence number              */</span>
   722            Bits16       reserved;          <span class="comment">/* reserved                     */</span>
   723        };
   724    
   725        <span class=key>struct</span> HeapEntry {
   726            IHeap.Handle  heap;
   727            UInt16        heapId;
   728        };
   729    
   730        <span class=key>struct</span> TransportEntry {
   731            IMessageQTransport.Handle  transport;
   732            UInt16             procId;
   733        };
   734    
   735        <span class=key>enum</span> TransportType {
   736            TransportType_IMessageQTransport,
   737            TransportType_INetworkTransport,
   738            TransportType_Invalid
   739        };
   740    
   741        <span class=key>struct</span> RegisteredTransport {
   742            ITransport.Handle transport;
   743            TransportType type;
   744        };
   745    
   746        <span class="xdoc">/*!
</span>   747    <span class="xdoc">     *  ======== nameSrvPrms ========
</span>   748    <span class="xdoc">     *  This Params object is used for temporary storage of the
</span>   749    <span class="xdoc">     *  module wide parameters that are for setting the NameServer instance.
</span>   750    <span class="xdoc">     */</span>
   751        <span class=key>metaonly</span> <span class=key>config</span> NameServer.Params nameSrvPrms;
   752    
   753        <span class="xdoc">/*!
</span>   754    <span class="xdoc">     *  Statically registered heaps
</span>   755    <span class="xdoc">     *
</span>   756    <span class="xdoc">     *  This configuration parameter allows the static registeration
</span>   757    <span class="xdoc">     *  of heaps. The index of the array corresponds to the heapId.
</span>   758    <span class="xdoc">     */</span>
   759        <span class=key>metaonly</span> <span class=key>config</span> HeapEntry staticHeaps[];
   760    
   761        <span class="xdoc">/*!
</span>   762    <span class="xdoc">     *  Statically registered transports
</span>   763    <span class="xdoc">     *
</span>   764    <span class="xdoc">     *  This configuration parameter allows the static registeration
</span>   765    <span class="xdoc">     *  of transports. The index of the array corresponds to the procId.
</span>   766    <span class="xdoc">     */</span>
   767        <span class=key>metaonly</span> <span class=key>config</span> TransportEntry staticTransports[];
   768    
   769        <span class="xdoc">/*!
</span>   770    <span class="xdoc">     *  Allows for the number of dynamically created message queues to grow.
</span>   771    <span class="xdoc">     */</span>
   772        UInt16 grow(Object *obj, Error.Block *eb);
   773    
   774        <span class=key>struct</span> Instance_State {
   775            QueueId         queue;        <span class="comment">/* Unique id                     */</span>
   776            ISync.Handle    synchronizer; <span class="comment">/* completion synchronizer       */</span>
   777            List.Object     normalList;   <span class="comment">/* Embedded List objects         */</span>
   778            List.Object     highList;     <span class="comment">/* Embedded List objects         */</span>
   779            Ptr             nsKey;        <span class="comment">/* unique NameServer key         */</span>
   780            SyncSem.Handle  syncSemHandle;<span class="comment">/* for use in finalize           */</span>
   781            Bool            unblocked;    <span class="comment">/* Whether MessageQ is unblocked */</span>
   782        };
   783    
   784        <span class=key>struct</span> Module_State {
   785            IMessageQTransport.Handle transports[<span class=key>length</span>][2];
   786            Handle               queues[];
   787            IHeap.Handle         heaps[];
   788            IGateProvider.Handle gate;
   789            UInt16               numQueues;
   790            UInt16               numHeaps;
   791            NameServer.Handle    nameServer;
   792            FreeHookFxn          freeHookFxn;
   793            PutHookFxn           putHookFxn;
   794            Bool                 canFreeQueues;
   795            UInt16               seqNum;
   796            RegisteredTransport  regTrans[8];
   797        };
   798    }
</pre>
</body></html>
